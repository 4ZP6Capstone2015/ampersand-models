{----------------------------------------------------------------------
Revision history
20110326 - Inspiration from techneutenweekend and discussions with Bas about
           the implementation of services and UI-components in the context of a user session.

----------------------------------------------------------------------}
-- Markup uses `reStructuredTexts <http://docutils.sourceforge.net/docs/user/rst/quickref.html>`__
-----------------------------------------------------------------------

CONTEXT RAP

PATTERN Portals

PURPOSE PATTERN Portals IN ENGLISH
{+This pattern was made in the process of building services into RAP.
The problem at hand is to invent how user interface components relate to services
such that portals can be generated automatically.
The Ampersand script specifies user interface components on top of the language defined in patterns.
So that is the starting point of our reasoning.
-}

CONCEPT Person "an identifier that represents a registered user." ""
PURPOSE CONCEPT Person IN ENGLISH
{+RAP might possibly follow the habit of some internet applications to identify a person with his or her e-mail address.
We haven't decided yet.
In this pattern, we will not worry about that and just take persons as a concept.
-}

CONCEPT Role "a name that serves as a placeholder for a person." ""
PURPOSE CONCEPT Role IN ENGLISH
{+Roles are used in an Ampersand script to define who will maintain which rules.
-}

CONCEPT Rule "a term that is meant to be true." ""
PURPOSE CONCEPT Rule IN ENGLISH
{+Ampersand helps people to live by their own rules.
Rules followed by people are called "process rules".
Ampersand helps people to make these rules come true,
by signalling the cases that still need attention.
Rules that are not maintained by people are maintained by a computer.
Those rules cannot be broken and remain true all the time (in the perception of users).
-}

CONCEPT Portal "the user interface used in a session, which is not part of another user interface." ""
PURPOSE CONCEPT Portal IN ENGLISH
{+The outermost user interface that is used in a session is called the portal.
This definition allows for portals on a computer, on other devices such as handhelds, virtual devices such as remote login sessions, etcetera.
However, the outermost user interface (from the session's perspective) is meant.
-}

CONCEPT UIcomp "a software component of an information system that allows a user to communicate with that system." ""
PURPOSE CONCEPT UIcomp IN ENGLISH
{+User interface components are needed for interaction with users.
The concept UIcomp is introduced for this purpose.
-}

GEN Portal ISA UIcomp

in :: UIcomp * UIcomp PRAGMA "" "is part of"
PURPOSE RELATION in[UIcomp*UIcomp] IN ENGLISH
{+User interface components are defined in a hierarchical structure, allowing complex portals to be built as a hierarchy of UIcomps.
For example, let ``UIcomp`` number 5 be a widget that asks for a social security number, and let ``UIcomp`` 16 be a tax return form.
If we say that ``UIcomp`` 5 is in ``UIcomp`` 16, we mean that the tax return form contains a widget that asks for a social security number.
-}

RULE -(I[Portal];in)
PHRASE "A portal cannot occur inside a user interface component."



user :: Session * Person [UNI] PRAGMA "" "serves"
PURPOSE RELATION user IN ENGLISH
{+An important reason for having sessions is to allow tracing
every activity to the user who is responsible for it.
For this reason, each session is linked to one person for the duration that this person stays logged on.
-}

role :: Person * Role PRAGMA "" "has"
PURPOSE RELATION role[Person*Role] IN ENGLISH
{+In order to link registered users to roles, we need a relation.
``p role r`` means that person ``p`` has role ``r`` at the moment.
-}

role :: Session -> Role PRAGMA "" "has"
PURPOSE RELATION role[Session*Role] IN ENGLISH
{+During a session, a user has one specific role.
This is done because the functionality presented to each user is role specific.
-}

RULE "role match" : user~;role |- role
PHRASE "As long as person ``p`` is user in a session, then person ``p`` must have that session's role."
PURPOSE RULE "role match" IN ENGLISH
{+In order to give people access to the right functionality,
without having to do access right administration,
any session is open only to persons that have that session's role.
-}


curr :: Session -> Portal PRAGMA "" "is using" "as its user interface"
PURPOSE RELATION curr IN ENGLISH
{+At any moment during its lifetime, a session corresponds to a specific portal.
During the session, that portal may change, as the user navigates through the application.
By saying ``s curr p`` we mean that session ``s`` currently corresponds to portal ``p``.
-}

core :: Portal -> Concept PRAGMA "" "has" "as its core"
PURPOSE RELATION core[Portal*Concept] IN ENGLISH
{+Every portal corresponds to a concept.
When the portal is instantiated, the instance works on one particular atom.
For instance, when a user logs in, the user gets a portal with that user (a ``Person``) as its starting point.
From that point, the user can navigate to wherever he or she is allowed to go.
For this reason, it makes sense to talk about the core concept of a portal.
-}

core :: Session -> Atom PRAGMA "" "has" "as its core"
PURPOSE RELATION core[Session*Atom] IN ENGLISH
{+Every session corresponds to an atom.
This atom is the starting point from where all navigation begins.
From that point, the user can navigate to wherever he or she is allowed to go.
For this reason, it makes sense to talk about the core atom of a session.
-}

type :: Atom -> Concept PRAGMA "" "has" "as its type"
PURPOSE RELATION type[Atom*Concept] IN ENGLISH
{+Every atom has a fixed type, which is a concept.
In speech, we can refer to that concept as *the type of* the atom.
-}

RULE portaltype : curr;core = core;type
PHRASE "The type of a session's central atom corresponds to the type of the current portal of that session."
PURPOSE RULE portaltype IN ENGLISH
{+In order to obtain the right functionality, the type of a session and its portal must correspond.
-}


maintains :: Role * Rule PRAGMA "" "maintains"
PURPOSE RELATION maintains IN ENGLISH
{+Maintaining a rule means to ensure that it will become true.
If at some point in time a rule is violated, someone has work to do.
In order to allocate that work to a role, we introduce: ``role r maintains rule p``.
This means that a person in role ``r`` gets all functionality required te restore truth in rule ``p``.
-}

visible :: Portal * Role PRAGMA "" "is visible to"
PURPOSE RELATION visible IN ENGLISH
{+Since a portal opens functionality to its user,
access to portals may be restricted to certain roles.
To say that a portal ``p`` is visible to role ``r`` means that a user in role ``r`` may use portal ``p``.
(Of course, other restrictions may be in place that limit the access further.)
-}

signals :: Portal * Rule PRAGMA "" "signals"
PURPOSE RELATION signals IN ENGLISH
{+The phrase \"Portal ``p`` signals rule ``r``\" means that violations of rule ``r`` are made visible in that portal or one of its components.
-}

RULE signalling : maintains |- visible~;signals
PURPOSE RULE signalling IN ENGLISH
{+In order to maintain a rule, a user must be able to see the violations of that rule.
There must be a portal, visible to the user, which signals that rule.
-}

ENDPATTERN

PATTERN Services
PURPOSE PATTERN Services IN ENGLISH
{+This pattern was made in the process of building services into RAP.
The problem at hand is to make a definition that allows Ampersand to
generate all services fully automatically.
The Ampersand script specifies which rules are being maintained by which roles,
so that is the starting point of our reasoning.
-}

CONCEPT Service "a unit of software that executes precisely one transaction." ""
PURPOSE CONCEPT Service IN ENGLISH
{+A service is needed to change data, i.e. the contents of the database.
At all times, the data satisfies all invariants.
A service must ensure that the set of changes made by a user leaves the database in that condition that satisfies all invariants.
This corresponds precisely with the notion of transaction in the world of databases.
-}

CONCEPT ECArule "an executable rule that restores invariance after a single event." ""
PURPOSE CONCEPT ECArule IN ENGLISH
{+To restore invariance means that all rules are kept true.
After a user does an insert or delete in a relation ``r``,
some rules may be violated.
An ``ECArule`` (this is short for event-condition-action rule) does this.
Note that, as a consequence of executing an ``ECArule``,
other relations may be changed.
In order to keep all rules satisfied, several ``ECArule`` may have to be called.
All of this happens automatically.
The user will notice nothing other than certain fields that are filled "by magic".
-}


role :: Service -> Role PRAGMA "" "has"
PURPOSE RELATION role[Service*Role] IN ENGLISH
{+A service is made for one specific role.
It contains the functionality that is derivable from the process logic for that specific role
together with the invariant rules in the system.
For this reason, it makes sense to say "the role of service ``s``"
-}

rels :: Relation * Service PRAGMA "" "is used in"
PURPOSE RELATION rels[Relation*Service] IN ENGLISH
{+We need a way to identify which relations are affected by a service,
because they will be within the scope of any transaction performed by this service.
The statement "Relation ``r`` is used in service ``s``" means that the population of this relation may change
or may have to be changed as a result of using the service.
-}

rels :: Relation * Rule PRAGMA "" "is used in"
PURPOSE RELATION rels[Relation*Rule] IN ENGLISH
{+Since all rules are built with relations, we use the sentence "Relation ``r`` is used in rule ``p``"
to indicate that ``r`` is among those building blocks.
This language is used, for instance, to analyse how the population of relations is affacted when rules are maintained.
-}

RULE  "relations in service": rels;maintains~|- rels;role
PURPOSE RULE "relations in service" IN ENGLISH
{+This rule defines the scope of a service.
All relations that are being maintained by this service are in scope.
These are the relations whose population may change as a result of executing the service.
-}

derivedfrom :: ECArule * Service PRAGMA "" ""
PURPOSE RELATION derivedfrom[ECArule*Service] IN ENGLISH
{+ECArules that are derived (by a compiler) from a service are in the relation ``derivedfrom``.
These rules help the user by changing the population of relations such that invariants are being restored and
rules are being maintained.
-}

affects :: Relation * ECArule PRAGMA "" ""
PURPOSE RELATION affects[Relation*ECArule] IN ENGLISH
{+The statement "ECArule ``e`` affects relation ``r``" means that
execution of this ECArule may cause the population of ``r`` to change.
-}

RULE "ECArules in scope" : affects;derivedfrom |- rels[Relation*Service]
PHRASE "Wherever an ECArule is derived from a service, the relation(s) it affects must be in scope of that service."
PURPOSE RULE "ECArules in scope" IN ENGLISH
{+The scope of a service can be perceived as the relations that are affected by that service.
ECArules may affect relations.
Therefore, only those ECArules are permitted that respect the scope of the service.
-}


ENDPATTERN

ENDCONTEXT
