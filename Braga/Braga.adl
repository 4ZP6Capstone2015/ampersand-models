CONTEXT AST IN ENGLISH LATEX
INCLUDE "Braga1.xlsx"






-- Type Checking by
-- Domain Analysis in Ampersand
-- 
-- RAMICS 2015
-- 
-- Stef Joosten
-- Sebastiaan Joosten





-- This presentation:
--   Rules in Ampersand
--   Domain analysis
--   
--   This demonstration is in Ampersand
--   For a Haskell implementation
--    see the links in our paper




PATTERN "Terms and Rules"
    -- A Rule prescribes that two terms are equal.
    -- e.g. "r = s;t",
    --   lhsTerm is the Term "r"
    --   and its rhsTerm is "s;t"

    RELATION lhsTerm[Rule*Term] [UNI,TOT]
    RELATION rhsTerm[Rule*Term] [UNI,TOT]
    

    -- s;t is a BinaryTerm
    CLASSIFY BinaryTerm ISA Term
    RELATION first[BinaryTerm*Term] [UNI,TOT]
    RELATION second[BinaryTerm*Term] [UNI,TOT]
    CLASSIFY Composition ISA BinaryTerm
    CLASSIFY Intersection ISA BinaryTerm
    CLASSIFY Minus ISA BinaryTerm
    CLASSIFY Identity ISA Term
    CLASSIFY Full ISA Term
    CLASSIFY Converse ISA Term
    RELATION flp[Converse*Term] [UNI,TOT]
    CLASSIFY Relation ISA Term
ENDPATTERN

PATTERN "Types and concepts"
    RELATION name[Relation*Identifier] [UNI,TOT]
    RELATION source[Relation*Concept] [UNI,TOT]
    RELATION target[Relation*Concept] [UNI,TOT]
    
    RELATION src[Term*Concept]                                -- Is only [UNI] in type-correct scripts. We want to expose type-errors!
    RELATION tgt[Term*Concept]
ENDPATTERN
-- (Show demo: src and tgt remain empty,
--   but source and target are filled)


PROCESS "Defining type-terms"
    RELATION dom[Term*TypeTerm] [UNI]                         -- TOT is maintained in RULE "dom is total"
    RELATION cod[Term*TypeTerm] [UNI]                         -- TOT is maintained in RULE "cod is total"
    RELATION pop[Concept*TypeTerm] [UNI]                      -- TOT is maintained in RULE "pop is total"

    RELATION sub[TypeTerm*TypeTerm]
    RELATION subStar[TypeTerm*TypeTerm]
    RELATION subPlus[TypeTerm*TypeTerm]                       RELATION subCopy[TypeTerm*TypeTerm]    RULE "Compute transitive closure of sub" : sub = subCopy      VIOLATION (TXT "{EX}_; TransitiveClosure_;sub_;TypeTerm_;subCopy_;subPlus") ROLE ExecEngine MAINTAINS "Compute transitive closure of sub"
     --  "subPlus = sub+" (implicitly)
    RULE "Compute subStar from subPlus" :
     subStar = subPlus\/I                                     VIOLATION (TXT "{EX}_; InsPair_;subStar_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)   ROLE ExecEngine MAINTAINS "Compute subStar from subPlus"

    RULE "dom is total" :                                    
      I[Term] |- dom;dom~                                     VIOLATION (TXT "{EX}_; InsPair_;dom_;Term_;", SRC I, TXT "_;TypeTerm_;dom(", SRC I, TXT ")")   ROLE ExecEngine MAINTAINS "dom is total"
    RULE "cod is total" :                                     
      I[Term] |- cod;cod~                                     VIOLATION (TXT "{EX}_; InsPair_;cod_;Term_;", SRC I, TXT "_;TypeTerm_;cod(", SRC I, TXT ")")    ROLE ExecEngine MAINTAINS "cod is total"
    RULE "pop is total" : 
      I[Concept] |- pop;pop~                                  VIOLATION (TXT "{EX}_; InsPair_;pop_;Concept_;", SRC I, TXT "_;TypeTerm_;pop(", SRC name, TXT ")")    ROLE ExecEngine MAINTAINS "pop is total"

    RULE insDomRelation : dom~;source;pop |- sub              VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)    ROLE ExecEngine MAINTAINS insDomRelation
    RULE insCodRelation : cod~;target;pop |- sub              VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)    ROLE ExecEngine MAINTAINS insCodRelation

    {-Example:  dom(s;t) |- dom(s)     -}
    RULE domainDomComposition :
     dom~;I[Composition];first;dom |- sub                       VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)    ROLE ExecEngine MAINTAINS domainDomComposition
    RULE domainCodComposition :
     cod~;I[Composition];second;cod |- sub                       VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)    ROLE ExecEngine MAINTAINS domainCodComposition
    
    RELATION inter[Composition*TypeTerm]
    RULE compositionNewTypeTerm : 
     I[Composition] |- inter;inter~                             VIOLATION (TXT "{EX}_; InsPair_;inter_;Composition_;", SRC I, TXT "_;TypeTerm_;inter(", SRC I, TXT ")" ,TXT "{EX}_; InsPair_;sub_;TypeTerm_;inter(", SRC I, TXT ")_;TypeTerm_;", SRC first;cod,TXT "{EX}_; InsPair_;sub_;TypeTerm_;inter(", SRC I, TXT ")_;TypeTerm_;", SRC second;dom              )    ROLE ExecEngine MAINTAINS compositionNewTypeTerm

    RULE domainDomRule :
       dom~;lhsTerm~;rhsTerm;dom
    \/ dom~;rhsTerm~;lhsTerm;dom |- sub                         VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I) ROLE ExecEngine MAINTAINS domainDomRule

    RULE domainCodRule :
       cod~;lhsTerm~;rhsTerm;cod
    \/ cod~;rhsTerm~;lhsTerm;cod |- sub                         VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I) ROLE ExecEngine MAINTAINS domainCodRule

    RELATION pretype[TypeTerm*Concept]
    RELATION isa[Concept*Concept]
    RULE "Insert into isa" :
     pop;subPlus;pop~ - I |- isa                                VIOLATION (TXT "{EX}_; InsPair_;isa_;Concept_;", SRC I, TXT "_;Concept_;", TGT I)   ROLE ExecEngine MAINTAINS "Insert into pretype"
    RULE "Insert into pretype" :
     subStar;pop~ |- pretype                                    VIOLATION (TXT "{EX}_; InsPair_;pretype_;TypeTerm_;", SRC I, TXT "_;Concept_;", TGT I)   ROLE ExecEngine MAINTAINS "Insert into pretype"

ENDPROCESS

PROCESS Signatures                                              ROLE ExecEngine MAINTAINS signatureInsDom, signatureInsCod
    RULE signatureInsDom :
     dom;(pretype - pretype;isa) |- src                         VIOLATION (TXT "{EX}_; InsPair_;src_;Term_;", SRC I, TXT "_;Concept_;", TGT I)
    RULE signatureInsCod :
     cod;(pretype - pretype;isa) |- tgt                         VIOLATION (TXT "{EX}_; InsPair_;tgt_;Term_;", SRC I, TXT "_;Concept_;", TGT I)
ENDPROCESS

PROCESS "Type checking"
    RULE "Unambiguous pretype"
     : pretype |- pretype~\I[Concept]
    MESSAGE "Every type-term must be subset of one concept only."
    VIOLATION (SRC I, TXT " is a subset of ", TGT I, TXT ".")
    ROLE User MAINTAINS "Unambiguous pretype"

    RULE "Complete pretype"
     : I[TypeTerm] |- pretype;pretype~
    MESSAGE "Every type-term must have one concept as its pretype."
    VIOLATION (SRC I, TXT " has no pretype.")
    ROLE User MAINTAINS "Complete pretype"

    RULE compositionCheck :
     I[Composition];first;tgt |- (src~;second~)\I
    MESSAGE "Source and target in a composition must match."
    VIOLATION (SRC I, TXT " has ", TGT I, TXT " and ", SRC second;src, TXT " as its type.")
    ROLE User MAINTAINS compositionCheck

ENDPROCESS


--PROCESS "Domain inference from rules"
--    RULE domainDomRule :
--       dom~;lhsTerm~;rhsTerm;dom
--    \/ dom~;rhsTerm~;lhsTerm;dom |- sub                         VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I) ROLE ExecEngine MAINTAINS domainDomRule
--    
--    RULE domainCodRule :
--       cod~;lhsTerm~;rhsTerm;cod
--    \/ cod~;rhsTerm~;lhsTerm;cod |- sub                         VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I) ROLE ExecEngine MAINTAINS domainCodRule
--ENDPROCESS


--PROCESS "Intersections"
--    RULE domainCodIntersection :
--        cod~;I[Intersection];first;cod 
--     \/ cod~;I[Intersection];second;cod |- sub                   VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)  ROLE ExecEngine MAINTAINS domainCodIntersection
--    RULE domainDomIntersection :
--        dom~;I[Intersection];first;dom
--     \/ dom~;I[Intersection];second;dom |- sub                   VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I) ROLE ExecEngine MAINTAINS domainDomIntersection
--ENDPROCESS


--PROCESS "Minuses"                                             ROLE ExecEngine MAINTAINS domainDomMinus, domainCodMinus
--    RULE domainDomMinus :
--     dom~;I[Minus];first[BinaryTerm*Term];dom |- sub            VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)
--    RULE domainCodMinus :
--     cod~;I[Minus];second[BinaryTerm*Term];cod |- sub            VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)
--ENDPROCESS



--PROCESS "Converses"                                           ROLE ExecEngine MAINTAINS converseDom, converseDomFlp, converseCod, converseCodFlp
--    RULE converseDom :
--     dom~;I[Converse];flp;cod |- sub                          VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)
--    RULE converseDomFlp :
--     dom~;I[Converse];flp;cod |- sub~                         VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", TGT I, TXT "_;TypeTerm_;", SRC I)
--    RULE converseCod :
--     cod~;I[Converse];flp;dom |- sub                          VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", SRC I, TXT "_;TypeTerm_;", TGT I)
--    RULE converseCodFlp :
--     cod~;I[Converse];flp;dom |- sub~                         VIOLATION (TXT "{EX}_; InsPair_;sub_;TypeTerm_;", TGT I, TXT "_;TypeTerm_;", SRC I)
--ENDPROCESS


PROCESS Atoms
REPRESENT Representation TYPE ALPHANUMERIC
REPRESENT Identifier TYPE ALPHANUMERIC

RELATION name[Concept*Identifier] [UNI,TOT]
MEANING "Every concept has a name" -- Identifiability is not a property of this relation, and therefore should be specified by a rule.
REPRESENT Identifier TYPE ALPHANUMERIC

RULE "Identifiability of concepts": name;name~ |- I[Concept]
MEANING "The name of a concept identifies that concept."
VIOLATION (TXT "The name \"", SRC I, TXT "\" is already in use")

RELATION isa[Concept*Concept] [IRF,ASY]
MEANING "s isa g  means that each element of concept  s  is defined to be an element of concept  g  as well."
RELATION isaStar[Concept*Concept] -- Transitive, reflexive closure of isa, aka isa*
RELATION isaPlus[Concept*Concept] -- Transitive closure of isa, aka isa+

RELATION isaCopy[Concept*Concept] -- necessary only for calling the Transitive closure function.
ROLE ExecEngine MAINTAINS "Compute transitive closure of isa"
RULE "Compute transitive closure of isa" : isa = isaCopy
VIOLATION (TXT "{EX} TransitiveClosure;isa;Concept;isaCopy;isaPlus")

ROLE ExecEngine MAINTAINS "Compute transitive closure of isa by Ins", "Compute transitive closure of isa by Del"
RULE "Compute transitive closure of isa by Ins" : isaPlus\/I |- isaStar
VIOLATION (TXT "{EX} InsPair;isaStar;Concept;", SRC I, TXT ";Concept;", TGT I)
RULE "Compute transitive closure of isa by Del" : isaStar |- isaPlus\/I
VIOLATION (TXT "{EX} DelPair;isaStar;Concept;", SRC I, TXT ";Concept;", TGT I)

ENDPROCESS

INTERFACE "DomainAnaylsis" (source,target) : '_SESSION'
TABS[ relations : V[SESSION*Relation]
      BOX<SCOLS>
           [ relation   : name
           , source     : source
           , target     : target
           ]
    , rules : V[SESSION*Rule]
      ROWS
           [ rule       : I
           , lhsTerm    : lhsTerm
           , rhsTerm    : rhsTerm
           ]
    , terms : V[SESSION*Term]
      BOX<SCOLS>
           [ term        : I
           , src         : src
           , tgt         : tgt
           ]
    , "type-terms" : V[SESSION*TypeTerm]
      BOX<SCOLS>
           [ "type-term" : I
           , "sub+"      : subPlus
           , pretype     : pretype
           ]
    ]

VIEW Concept : Concept(name)
VIEW Term : Term(I)
VIEW Rule : Rule(lhsTerm, TXT " = ", rhsTerm)

INTERFACE Concept(name[Concept*Identifier],isa) FOR Ampersand : I[Concept]
ROWS [ name             : name
     , generalizations  : isa
     , specializations  : isa~
     ]

VIEW Relation : Relation(name, TXT "[", source;name, TXT "*", target;name, TXT "]")

INTERFACE Relation(name[Relation*Identifier], source, target) FOR Ampersand: I[Relation]
ROWS [ name    : name
     , source  : source
     , target  : target
     ]

INTERFACE Rule(lhsTerm, rhsTerm) FOR Ampersand: I[Rule]
ROWS [ rule    : I
     , lhsTerm : lhsTerm
     , rhsTerm : rhsTerm
     ]

ENDCONTEXT