<?php
// module Generics.php generated by Generate.hs
// Prototype v2.2.0.1869, build time: 19-Mar-12 13:54.30 (lib: Ampersand v2.2.0.537, build time: 19-Mar-12 13:53.39)


$versionInfo = 'Prototype v2.2.0.1869, build time: 19-Mar-12 13:54.30 (lib: Ampersand v2.2.0.537, build time: 19-Mar-12 13:53.39)';

$dbName = 'CSA_Op';

$isDev = false;

$autoRefreshInterval = '0';

$allSpecializations =
  array
    ();

$relationTableInfo =
  array
    ( 'planStatus' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'Status', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planStatus')
    , 'atStatus' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'Status', 'table' => 'ActivityType', 'srcCol' => 'ActivityType', 'tgtCol' => 'atStatus')
    , 'actStatus' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actStatus')
    , 'ouStatus' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table' => 'OrgUnit', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ouStatus')
    , 'scStatus' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scStatus')
    , 'compStatus' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compStatus')
    , 'svcStatus' => array ('srcConcept' => 'Service', 'tgtConcept' => 'Status', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcStatus')
    , 'nwStatus' => array ('srcConcept' => 'Network', 'tgtConcept' => 'Status', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwStatus')
    , 'routerStatus' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Status', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerStatus')
    , 'planID' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'PlanID', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planID')
    , 'planMnlStat' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'Status', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planMnlStat')
    , 'atReqsCpb' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'Capability', 'table' => 'atReqsCpb', 'srcCol' => 'ActivityType', 'tgtCol' => 'Capability')
    , 'planAT' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'ActivityType', 'table' => 'planAT', 'srcCol' => 'Plan', 'tgtCol' => 'ActivityType')
    , 'actType' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'ActivityType', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actType')
    , 'actPlan' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Plan', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actPlan')
    , 'atReqsSvc' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'Service', 'table' => 'atReqsSvc', 'srcCol' => 'ActivityType', 'tgtCol' => 'Service')
    , 'scImplements' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Service', 'table' => 'scImplements', 'srcCol' => 'SvcComponent', 'tgtCol' => 'Service')
    , 'ouMayExecuteAT' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'ActivityType', 'table' => 'ouMayExecuteAT', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ActivityType')
    , 'ouQualifiedFor' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Capability', 'table' => 'ouQualifiedFor', 'srcCol' => 'OrgUnit', 'tgtCol' => 'Capability')
    , 'actID' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'ActivityID', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actID')
    , 'actMnlStat' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actMnlStat')
    , 'actExecutingOU' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'OrgUnit', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actExecutingOU')
    , 'actPlanStart' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actPlanStart')
    , 'actPlanEnd' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actPlanEnd')
    , 'actStartTime' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actStartTime')
    , 'actEndTime' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actEndTime')
    , 'actUseSC' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'SvcComponent', 'table' => 'actUseSC', 'srcCol' => 'Activity', 'tgtCol' => 'SvcComponent')
    , 'scDeployedOn' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Computer', 'table' => 'scDeployedOn', 'srcCol' => 'SvcComponent', 'tgtCol' => 'Computer')
    , 'compOwner' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'OrgUnit', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compOwner')
    , 'ouMnlStat' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table' => 'OrgUnit', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ouMnlStat')
    , 'svcID' => array ('srcConcept' => 'Service', 'tgtConcept' => 'ServiceID', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcID')
    , 'routerNW' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Network', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerNW')
    , 'compRouter' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Router', 'table' => 'compRouter', 'srcCol' => 'Computer', 'tgtCol' => 'Router')
    , 'scID' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponentID', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scID')
    , 'scName' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponentName', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scName')
    , 'scMnlStat' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scMnlStat')
    , 'scReqCommWith' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'scReqCommWith', 'srcCol' => 'sSvcComponent', 'tgtCol' => 'tSvcComponent')
    , 'scHasCommWith' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'scHasCommWith', 'srcCol' => 'sSvcComponent', 'tgtCol' => 'tSvcComponent')
    , 'compID' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'ComputerID', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compID')
    , 'compName' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'ComputerName', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compName')
    , 'compMnlStat' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compMnlStat')
    , 'compReqCommWith' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'compReqCommWith', 'srcCol' => 'sComputer', 'tgtCol' => 'tComputer')
    , 'compHasCommWith' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'compHasCommWith', 'srcCol' => 'sComputer', 'tgtCol' => 'tComputer')
    , 'routerID' => array ('srcConcept' => 'Router', 'tgtConcept' => 'RouterID', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerID')
    , 'routerName' => array ('srcConcept' => 'Router', 'tgtConcept' => 'RouterName', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerName')
    , 'routerRoutesTo' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'routerRoutesTo', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'rrtDirect' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'rrtDirect', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'routerNeedsPathTo' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'routerNeedsPathTo', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'nwID' => array ('srcConcept' => 'Network', 'tgtConcept' => 'NetworkID', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwID')
    , 'connectComputerToNetworkRouter' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'connectComputerToNetworkRouter')
    , 'routesToBeDiscarded' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'routesToBeDiscarded', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'computerToBeDisconnected' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Router', 'table' => 'computerToBeDisconnected', 'srcCol' => 'Computer', 'tgtCol' => 'Router')
    , 'setupComputerComputerCommunications' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'setupComputerComputerCommunications', 'srcCol' => 'sComputer', 'tgtCol' => 'tComputer')
    , 'startRunningServiceComponents' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'startRunningServiceComponents')
    , 'planCmpStat' => array ('srcConcept' => 'Plan', 'tgtConcept' => 'Status', 'table' => 'Plan', 'srcCol' => 'Plan', 'tgtCol' => 'planCmpStat')
    , 'atStatusIsGreen' => array ('srcConcept' => 'ActivityType', 'tgtConcept' => 'ActivityType', 'table' => 'ActivityType', 'srcCol' => 'ActivityType', 'tgtCol' => 'atStatusIsGreen')
    , 'actCmpStat' => array ('srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table' => 'Activity', 'srcCol' => 'Activity', 'tgtCol' => 'actCmpStat')
    , 'ouCmpStat' => array ('srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table' => 'OrgUnit', 'srcCol' => 'OrgUnit', 'tgtCol' => 'ouCmpStat')
    , 'scCmpStat' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scCmpStat')
    , 'compCmpStat' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compCmpStat')
    , 'rrtStar' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'rrtStar', 'srcCol' => 'sRouter', 'tgtCol' => 'tRouter')
    , 'nwAllCompCommReqsSatisfied' => array ('srcConcept' => 'Network', 'tgtConcept' => 'Network', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwAllCompCommReqsSatisfied')
    , 'routerAllCommReqsSatisfied' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerAllCommReqsSatisfied')
    , 'nwNoCompCommReqsSatisfied' => array ('srcConcept' => 'Network', 'tgtConcept' => 'Network', 'table' => 'Network', 'srcCol' => 'Network', 'tgtCol' => 'nwNoCompCommReqsSatisfied')
    , 'routerNoCommReqsSatisfied' => array ('srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table' => 'Router', 'srcCol' => 'Router', 'tgtCol' => 'routerNoCommReqsSatisfied')
    , 'compRequiresComm' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compRequiresComm')
    , 'compAllReqCommSatisfied' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compAllReqCommSatisfied')
    , 'compNoReqCommSatisfied' => array ('srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table' => 'Computer', 'srcCol' => 'Computer', 'tgtCol' => 'compNoReqCommSatisfied')
    , 'scAllReqCommSatisfied' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scAllReqCommSatisfied')
    , 'scNoReqCommSatisfied' => array ('srcConcept' => 'SvcComponent', 'tgtConcept' => 'SvcComponent', 'table' => 'SvcComponent', 'srcCol' => 'SvcComponent', 'tgtCol' => 'scNoReqCommSatisfied')
    , 'svcAllSvcCompReqsSatisfied' => array ('srcConcept' => 'Service', 'tgtConcept' => 'Service', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcAllSvcCompReqsSatisfied')
    , 'svcNoSvcCompReqsSatisfied' => array ('srcConcept' => 'Service', 'tgtConcept' => 'Service', 'table' => 'Service', 'srcCol' => 'Service', 'tgtCol' => 'svcNoSvcCompReqsSatisfied')
    );

$conceptTableInfo =
  array
    ( 'Plan' => array 
          ( array ( 'table' => 'Plan'
                  , 'cols' => array ('Plan')
                  )
          )
    , 'Status' => array 
          ( array ( 'table' => 'Status'
                  , 'cols' => array ('Status')
                  )
          )
    , 'ActivityType' => array 
          ( array ( 'table' => 'ActivityType'
                  , 'cols' => array ('ActivityType')
                  )
          )
    , 'Activity' => array 
          ( array ( 'table' => 'Activity'
                  , 'cols' => array ('Activity')
                  )
          )
    , 'OrgUnit' => array 
          ( array ( 'table' => 'OrgUnit'
                  , 'cols' => array ('OrgUnit')
                  )
          )
    , 'SvcComponent' => array 
          ( array ( 'table' => 'SvcComponent'
                  , 'cols' => array ('SvcComponent')
                  )
          )
    , 'Computer' => array 
          ( array ( 'table' => 'Computer'
                  , 'cols' => array ('Computer')
                  )
          )
    , 'Network' => array 
          ( array ( 'table' => 'Network'
                  , 'cols' => array ('Network')
                  )
          )
    , 'Router' => array 
          ( array ( 'table' => 'Router'
                  , 'cols' => array ('Router')
                  )
          )
    , 'Service' => array 
          ( array ( 'table' => 'Service'
                  , 'cols' => array ('Service')
                  )
          )
    , 'Yes/No answer' => array 
          ( array ( 'table' => 'Yes/No answer'
                  , 'cols' => array ('Yes/No answer')
                  )
          )
    , 'PlanID' => array 
          ( array ( 'table' => 'PlanID'
                  , 'cols' => array ('PlanID')
                  )
          )
    , 'Capability' => array 
          ( array ( 'table' => 'Capability'
                  , 'cols' => array ('Capability')
                  )
          )
    , 'ServiceID' => array 
          ( array ( 'table' => 'ServiceID'
                  , 'cols' => array ('ServiceID')
                  )
          )
    , 'ActivityID' => array 
          ( array ( 'table' => 'ActivityID'
                  , 'cols' => array ('ActivityID')
                  )
          )
    , 'Timestamp' => array 
          ( array ( 'table' => 'Timestamp'
                  , 'cols' => array ('Timestamp')
                  )
          )
    , 'ComputerID' => array 
          ( array ( 'table' => 'ComputerID'
                  , 'cols' => array ('ComputerID')
                  )
          )
    , 'ComputerName' => array 
          ( array ( 'table' => 'ComputerName'
                  , 'cols' => array ('ComputerName')
                  )
          )
    , 'NetworkID' => array 
          ( array ( 'table' => 'NetworkID'
                  , 'cols' => array ('NetworkID')
                  )
          )
    , 'RouterID' => array 
          ( array ( 'table' => 'RouterID'
                  , 'cols' => array ('RouterID')
                  )
          )
    , 'RouterName' => array 
          ( array ( 'table' => 'RouterName'
                  , 'cols' => array ('RouterName')
                  )
          )
    , 'SvcComponentID' => array 
          ( array ( 'table' => 'SvcComponentID'
                  , 'cols' => array ('SvcComponentID')
                  )
          )
    , 'SvcComponentName' => array 
          ( array ( 'table' => 'SvcComponentName'
                  , 'cols' => array ('SvcComponentName')
                  )
          )
    );

$tableColumnInfo =
  array
    ( 'Activity' =>
        array
          ( 'Activity' => array ( 'concept' => 'Activity', 'unique' => true, 'null' => false)
          , 'actCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          , 'actID' => array ( 'concept' => 'ActivityID', 'unique' => false, 'null' => false)
          , 'actStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actExecutingOU' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          , 'actPlan' => array ( 'concept' => 'Plan', 'unique' => false, 'null' => false)
          , 'actPlanStart' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actPlanEnd' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actStartTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actEndTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          )
    , 'Computer' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => false)
          , 'compCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compRequiresComm' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compAllReqCommSatisfied' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compNoReqCommSatisfied' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'connectComputerToNetworkRouter' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compID' => array ( 'concept' => 'ComputerID', 'unique' => false, 'null' => false)
          , 'compName' => array ( 'concept' => 'ComputerName', 'unique' => false, 'null' => true)
          , 'compStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compOwner' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => true)
          )
    , 'SvcComponent' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => false)
          , 'scCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scAllReqCommSatisfied' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => true)
          , 'scNoReqCommSatisfied' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => true)
          , 'startRunningServiceComponents' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => true)
          , 'scStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scID' => array ( 'concept' => 'SvcComponentID', 'unique' => false, 'null' => false)
          , 'scName' => array ( 'concept' => 'SvcComponentName', 'unique' => false, 'null' => true)
          )
    , 'Router' =>
        array
          ( 'Router' => array ( 'concept' => 'Router', 'unique' => true, 'null' => false)
          , 'routerAllCommReqsSatisfied' => array ( 'concept' => 'Router', 'unique' => true, 'null' => true)
          , 'routerNoCommReqsSatisfied' => array ( 'concept' => 'Router', 'unique' => true, 'null' => true)
          , 'routerID' => array ( 'concept' => 'RouterID', 'unique' => false, 'null' => false)
          , 'routerName' => array ( 'concept' => 'RouterName', 'unique' => false, 'null' => true)
          , 'routerStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'routerNW' => array ( 'concept' => 'Network', 'unique' => false, 'null' => true)
          )
    , 'Service' =>
        array
          ( 'Service' => array ( 'concept' => 'Service', 'unique' => true, 'null' => false)
          , 'svcAllSvcCompReqsSatisfied' => array ( 'concept' => 'Service', 'unique' => true, 'null' => true)
          , 'svcNoSvcCompReqsSatisfied' => array ( 'concept' => 'Service', 'unique' => true, 'null' => true)
          , 'svcID' => array ( 'concept' => 'ServiceID', 'unique' => false, 'null' => false)
          , 'svcStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Network' =>
        array
          ( 'Network' => array ( 'concept' => 'Network', 'unique' => true, 'null' => false)
          , 'nwAllCompCommReqsSatisfied' => array ( 'concept' => 'Network', 'unique' => true, 'null' => true)
          , 'nwNoCompCommReqsSatisfied' => array ( 'concept' => 'Network', 'unique' => true, 'null' => true)
          , 'nwID' => array ( 'concept' => 'NetworkID', 'unique' => false, 'null' => false)
          , 'nwStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Plan' =>
        array
          ( 'Plan' => array ( 'concept' => 'Plan', 'unique' => true, 'null' => false)
          , 'planCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'planID' => array ( 'concept' => 'PlanID', 'unique' => false, 'null' => false)
          , 'planStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'planMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'OrgUnit' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => true, 'null' => false)
          , 'ouCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'ouStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'ouMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'ActivityType' =>
        array
          ( 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => true, 'null' => false)
          , 'atStatusIsGreen' => array ( 'concept' => 'ActivityType', 'unique' => true, 'null' => true)
          , 'atStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'SvcComponentName' =>
        array
          ( 'SvcComponentName' => array ( 'concept' => 'SvcComponentName', 'unique' => true, 'null' => false)
          )
    , 'SvcComponentID' =>
        array
          ( 'SvcComponentID' => array ( 'concept' => 'SvcComponentID', 'unique' => true, 'null' => false)
          )
    , 'RouterName' =>
        array
          ( 'RouterName' => array ( 'concept' => 'RouterName', 'unique' => true, 'null' => false)
          )
    , 'RouterID' =>
        array
          ( 'RouterID' => array ( 'concept' => 'RouterID', 'unique' => true, 'null' => false)
          )
    , 'NetworkID' =>
        array
          ( 'NetworkID' => array ( 'concept' => 'NetworkID', 'unique' => true, 'null' => false)
          )
    , 'ComputerName' =>
        array
          ( 'ComputerName' => array ( 'concept' => 'ComputerName', 'unique' => true, 'null' => false)
          )
    , 'ComputerID' =>
        array
          ( 'ComputerID' => array ( 'concept' => 'ComputerID', 'unique' => true, 'null' => false)
          )
    , 'Timestamp' =>
        array
          ( 'Timestamp' => array ( 'concept' => 'Timestamp', 'unique' => true, 'null' => false)
          )
    , 'ActivityID' =>
        array
          ( 'ActivityID' => array ( 'concept' => 'ActivityID', 'unique' => true, 'null' => false)
          )
    , 'ServiceID' =>
        array
          ( 'ServiceID' => array ( 'concept' => 'ServiceID', 'unique' => true, 'null' => false)
          )
    , 'Capability' =>
        array
          ( 'Capability' => array ( 'concept' => 'Capability', 'unique' => true, 'null' => false)
          )
    , 'PlanID' =>
        array
          ( 'PlanID' => array ( 'concept' => 'PlanID', 'unique' => true, 'null' => false)
          )
    , 'Yes/No answer' =>
        array
          ( 'Yes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => true, 'null' => false)
          )
    , 'Status' =>
        array
          ( 'Status' => array ( 'concept' => 'Status', 'unique' => true, 'null' => false)
          )
    , 'routerRoutesTo' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'rrtDirect' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'rrtStar' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'routerNeedsPathTo' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'compReqCommWith' =>
        array
          ( 'sComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'tComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'compHasCommWith' =>
        array
          ( 'sComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'tComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'routesToBeDiscarded' =>
        array
          ( 'sRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'tRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'computerToBeDisconnected' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'Router' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'setupComputerComputerCommunications' =>
        array
          ( 'sComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'tComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'yesNo' =>
        array
          ( 'sYes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => false, 'null' => false)
          , 'tYes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => false, 'null' => false)
          )
    , 'planAT' =>
        array
          ( 'Plan' => array ( 'concept' => 'Plan', 'unique' => false, 'null' => false)
          , 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          )
    , 'atReqsCpb' =>
        array
          ( 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          , 'Capability' => array ( 'concept' => 'Capability', 'unique' => false, 'null' => false)
          )
    , 'atReqsSvc' =>
        array
          ( 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          , 'Service' => array ( 'concept' => 'Service', 'unique' => false, 'null' => false)
          )
    , 'actUseSC' =>
        array
          ( 'Activity' => array ( 'concept' => 'Activity', 'unique' => false, 'null' => false)
          , 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          )
    , 'ouQualifiedFor' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          , 'Capability' => array ( 'concept' => 'Capability', 'unique' => false, 'null' => false)
          )
    , 'ouMayExecuteAT' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          , 'ActivityType' => array ( 'concept' => 'ActivityType', 'unique' => false, 'null' => false)
          )
    , 'scImplements' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'Service' => array ( 'concept' => 'Service', 'unique' => false, 'null' => false)
          )
    , 'scDeployedOn' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'compRouter' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'Router' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'scReqCommWith' =>
        array
          ( 'sSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'tSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          )
    , 'scHasCommWith' =>
        array
          ( 'sSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'tSvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          )
    );

$allRulesSql =
  array
    ( 'ActivityType OrgUnits' =>
        array ( 'name' => 'ActivityType OrgUnits'
              , 'ruleAdl' => 'I[ActivityType] |- (-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~'
              , 'origin' => 'line 98, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'In order for an ActivityType to be operationalized, there must at least be one OrgUnit that is qualified for all capabilities required by the ActivityType.'
              , 'message' => ''
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-I[ActivityType] \\/ (-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)
              // <=> { De Morgan }
              //     I[ActivityType]/\\-((-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[ActivityType]\",\"-((-atReqsCpb!ouQualifiedFor~);(-atReqsCpb!ouQualifiedFor~)~)\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`ActivityType1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `ActivityType`, `ActivityType` AS `ActivityType1`
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"-atReqsCpb!ouQualifiedFor~\",\"(-atReqsCpb!ouQualifiedFor~)~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ActivityType`, ECps1.`ActivityType` AS `ActivityType1`
                                             FROM 
                                                  ( /* case: ERad es@(_:_:_)
                                                       ERad [\"-atReqsCpb\",\"ouQualifiedFor~\"] */
                                                    /* case: ECpl e
                                                       ECpl [ \"atReqsCpb;-ouQualifiedFor~\" ] */
                                                    SELECT DISTINCT cfst.`ActivityType`, csnd.`OrgUnit`
                                                    FROM `ActivityType` AS cfst,
                                                         `OrgUnit` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                ECps [\"atReqsCpb\",\"-ouQualifiedFor~\"] */
                                                             
                                                             SELECT DISTINCT ECps0.`ActivityType`, ECps1.`OrgUnit`
                                                             FROM `atReqsCpb` AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl [ \"ouQualifiedFor~\" ] */
                                                                    SELECT DISTINCT cfst.`Capability`, csnd.`OrgUnit`
                                                                    FROM `Capability` AS cfst,
                                                                         `OrgUnit` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: EFlp x. */
                                                                             SELECT DISTINCT `OrgUnit`, `Capability`
                                                                             FROM `ouQualifiedFor`
                                                                             WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL
                                                                           ) AS cp
                                                                      WHERE cfst.`Capability`=cp.`Capability` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`Capability`=ECps1.`Capability`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: ERad es@(_:_:_)
                                                       ERad [\"-atReqsCpb\",\"ouQualifiedFor~\"] */
                                                    /* case: ECpl e
                                                       ECpl [ \"atReqsCpb;-ouQualifiedFor~\" ] */
                                                    SELECT DISTINCT cfst.`ActivityType`, csnd.`OrgUnit`
                                                    FROM `ActivityType` AS cfst,
                                                         `OrgUnit` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                ECps [\"atReqsCpb\",\"-ouQualifiedFor~\"] */
                                                             
                                                             SELECT DISTINCT ECps0.`ActivityType`, ECps1.`OrgUnit`
                                                             FROM `atReqsCpb` AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl [ \"ouQualifiedFor~\" ] */
                                                                    SELECT DISTINCT cfst.`Capability`, csnd.`OrgUnit`
                                                                    FROM `Capability` AS cfst,
                                                                         `OrgUnit` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: EFlp x. */
                                                                             SELECT DISTINCT `OrgUnit`, `Capability`
                                                                             FROM `ouQualifiedFor`
                                                                             WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL
                                                                           ) AS cp
                                                                      WHERE cfst.`Capability`=cp.`Capability` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`Capability`=ECps1.`Capability`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                                                  ) AS ECps1
                                             WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                                           ) AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`ActivityType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'None of the OrgUnits is qualified for ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' activities')
                    )
              )
    , 'Service implementation' =>
        array ( 'name' => 'Service implementation'
              , 'ruleAdl' => 'I[Service]/\\atReqsSvc~;atReqsSvc |- scImplements~;scImplements'
              , 'origin' => 'line 103, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'If a Service is required by an ActivityType, an SvcComponent must exist that implements this Service.'
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(I[Service]/\\atReqsSvc~;atReqsSvc) \\/ scImplements~;scImplements)
              // <=> { De Morgan }
              //     I[Service]/\\atReqsSvc~;atReqsSvc/\\-(scImplements~;scImplements)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Service]\",\"atReqsSvc~;atReqsSvc\",\"-(scImplements~;scImplements)\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Service`, `Service` AS `Service1`
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atReqsSvc~\",\"atReqsSvc\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ActivityType`, `Service`
                                        FROM `atReqsSvc`
                                        WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps0,
                                      `atReqsSvc` AS ECps1
                                 WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                               ) AS isect1
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`Service1` = isect1.`Service1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scImplements~\",\"scImplements\"] */
                                             
                                             SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Service`
                                                    FROM `scImplements`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps0,
                                                  `scImplements` AS ECps1
                                             WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                           ) AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Service ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' lacks an SvcComponent that implements it')
                    )
              )
    , 'Capability relevance' =>
        array ( 'name' => 'Capability relevance'
              , 'ruleAdl' => 'actExecutingOU~;actType;atReqsCpb |- ouQualifiedFor'
              , 'origin' => 'line 108, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'If an OrgUnit executes an activity of a type that requires some capability, then this OrgUnit must be qualified for this capability'
              , 'message' => 'OrgUnits that lack capabilities:'
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'Capability'
              // original expression:
              //     -(-(actExecutingOU~;actType;atReqsCpb) \\/ ouQualifiedFor)
              // <=> { De Morgan }
              //     actExecutingOU~;actType;atReqsCpb/\\-ouQualifiedFor
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actExecutingOU~;actType;atReqsCpb\",\"-ouQualifiedFor\"] */
                          SELECT DISTINCT isect0.`actExecutingOU` AS src, isect0.`Capability` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actExecutingOU~\",\"actType\",\"atReqsCpb\"] */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU`, ECps2.`Capability`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actExecutingOU`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1,
                                      `atReqsCpb` AS ECps2
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                                   AND ECps1.`actType`=ECps2.`ActivityType`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `ouQualifiedFor` AS cp
                                      WHERE isect0.`actExecutingOU`=cp.`OrgUnit` AND isect0.`Capability`=cp.`Capability`) AND isect0.`actExecutingOU` IS NOT NULL AND isect0.`Capability` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'OrgUnit ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be qualified for capability ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Capability'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Capability` AS src, `Capability` AS tgt
                                 FROM `Capability`
                                 WHERE `Capability` IS NOT NULL AND `Capability` IS NOT NULL'
                            )
                    )
              )
    , 'insouMayExecuteAT' =>
        array ( 'name' => 'insouMayExecuteAT'
              , 'ruleAdl' => '-(atReqsCpb;-ouQualifiedFor~)~ |- ouMayExecuteAT'
              , 'origin' => 'line 115, file "CSA_Op Ontology.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(--(atReqsCpb;-ouQualifiedFor~)~ \\/ ouMayExecuteAT)
              // <=> { De Morgan }
              //     -(atReqsCpb;-ouQualifiedFor~)~/\\-ouMayExecuteAT
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-(atReqsCpb;-ouQualifiedFor~)~\",\"-ouMayExecuteAT\"] */
                          SELECT DISTINCT isect0.`OrgUnit` AS src, isect0.`ActivityType` AS tgt
                          FROM 
                               ( /* case: EFlp x. */
                                 /* case: ECpl e
                                    ECpl [ \"atReqsCpb;-ouQualifiedFor~\" ] */
                                 SELECT DISTINCT cfst.`ActivityType`, csnd.`OrgUnit`
                                 FROM `ActivityType` AS cfst,
                                      `OrgUnit` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"atReqsCpb\",\"-ouQualifiedFor~\"] */
                                          
                                          SELECT DISTINCT ECps0.`ActivityType`, ECps1.`OrgUnit`
                                          FROM `atReqsCpb` AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 /* case: ECpl e
                                                    ECpl [ \"ouQualifiedFor\" ] */
                                                 SELECT DISTINCT cfst.`OrgUnit`, csnd.`Capability`
                                                 FROM `OrgUnit` AS cfst,
                                                      `Capability` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `ouQualifiedFor` AS cp
                                                   WHERE cfst.`OrgUnit`=cp.`OrgUnit` AND csnd.`Capability`=cp.`Capability`)
                                               ) AS ECps1
                                          WHERE ECps0.`Capability`=ECps1.`Capability`
                                        ) AS cp
                                   WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `ouMayExecuteAT` AS cp
                                      WHERE isect0.`OrgUnit`=cp.`OrgUnit` AND isect0.`ActivityType`=cp.`ActivityType`) AND isect0.`OrgUnit` IS NOT NULL AND isect0.`ActivityType` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouMayExecuteAT;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    )
              )
    , 'delouMayExecuteAT' =>
        array ( 'name' => 'delouMayExecuteAT'
              , 'ruleAdl' => 'ouMayExecuteAT |- -(atReqsCpb;-ouQualifiedFor~)~'
              , 'origin' => 'line 118, file "CSA_Op Ontology.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-ouMayExecuteAT \\/ -(atReqsCpb;-ouQualifiedFor~)~)
              // <=> { De Morgan }
              //     ouMayExecuteAT/\\--(atReqsCpb;-ouQualifiedFor~)~
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ouMayExecuteAT\",\"--(atReqsCpb;-ouQualifiedFor~)~\"] */
                          SELECT DISTINCT isect0.`OrgUnit` AS src, isect0.`ActivityType` AS tgt
                          FROM `ouMayExecuteAT` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: EFlp x. */
                                             /* case: ECpl e
                                                ECpl [ \"atReqsCpb;-ouQualifiedFor~\" ] */
                                             SELECT DISTINCT cfst.`ActivityType`, csnd.`OrgUnit`
                                             FROM `ActivityType` AS cfst,
                                                  `OrgUnit` AS csnd
                                             WHERE NOT EXISTS
                                              (SELECT * FROM 
                                                    ( /* case: (ECps es), with two or more elements in es.
                                                         ECps [\"atReqsCpb\",\"-ouQualifiedFor~\"] */
                                                      
                                                      SELECT DISTINCT ECps0.`ActivityType`, ECps1.`OrgUnit`
                                                      FROM `atReqsCpb` AS ECps0,
                                                           
                                                           ( /* case: EFlp x. */
                                                             /* case: ECpl e
                                                                ECpl [ \"ouQualifiedFor\" ] */
                                                             SELECT DISTINCT cfst.`OrgUnit`, csnd.`Capability`
                                                             FROM `OrgUnit` AS cfst,
                                                                  `Capability` AS csnd
                                                             WHERE NOT EXISTS
                                                              (SELECT * FROM `ouQualifiedFor` AS cp
                                                               WHERE cfst.`OrgUnit`=cp.`OrgUnit` AND csnd.`Capability`=cp.`Capability`)
                                                           ) AS ECps1
                                                      WHERE ECps0.`Capability`=ECps1.`Capability`
                                                    ) AS cp
                                               WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                                           ) AS cp
                                      WHERE isect0.`OrgUnit`=cp.`OrgUnit` AND isect0.`ActivityType`=cp.`ActivityType`) AND isect0.`OrgUnit` IS NOT NULL AND isect0.`ActivityType` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;ouMayExecuteAT;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    )
              )
    , 'SvcComponent assignment' =>
        array ( 'name' => 'SvcComponent assignment'
              , 'ruleAdl' => 'actType;atReqsSvc |- actUseSC;scImplements'
              , 'origin' => 'line 122, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'An Activity of a type that requires some Service, must use a SvcComponent that implements this Service'
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(actType;atReqsSvc) \\/ actUseSC;scImplements)
              // <=> { De Morgan }
              //     actType;atReqsSvc/\\-(actUseSC;scImplements)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actType;atReqsSvc\",\"-(actUseSC;scImplements)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Service` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actType\",\"atReqsSvc\"] */
                                 
                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Service`
                                 FROM `Activity` AS ECps0,
                                      `atReqsSvc` AS ECps1
                                 WHERE ECps0.`actType`=ECps1.`ActivityType`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actUseSC\",\"scImplements\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Service`
                                             FROM `actUseSC` AS ECps0,
                                                  `scImplements` AS ECps1
                                             WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Service`=cp.`Service`) AND isect0.`Activity` IS NOT NULL AND isect0.`Service` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Activity ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be assigned a SvcComponent that implements Service ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'Activity Integrity' =>
        array ( 'name' => 'Activity Integrity'
              , 'ruleAdl' => 'actExecutingOU~;actUseSC |- compOwner~;scDeployedOn~'
              , 'origin' => 'line 127, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'If an OrgUnit executes an activity that uses an SvcComponent, then the OrgUnit must have at least one computer on which the SvcComponent is deployed.'
              , 'message' => 'SvcComponents that need to be installed:'
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(actExecutingOU~;actUseSC) \\/ compOwner~;scDeployedOn~)
              // <=> { De Morgan }
              //     actExecutingOU~;actUseSC/\\-(compOwner~;scDeployedOn~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actExecutingOU~;actUseSC\",\"-(compOwner~;scDeployedOn~)\"] */
                          SELECT DISTINCT isect0.`actExecutingOU` AS src, isect0.`SvcComponent` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actExecutingOU~\",\"actUseSC\"] */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU`, ECps1.`SvcComponent`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actExecutingOU`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps0,
                                      `actUseSC` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compOwner~\",\"scDeployedOn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`compOwner`, ECps1.`SvcComponent`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compOwner`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Computer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                           ) AS cp
                                      WHERE isect0.`actExecutingOU`=cp.`compOwner` AND isect0.`SvcComponent`=cp.`SvcComponent`) AND isect0.`actExecutingOU` IS NOT NULL AND isect0.`SvcComponent` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'OrgUnit ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' does not have ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' deployed on its computers')
                    )
              )
    , 'planCmpStatIsRed' =>
        array ( 'name' => 'planCmpStatIsRed'
              , 'ruleAdl' => 'I[Plan]/\\planAT;(I/\\-atStatusIsGreen);planAT~ |- planCmpStat;\'Red\';planCmpStat~'
              , 'origin' => 'line 14, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-(I[Plan]/\\planAT;(I/\\-atStatusIsGreen);planAT~) \\/ planCmpStat;\'Red\';planCmpStat~)
              // <=> { De Morgan }
              //     I[Plan]/\\planAT;(I/\\-atStatusIsGreen);planAT~/\\-(planCmpStat;\'Red\';planCmpStat~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Plan]\",\"planAT;(I/\\\\-atStatusIsGreen);planAT~\",\"-(planCmpStat;\'Red\';planCmpStat~)\"] */
                          SELECT DISTINCT isect0.`actPlan` AS src, isect0.`actPlan1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `actPlan`, `actPlan` AS `actPlan1`
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planAT\",\"I/\\\\-atStatusIsGreen\",\"planAT~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Plan`, ECps2.`Plan` AS `Plan1`
                                 FROM `planAT` AS ECps0,
                                      
                                      ( /* case: (EIsc lst@(_:_:_))
                                           EIsc [\"I\",\"-atStatusIsGreen\"] */
                                        SELECT DISTINCT isect0.`ActivityType`, isect0.`ActivityType` AS `ActivityType1`
                                        FROM `ActivityType` AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM `ActivityType` AS cp
                                                    WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType`=cp.`atStatusIsGreen`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType` IS NOT NULL
                                      ) AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `ActivityType`
                                        FROM `planAT`
                                        WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                                   AND ECps1.`ActivityType1`=ECps2.`ActivityType`
                               ) AS isect1
                          WHERE (isect0.`actPlan` = isect1.`Plan` AND isect0.`actPlan1` = isect1.`Plan1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"planCmpStat\",\"\'Red\'\",\"planCmpStat~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Plan`, ECps2.`Plan` AS `Plan1`
                                             FROM `Plan` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan`, `planCmpStat`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`planCmpStat`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`planCmpStat`
                                           ) AS cp
                                      WHERE isect0.`actPlan`=cp.`Plan` AND isect0.`actPlan1`=cp.`Plan1`) AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planCmpStat;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'planCmpStatIsYellow' =>
        array ( 'name' => 'planCmpStatIsYellow'
              , 'ruleAdl' => 'I[Plan]/\\-planAT!(atStatusIsGreen;planAT~)/\\planAT;(I/\\-(actType~;actType));planAT~ |- planCmpStat;\'Yellow\';planCmpStat~'
              , 'origin' => 'line 18, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-(I[Plan]/\\-planAT!(atStatusIsGreen;planAT~)/\\planAT;(I/\\-(actType~;actType));planAT~) \\/ planCmpStat;\'Yellow\';planCmpStat~)
              // <=> { De Morgan }
              //     I[Plan]/\\-planAT!(atStatusIsGreen;planAT~)/\\planAT;(I/\\-(actType~;actType));planAT~/\\-(planCmpStat;\'Yellow\';planCmpStat~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Plan]\",\"-planAT!(atStatusIsGreen;planAT~)\",\"planAT;(I/\\\\-(actType~;actType));planAT~\",\"-(planCmpStat;\'Yellow\';planCmpStat~)\"] */
                          SELECT DISTINCT isect0.`actPlan` AS src, isect0.`actPlan1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `actPlan`, `actPlan` AS `actPlan1`
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-planAT\",\"atStatusIsGreen;planAT~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"planAT;-(atStatusIsGreen;planAT~)\" ] */
                                 SELECT DISTINCT cfst.`Plan`, csnd.`Plan` AS `Plan1`
                                 FROM `Plan` AS cfst,
                                      `Plan` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"planAT\",\"-(atStatusIsGreen;planAT~)\"] */
                                          
                                          SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                          FROM `planAT` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"atStatusIsGreen;planAT~\" ] */
                                                 SELECT DISTINCT cfst.`ActivityType`, csnd.`Plan`
                                                 FROM `ActivityType` AS cfst,
                                                      `Plan` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"atStatusIsGreen\",\"planAT~\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`ActivityType`, ECps1.`Plan`
                                                          FROM `ActivityType` AS ECps0,
                                                               
                                                               ( /* case: EFlp x. */
                                                                 SELECT DISTINCT `Plan`, `ActivityType`
                                                                 FROM `planAT`
                                                                 WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                               ) AS ECps1
                                                          WHERE ECps0.`atStatusIsGreen`=ECps1.`ActivityType`
                                                        ) AS cp
                                                   WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`Plan`=cp.`Plan`)
                                               ) AS ECps1
                                          WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                                        ) AS cp
                                   WHERE cfst.`Plan`=cp.`Plan` AND csnd.`Plan`=cp.`Plan1`)
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planAT\",\"I/\\\\-(actType~;actType)\",\"planAT~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Plan`, ECps2.`Plan` AS `Plan1`
                                 FROM `planAT` AS ECps0,
                                      
                                      ( /* case: (EIsc lst@(_:_:_))
                                           EIsc [\"I\",\"-(actType~;actType)\"] */
                                        SELECT DISTINCT isect0.`ActivityType`, isect0.`ActivityType` AS `ActivityType1`
                                        FROM `ActivityType` AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"actType~\",\"actType\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`actType`, ECps1.`actType` AS `actType1`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Activity`, `actType`
                                                                  FROM `Activity`
                                                                  WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                                ) AS ECps0,
                                                                `Activity` AS ECps1
                                                           WHERE ECps0.`Activity`=ECps1.`Activity`
                                                         ) AS cp
                                                    WHERE isect0.`ActivityType`=cp.`actType` AND isect0.`ActivityType`=cp.`actType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType` IS NOT NULL
                                      ) AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `ActivityType`
                                        FROM `planAT`
                                        WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                                   AND ECps1.`ActivityType1`=ECps2.`ActivityType`
                               ) AS isect2
                          WHERE (isect0.`actPlan` = isect1.`Plan` AND isect0.`actPlan1` = isect1.`Plan1`) AND (isect0.`actPlan` = isect2.`Plan` AND isect0.`actPlan1` = isect2.`Plan1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"planCmpStat\",\"\'Yellow\'\",\"planCmpStat~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Plan`, ECps2.`Plan` AS `Plan1`
                                             FROM `Plan` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan`, `planCmpStat`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`planCmpStat`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`planCmpStat`
                                           ) AS cp
                                      WHERE isect0.`actPlan`=cp.`Plan` AND isect0.`actPlan1`=cp.`Plan1`) AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planCmpStat;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'planCmpStatIsGreen' =>
        array ( 'name' => 'planCmpStatIsGreen'
              , 'ruleAdl' => 'I[Plan]/\\-planAT!((atStatusIsGreen/\\actType~;actType);planAT~) |- planCmpStat;\'Green\';planCmpStat~'
              , 'origin' => 'line 22, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-(I[Plan]/\\-planAT!((atStatusIsGreen/\\actType~;actType);planAT~)) \\/ planCmpStat;\'Green\';planCmpStat~)
              // <=> { De Morgan }
              //     I[Plan]/\\-planAT!((atStatusIsGreen/\\actType~;actType);planAT~)/\\-(planCmpStat;\'Green\';planCmpStat~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Plan]\",\"-planAT!((atStatusIsGreen/\\\\actType~;actType);planAT~)\",\"-(planCmpStat;\'Green\';planCmpStat~)\"] */
                          SELECT DISTINCT isect0.`actPlan` AS src, isect0.`actPlan1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `actPlan`, `actPlan` AS `actPlan1`
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-planAT\",\"(atStatusIsGreen/\\\\actType~;actType);planAT~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"planAT;-((atStatusIsGreen/\\actType~;actType);planAT~)\" ] */
                                 SELECT DISTINCT cfst.`Plan`, csnd.`Plan` AS `Plan1`
                                 FROM `Plan` AS cfst,
                                      `Plan` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"planAT\",\"-((atStatusIsGreen/\\\\actType~;actType);planAT~)\"] */
                                          
                                          SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                          FROM `planAT` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"(atStatusIsGreen/\\actType~;actType);planAT~\" ] */
                                                 SELECT DISTINCT cfst.`ActivityType`, csnd.`Plan`
                                                 FROM `ActivityType` AS cfst,
                                                      `Plan` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"atStatusIsGreen/\\\\actType~;actType\",\"planAT~\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`ActivityType`, ECps1.`Plan`
                                                          FROM 
                                                               ( /* case: (EIsc lst@(_:_:_))
                                                                    EIsc [\"atStatusIsGreen\",\"actType~;actType\"] */
                                                                 SELECT DISTINCT isect0.`ActivityType`, isect0.`atStatusIsGreen`
                                                                 FROM `ActivityType` AS isect0, 
                                                                      ( /* case: (ECps es), with two or more elements in es.
                                                                           ECps [\"actType~\",\"actType\"] */
                                                                        
                                                                        SELECT DISTINCT ECps0.`actType`, ECps1.`actType` AS `actType1`
                                                                        FROM 
                                                                             ( /* case: EFlp x. */
                                                                               SELECT DISTINCT `Activity`, `actType`
                                                                               FROM `Activity`
                                                                               WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                                             ) AS ECps0,
                                                                             `Activity` AS ECps1
                                                                        WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                      ) AS isect1
                                                                 WHERE (isect0.`ActivityType` = isect1.`actType` AND isect0.`atStatusIsGreen` = isect1.`actType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`atStatusIsGreen` IS NOT NULL
                                                               ) AS ECps0,
                                                               
                                                               ( /* case: EFlp x. */
                                                                 SELECT DISTINCT `Plan`, `ActivityType`
                                                                 FROM `planAT`
                                                                 WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                               ) AS ECps1
                                                          WHERE ECps0.`atStatusIsGreen`=ECps1.`ActivityType`
                                                        ) AS cp
                                                   WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`Plan`=cp.`Plan`)
                                               ) AS ECps1
                                          WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                                        ) AS cp
                                   WHERE cfst.`Plan`=cp.`Plan` AND csnd.`Plan`=cp.`Plan1`)
                               ) AS isect1
                          WHERE (isect0.`actPlan` = isect1.`Plan` AND isect0.`actPlan1` = isect1.`Plan1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"planCmpStat\",\"\'Green\'\",\"planCmpStat~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Plan`, ECps2.`Plan` AS `Plan1`
                                             FROM `Plan` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan`, `planCmpStat`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`planCmpStat`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`planCmpStat`
                                           ) AS cp
                                      WHERE isect0.`actPlan`=cp.`Plan` AND isect0.`actPlan1`=cp.`Plan1`) AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planCmpStat;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'InsPlanStatus' =>
        array ( 'name' => 'InsPlanStatus'
              , 'ruleAdl' => 'planMnlStat \\/ (I/\\-(planMnlStat;planMnlStat~));planCmpStat |- planStatus'
              , 'origin' => 'line 27, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(planMnlStat \\/ (I/\\-(planMnlStat;planMnlStat~));planCmpStat) \\/ planStatus)
              // <=> { De Morgan }
              //     (planMnlStat \\/ (I/\\-(planMnlStat;planMnlStat~));planCmpStat)/\\-planStatus
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"planMnlStat \\\\/ (I/\\\\-(planMnlStat;planMnlStat~));planCmpStat\",\"-planStatus\"] */
                          SELECT DISTINCT isect0.`Plan` AS src, isect0.`planMnlStat` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"planMnlStat\",\"(I/\\\\-(planMnlStat;planMnlStat~));planCmpStat\"] */
                                 (SELECT DISTINCT `Plan`, `planMnlStat`
                                     FROM `Plan`
                                     WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"I/\\\\-(planMnlStat;planMnlStat~)\",\"planCmpStat\"] */
                                     
                                     SELECT DISTINCT ECps0.`actPlan` AS `Plan`, ECps1.`planCmpStat` AS `planMnlStat`
                                     FROM 
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"-(planMnlStat;planMnlStat~)\"] */
                                            SELECT DISTINCT isect0.`actPlan`, isect0.`actPlan` AS `actPlan1`
                                            FROM `Activity` AS isect0
                                            WHERE NOT EXISTS (SELECT * FROM 
                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                  ECps [\"planMnlStat\",\"planMnlStat~\"] */
                                                               
                                                               SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                                               FROM `Plan` AS ECps0,
                                                                    
                                                                    ( /* case: EFlp x. */
                                                                      SELECT DISTINCT `Plan`, `planMnlStat`
                                                                      FROM `Plan`
                                                                      WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL
                                                                    ) AS ECps1
                                                               WHERE ECps0.`planMnlStat`=ECps1.`planMnlStat`
                                                             ) AS cp
                                                        WHERE isect0.`actPlan`=cp.`Plan` AND isect0.`actPlan`=cp.`Plan1`) AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan` IS NOT NULL
                                          ) AS ECps0,
                                          `Plan` AS ECps1
                                     WHERE ECps0.`actPlan1`=ECps1.`Plan`
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Plan` AS cp
                                      WHERE isect0.`Plan`=cp.`Plan` AND isect0.`planMnlStat`=cp.`planStatus`) AND isect0.`Plan` IS NOT NULL AND isect0.`planMnlStat` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planStatus;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultPlanStatus' =>
        array ( 'name' => 'defaultPlanStatus'
              , 'ruleAdl' => 'I[Plan] |- planStatus;planStatus~'
              , 'origin' => 'line 30, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-I[Plan] \\/ planStatus;planStatus~)
              // <=> { De Morgan }
              //     I[Plan]/\\-(planStatus;planStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Plan]\",\"-(planStatus;planStatus~)\"] */
                          SELECT DISTINCT isect0.`actPlan` AS src, isect0.`actPlan1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `actPlan`, `actPlan` AS `actPlan1`
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"planStatus\",\"planStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                             FROM `Plan` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan`, `planStatus`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`planStatus`=ECps1.`planStatus`
                                           ) AS cp
                                      WHERE isect0.`actPlan`=cp.`Plan` AND isect0.`actPlan1`=cp.`Plan1`) AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;planStatus;Plan;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Plan'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                 FROM `Activity`
                                 WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'insatStatusIsGreen' =>
        array ( 'name' => 'insatStatusIsGreen'
              , 'ruleAdl' => 'I[ActivityType]/\\ouMayExecuteAT~;ouMayExecuteAT/\\-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~) |- atStatusIsGreen'
              , 'origin' => 'line 45, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(I[ActivityType]/\\ouMayExecuteAT~;ouMayExecuteAT/\\-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~)) \\/ atStatusIsGreen)
              // <=> { De Morgan }
              //     I[ActivityType]/\\ouMayExecuteAT~;ouMayExecuteAT/\\-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~)/\\-atStatusIsGreen
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[ActivityType]\",\"ouMayExecuteAT~;ouMayExecuteAT\",\"-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~)\",\"-atStatusIsGreen\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`ActivityType1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `ActivityType`, `ActivityType` AS `ActivityType1`
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ouMayExecuteAT~\",\"ouMayExecuteAT\"] */
                                 
                                 SELECT DISTINCT ECps0.`ActivityType`, ECps1.`ActivityType` AS `ActivityType1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit`, `ActivityType`
                                        FROM `ouMayExecuteAT`
                                        WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps0,
                                      `ouMayExecuteAT` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect1
                          WHERE (isect0.`ActivityType` = isect1.`ActivityType` AND isect0.`ActivityType1` = isect1.`ActivityType1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"atReqsSvc\",\"-(scImplements~;scImplements)\",\"atReqsSvc~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ActivityType`, ECps2.`ActivityType` AS `ActivityType1`
                                             FROM `atReqsSvc` AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl [ \"scImplements~;scImplements\" ] */
                                                    SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                                    FROM `Service` AS cfst,
                                                         `Service` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                ECps [\"scImplements~\",\"scImplements\"] */
                                                             
                                                             SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                                             FROM 
                                                                  ( /* case: EFlp x. */
                                                                    SELECT DISTINCT `SvcComponent`, `Service`
                                                                    FROM `scImplements`
                                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  `scImplements` AS ECps1
                                                             WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                           ) AS cp
                                                      WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ActivityType`, `Service`
                                                    FROM `atReqsSvc`
                                                    WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`Service`=ECps1.`Service`
                                               AND ECps1.`Service1`=ECps2.`Service`
                                           ) AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`ActivityType1`) AND NOT EXISTS (SELECT * FROM `ActivityType` AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`atStatusIsGreen`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatusIsGreen;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatus;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'delatStatusIsGreen' =>
        array ( 'name' => 'delatStatusIsGreen'
              , 'ruleAdl' => 'atStatusIsGreen |- I[ActivityType]/\\ouMayExecuteAT~;ouMayExecuteAT/\\-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~)'
              , 'origin' => 'line 54, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-atStatusIsGreen \\/ (I[ActivityType]/\\ouMayExecuteAT~;ouMayExecuteAT/\\-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~)))
              // <=> { De Morgan }
              //     atStatusIsGreen/\\-(I[ActivityType]/\\ouMayExecuteAT~;ouMayExecuteAT/\\-(atReqsSvc;-(scImplements~;scImplements);atReqsSvc~))
              // <=> { De Morgan }
              //     atStatusIsGreen/\\(-I[ActivityType] \\/ -(ouMayExecuteAT~;ouMayExecuteAT) \\/ atReqsSvc;-(scImplements~;scImplements);atReqsSvc~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atStatusIsGreen\",\"-I[ActivityType] \\\\/ -(ouMayExecuteAT~;ouMayExecuteAT) \\\\/ atReqsSvc;-(scImplements~;scImplements);atReqsSvc~\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`atStatusIsGreen` AS tgt
                          FROM `ActivityType` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[ActivityType]\",\"-(ouMayExecuteAT~;ouMayExecuteAT)\",\"atReqsSvc;-(scImplements~;scImplements);atReqsSvc~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[ActivityType]\" ] */
                                     SELECT DISTINCT cfst.`ActivityType`, csnd.`ActivityType` AS `ActivityType1`
                                     FROM `ActivityType` AS cfst,
                                          `ActivityType` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `ActivityType`, `ActivityType` AS `ActivityType1`
                                              FROM `ActivityType`
                                              WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`ActivityType`=cp.`ActivityType1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"ouMayExecuteAT~;ouMayExecuteAT\" ] */
                                     SELECT DISTINCT cfst.`ActivityType`, csnd.`ActivityType` AS `ActivityType1`
                                     FROM `ActivityType` AS cfst,
                                          `ActivityType` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"ouMayExecuteAT~\",\"ouMayExecuteAT\"] */
                                              
                                              SELECT DISTINCT ECps0.`ActivityType`, ECps1.`ActivityType` AS `ActivityType1`
                                              FROM 
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `OrgUnit`, `ActivityType`
                                                     FROM `ouMayExecuteAT`
                                                     WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                   ) AS ECps0,
                                                   `ouMayExecuteAT` AS ECps1
                                              WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                                            ) AS cp
                                       WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`ActivityType`=cp.`ActivityType1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"atReqsSvc\",\"-(scImplements~;scImplements)\",\"atReqsSvc~\"] */
                                     
                                     SELECT DISTINCT ECps0.`ActivityType`, ECps2.`ActivityType` AS `ActivityType1`
                                     FROM `atReqsSvc` AS ECps0,
                                          
                                          ( /* case: ECpl e
                                               ECpl [ \"scImplements~;scImplements\" ] */
                                            SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                            FROM `Service` AS cfst,
                                                 `Service` AS csnd
                                            WHERE NOT EXISTS
                                             (SELECT * FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        ECps [\"scImplements~\",\"scImplements\"] */
                                                     
                                                     SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                                     FROM 
                                                          ( /* case: EFlp x. */
                                                            SELECT DISTINCT `SvcComponent`, `Service`
                                                            FROM `scImplements`
                                                            WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                          ) AS ECps0,
                                                          `scImplements` AS ECps1
                                                     WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                   ) AS cp
                                              WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                          ) AS ECps1,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `ActivityType`, `Service`
                                            FROM `atReqsSvc`
                                            WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                          ) AS ECps2
                                     WHERE ECps0.`Service`=ECps1.`Service`
                                       AND ECps1.`Service1`=ECps2.`Service`
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`ActivityType` = isect1.`ActivityType` AND isect0.`atStatusIsGreen` = isect1.`ActivityType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`atStatusIsGreen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;atStatusIsGreen;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    )
              )
    , 'atStatusIsYellow' =>
        array ( 'name' => 'atStatusIsYellow'
              , 'ruleAdl' => 'I[ActivityType]/\\-atStatusIsGreen/\\-(planAT~;planAT) |- atStatus;\'Yellow\';atStatus~'
              , 'origin' => 'line 62, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(I[ActivityType]/\\-atStatusIsGreen/\\-(planAT~;planAT)) \\/ atStatus;\'Yellow\';atStatus~)
              // <=> { De Morgan }
              //     I[ActivityType]/\\-atStatusIsGreen/\\-(planAT~;planAT)/\\-(atStatus;\'Yellow\';atStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[ActivityType]\",\"-atStatusIsGreen\",\"-(planAT~;planAT)\",\"-(atStatus;\'Yellow\';atStatus~)\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`ActivityType1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `ActivityType`, `ActivityType` AS `ActivityType1`
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `ActivityType` AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`atStatusIsGreen`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"planAT~\",\"planAT\"] */
                                             
                                             SELECT DISTINCT ECps0.`ActivityType`, ECps1.`ActivityType` AS `ActivityType1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan`, `ActivityType`
                                                    FROM `planAT`
                                                    WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                  ) AS ECps0,
                                                  `planAT` AS ECps1
                                             WHERE ECps0.`Plan`=ECps1.`Plan`
                                           ) AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`ActivityType1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"atStatus\",\"\'Yellow\'\",\"atStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ActivityType`, ECps2.`ActivityType` AS `ActivityType1`
                                             FROM `ActivityType` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ActivityType`, `atStatus`
                                                    FROM `ActivityType`
                                                    WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`atStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`atStatus`
                                           ) AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`ActivityType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatus;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'atStatusIsRed' =>
        array ( 'name' => 'atStatusIsRed'
              , 'ruleAdl' => 'I[ActivityType]/\\-atStatusIsGreen/\\planAT~;planAT |- atStatus;\'Red\';atStatus~'
              , 'origin' => 'line 66, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(I[ActivityType]/\\-atStatusIsGreen/\\planAT~;planAT) \\/ atStatus;\'Red\';atStatus~)
              // <=> { De Morgan }
              //     I[ActivityType]/\\-atStatusIsGreen/\\planAT~;planAT/\\-(atStatus;\'Red\';atStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[ActivityType]\",\"-atStatusIsGreen\",\"planAT~;planAT\",\"-(atStatus;\'Red\';atStatus~)\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`ActivityType1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `ActivityType`, `ActivityType` AS `ActivityType1`
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planAT~\",\"planAT\"] */
                                 
                                 SELECT DISTINCT ECps0.`ActivityType`, ECps1.`ActivityType` AS `ActivityType1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `ActivityType`
                                        FROM `planAT`
                                        WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL
                                      ) AS ECps0,
                                      `planAT` AS ECps1
                                 WHERE ECps0.`Plan`=ECps1.`Plan`
                               ) AS isect1
                          WHERE (isect0.`ActivityType` = isect1.`ActivityType` AND isect0.`ActivityType1` = isect1.`ActivityType1`) AND NOT EXISTS (SELECT * FROM `ActivityType` AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`atStatusIsGreen`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"atStatus\",\"\'Red\'\",\"atStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ActivityType`, ECps2.`ActivityType` AS `ActivityType1`
                                             FROM `ActivityType` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ActivityType`, `atStatus`
                                                    FROM `ActivityType`
                                                    WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`atStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`atStatus`
                                           ) AS cp
                                      WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType1`=cp.`ActivityType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;atStatus;ActivityType;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ActivityType'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                 FROM `ActivityType`
                                 WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'actCmpStatIsRed' =>
        array ( 'name' => 'actCmpStatIsRed'
              , 'ruleAdl' => 'I[Activity]/\\(-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~)) |- actCmpStat;\'Red\';actCmpStat~'
              , 'origin' => 'line 82, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-(I[Activity]/\\(-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~))) \\/ actCmpStat;\'Red\';actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity]/\\(-(actExecutingOU;actExecutingOU~) \\/ -(actPlanStart;actPlanStart~))/\\-(actCmpStat;\'Red\';actCmpStat~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Activity]\",\"-(actExecutingOU;actExecutingOU~) \\\\/ -(actPlanStart;actPlanStart~)\",\"-(actCmpStat;\'Red\';actCmpStat~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Activity`, `Activity` AS `Activity1`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-(actExecutingOU;actExecutingOU~)\",\"-(actPlanStart;actPlanStart~)\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"actExecutingOU;actExecutingOU~\" ] */
                                     SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                     FROM `Activity` AS cfst,
                                          `Activity` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"actExecutingOU\",\"actExecutingOU~\"] */
                                              
                                              SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Activity`, `actExecutingOU`
                                                     FROM `Activity`
                                                     WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                                            ) AS cp
                                       WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"actPlanStart;actPlanStart~\" ] */
                                     SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                     FROM `Activity` AS cfst,
                                          `Activity` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"actPlanStart\",\"actPlanStart~\"] */
                                              
                                              SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Activity`, `actPlanStart`
                                                     FROM `Activity`
                                                     WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`actPlanStart`=ECps1.`actPlanStart`
                                            ) AS cp
                                       WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Activity` = isect1.`Activity` AND isect0.`Activity1` = isect1.`Activity1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actCmpStat\",\"\'Red\'\",\"actCmpStat~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps2.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actCmpStat`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`actCmpStat`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`actCmpStat`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'actCmpStatIsYellow' =>
        array ( 'name' => 'actCmpStatIsYellow'
              , 'ruleAdl' => 'I[Activity]/\\actExecutingOU;actExecutingOU~/\\actPlanStart;actPlanStart~/\\(I/\\-(actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~))))) |- actCmpStat;\'Yellow\';actCmpStat~'
              , 'origin' => 'line 86, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-(I[Activity]/\\actExecutingOU;actExecutingOU~/\\actPlanStart;actPlanStart~/\\I/\\-(actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~))))) \\/ actCmpStat;\'Yellow\';actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity]/\\actExecutingOU;actExecutingOU~/\\actPlanStart;actPlanStart~/\\I/\\-(actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~))))/\\-(actCmpStat;\'Yellow\';actCmpStat~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Activity]\",\"actExecutingOU;actExecutingOU~\",\"actPlanStart;actPlanStart~\",\"I\",\"-(actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~))))\",\"-(actCmpStat;\'Yellow\';actCmpStat~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Activity`, `Activity` AS `Activity1`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actExecutingOU\",\"actExecutingOU~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                 FROM `Activity` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actExecutingOU`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actPlanStart\",\"actPlanStart~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                 FROM `Activity` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actPlanStart`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`actPlanStart`=ECps1.`actPlanStart`
                               ) AS isect2, `Activity` AS isect3
                          WHERE (isect0.`Activity` = isect1.`Activity` AND isect0.`Activity1` = isect1.`Activity1`) AND (isect0.`Activity` = isect2.`Activity` AND isect0.`Activity1` = isect2.`Activity1`) AND isect0.`Activity` = isect0.`Activity1` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actType\",\"-atReqsSvc!(scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~))\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  
                                                  ( /* case: ERad es@(_:_:_)
                                                       ERad [\"-atReqsSvc\",\"scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~)\"] */
                                                    /* case: ECpl e
                                                       ECpl [ \"atReqsSvc;-(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~))\" ] */
                                                    SELECT DISTINCT cfst.`ActivityType`, csnd.`Activity`
                                                    FROM `ActivityType` AS cfst,
                                                         `Activity` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                ECps [\"atReqsSvc\",\"-(scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~))\"] */
                                                             
                                                             SELECT DISTINCT ECps0.`ActivityType`, ECps1.`Activity`
                                                             FROM `atReqsSvc` AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl [ \"scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~)\" ] */
                                                                    SELECT DISTINCT cfst.`Service`, csnd.`Activity`
                                                                    FROM `Service` AS cfst,
                                                                         `Activity` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                                ECps [\"scImplements~\",\"actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~\"] */
                                                                             
                                                                             SELECT DISTINCT ECps0.`Service`, ECps1.`Activity`
                                                                             FROM 
                                                                                  ( /* case: EFlp x. */
                                                                                    SELECT DISTINCT `SvcComponent`, `Service`
                                                                                    FROM `scImplements`
                                                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                  ) AS ECps0,
                                                                                  
                                                                                  ( /* case: (EIsc lst@(_:_:_))
                                                                                       EIsc [\"actUseSC~\",\"scDeployedOn;compOwner;actExecutingOU~\"] */
                                                                                    SELECT DISTINCT isect0.`SvcComponent`, isect0.`Activity`
                                                                                    FROM 
                                                                                         ( /* case: EFlp x. */
                                                                                           SELECT DISTINCT `Activity`, `SvcComponent`
                                                                                           FROM `actUseSC`
                                                                                           WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL
                                                                                         ) AS isect0, 
                                                                                         ( /* case: (ECps es), with two or more elements in es.
                                                                                              ECps [\"scDeployedOn\",\"compOwner\",\"actExecutingOU~\"] */
                                                                                           
                                                                                           SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`Activity`
                                                                                           FROM `scDeployedOn` AS ECps0,
                                                                                                `Computer` AS ECps1,
                                                                                                
                                                                                                ( /* case: EFlp x. */
                                                                                                  SELECT DISTINCT `Activity`, `actExecutingOU`
                                                                                                  FROM `Activity`
                                                                                                  WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                                                ) AS ECps2
                                                                                           WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                             AND ECps1.`compOwner`=ECps2.`actExecutingOU`
                                                                                         ) AS isect1
                                                                                    WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`Activity` = isect1.`Activity`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`Activity` IS NOT NULL
                                                                                  ) AS ECps1
                                                                             WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                                           ) AS cp
                                                                      WHERE cfst.`Service`=cp.`Service` AND csnd.`Activity`=cp.`Activity`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`Service`=ECps1.`Service`
                                                           ) AS cp
                                                      WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`Activity`=cp.`Activity`)
                                                  ) AS ECps1
                                             WHERE ECps0.`actType`=ECps1.`ActivityType`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actCmpStat\",\"\'Yellow\'\",\"actCmpStat~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps2.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actCmpStat`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`actCmpStat`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`actCmpStat`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'actCmpStatIsGreen' =>
        array ( 'name' => 'actCmpStatIsGreen'
              , 'ruleAdl' => 'I[Activity]/\\actExecutingOU;actExecutingOU~/\\actPlanStart;actPlanStart~/\\actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~))) |- actCmpStat;\'Green\';actCmpStat~'
              , 'origin' => 'line 92, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-(I[Activity]/\\actExecutingOU;actExecutingOU~/\\actPlanStart;actPlanStart~/\\actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~)))) \\/ actCmpStat;\'Green\';actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity]/\\actExecutingOU;actExecutingOU~/\\actPlanStart;actPlanStart~/\\actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~)))/\\-(actCmpStat;\'Green\';actCmpStat~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Activity]\",\"actExecutingOU;actExecutingOU~\",\"actPlanStart;actPlanStart~\",\"actType;(-atReqsSvc!(scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~)))\",\"-(actCmpStat;\'Green\';actCmpStat~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Activity`, `Activity` AS `Activity1`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actExecutingOU\",\"actExecutingOU~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                 FROM `Activity` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actExecutingOU`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actPlanStart\",\"actPlanStart~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                 FROM `Activity` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actPlanStart`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`actPlanStart`=ECps1.`actPlanStart`
                               ) AS isect2, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actType\",\"-atReqsSvc!(scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~))\"] */
                                 
                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                 FROM `Activity` AS ECps0,
                                      
                                      ( /* case: ERad es@(_:_:_)
                                           ERad [\"-atReqsSvc\",\"scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~)\"] */
                                        /* case: ECpl e
                                           ECpl [ \"atReqsSvc;-(scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~))\" ] */
                                        SELECT DISTINCT cfst.`ActivityType`, csnd.`Activity`
                                        FROM `ActivityType` AS cfst,
                                             `Activity` AS csnd
                                        WHERE NOT EXISTS
                                         (SELECT * FROM 
                                               ( /* case: (ECps es), with two or more elements in es.
                                                    ECps [\"atReqsSvc\",\"-(scImplements~;(actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~))\"] */
                                                 
                                                 SELECT DISTINCT ECps0.`ActivityType`, ECps1.`Activity`
                                                 FROM `atReqsSvc` AS ECps0,
                                                      
                                                      ( /* case: ECpl e
                                                           ECpl [ \"scImplements~;(actUseSC~/\\scDeployedOn;compOwner;actExecutingOU~)\" ] */
                                                        SELECT DISTINCT cfst.`Service`, csnd.`Activity`
                                                        FROM `Service` AS cfst,
                                                             `Activity` AS csnd
                                                        WHERE NOT EXISTS
                                                         (SELECT * FROM 
                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                    ECps [\"scImplements~\",\"actUseSC~/\\\\scDeployedOn;compOwner;actExecutingOU~\"] */
                                                                 
                                                                 SELECT DISTINCT ECps0.`Service`, ECps1.`Activity`
                                                                 FROM 
                                                                      ( /* case: EFlp x. */
                                                                        SELECT DISTINCT `SvcComponent`, `Service`
                                                                        FROM `scImplements`
                                                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                      ) AS ECps0,
                                                                      
                                                                      ( /* case: (EIsc lst@(_:_:_))
                                                                           EIsc [\"actUseSC~\",\"scDeployedOn;compOwner;actExecutingOU~\"] */
                                                                        SELECT DISTINCT isect0.`SvcComponent`, isect0.`Activity`
                                                                        FROM 
                                                                             ( /* case: EFlp x. */
                                                                               SELECT DISTINCT `Activity`, `SvcComponent`
                                                                               FROM `actUseSC`
                                                                               WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL
                                                                             ) AS isect0, 
                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                  ECps [\"scDeployedOn\",\"compOwner\",\"actExecutingOU~\"] */
                                                                               
                                                                               SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`Activity`
                                                                               FROM `scDeployedOn` AS ECps0,
                                                                                    `Computer` AS ECps1,
                                                                                    
                                                                                    ( /* case: EFlp x. */
                                                                                      SELECT DISTINCT `Activity`, `actExecutingOU`
                                                                                      FROM `Activity`
                                                                                      WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                                    ) AS ECps2
                                                                               WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                 AND ECps1.`compOwner`=ECps2.`actExecutingOU`
                                                                             ) AS isect1
                                                                        WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`Activity` = isect1.`Activity`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`Activity` IS NOT NULL
                                                                      ) AS ECps1
                                                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                               ) AS cp
                                                          WHERE cfst.`Service`=cp.`Service` AND csnd.`Activity`=cp.`Activity`)
                                                      ) AS ECps1
                                                 WHERE ECps0.`Service`=ECps1.`Service`
                                               ) AS cp
                                          WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`Activity`=cp.`Activity`)
                                      ) AS ECps1
                                 WHERE ECps0.`actType`=ECps1.`ActivityType`
                               ) AS isect3
                          WHERE (isect0.`Activity` = isect1.`Activity` AND isect0.`Activity1` = isect1.`Activity1`) AND (isect0.`Activity` = isect2.`Activity` AND isect0.`Activity1` = isect2.`Activity1`) AND (isect0.`Activity` = isect3.`Activity` AND isect0.`Activity1` = isect3.`Activity1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actCmpStat\",\"\'Green\'\",\"actCmpStat~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps2.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actCmpStat`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`actCmpStat`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`actCmpStat`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'InsActivityStatus' =>
        array ( 'name' => 'InsActivityStatus'
              , 'ruleAdl' => 'actMnlStat \\/ (I/\\-(actMnlStat;actMnlStat~));actCmpStat |- actStatus'
              , 'origin' => 'line 99, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(actMnlStat \\/ (I/\\-(actMnlStat;actMnlStat~));actCmpStat) \\/ actStatus)
              // <=> { De Morgan }
              //     (actMnlStat \\/ (I/\\-(actMnlStat;actMnlStat~));actCmpStat)/\\-actStatus
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actMnlStat \\\\/ (I/\\\\-(actMnlStat;actMnlStat~));actCmpStat\",\"-actStatus\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`actMnlStat` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"actMnlStat\",\"(I/\\\\-(actMnlStat;actMnlStat~));actCmpStat\"] */
                                 (SELECT DISTINCT `Activity`, `actMnlStat`
                                     FROM `Activity`
                                     WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"I/\\\\-(actMnlStat;actMnlStat~)\",\"actCmpStat\"] */
                                     
                                     SELECT DISTINCT ECps0.`Activity`, ECps1.`actCmpStat` AS `actMnlStat`
                                     FROM 
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"-(actMnlStat;actMnlStat~)\"] */
                                            SELECT DISTINCT isect0.`Activity`, isect0.`Activity` AS `Activity1`
                                            FROM `Activity` AS isect0
                                            WHERE NOT EXISTS (SELECT * FROM 
                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                  ECps [\"actMnlStat\",\"actMnlStat~\"] */
                                                               
                                                               SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                                               FROM `Activity` AS ECps0,
                                                                    
                                                                    ( /* case: EFlp x. */
                                                                      SELECT DISTINCT `Activity`, `actMnlStat`
                                                                      FROM `Activity`
                                                                      WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL
                                                                    ) AS ECps1
                                                               WHERE ECps0.`actMnlStat`=ECps1.`actMnlStat`
                                                             ) AS cp
                                                        WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity` IS NOT NULL
                                          ) AS ECps0,
                                          `Activity` AS ECps1
                                     WHERE ECps0.`Activity1`=ECps1.`Activity`
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Activity` AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`actMnlStat`=cp.`actStatus`) AND isect0.`Activity` IS NOT NULL AND isect0.`actMnlStat` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actStatus;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultActivityStatus' =>
        array ( 'name' => 'defaultActivityStatus'
              , 'ruleAdl' => 'I[Activity] |- actStatus;actStatus~'
              , 'origin' => 'line 102, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-I[Activity] \\/ actStatus;actStatus~)
              // <=> { De Morgan }
              //     I[Activity]/\\-(actStatus;actStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Activity]\",\"-(actStatus;actStatus~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Activity`, `Activity` AS `Activity1`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actStatus\",\"actStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actStatus`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`actStatus`=ECps1.`actStatus`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actStatus;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsOrgUnitStatus' =>
        array ( 'name' => 'InsOrgUnitStatus'
              , 'ruleAdl' => 'ouMnlStat \\/ (I/\\-(ouMnlStat;ouMnlStat~));ouCmpStat |- ouStatus'
              , 'origin' => 'line 108, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(ouMnlStat \\/ (I/\\-(ouMnlStat;ouMnlStat~));ouCmpStat) \\/ ouStatus)
              // <=> { De Morgan }
              //     (ouMnlStat \\/ (I/\\-(ouMnlStat;ouMnlStat~));ouCmpStat)/\\-ouStatus
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ouMnlStat \\\\/ (I/\\\\-(ouMnlStat;ouMnlStat~));ouCmpStat\",\"-ouStatus\"] */
                          SELECT DISTINCT isect0.`OrgUnit` AS src, isect0.`ouMnlStat` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"ouMnlStat\",\"(I/\\\\-(ouMnlStat;ouMnlStat~));ouCmpStat\"] */
                                 (SELECT DISTINCT `OrgUnit`, `ouMnlStat`
                                     FROM `OrgUnit`
                                     WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"I/\\\\-(ouMnlStat;ouMnlStat~)\",\"ouCmpStat\"] */
                                     
                                     SELECT DISTINCT ECps0.`actExecutingOU` AS `OrgUnit`, ECps1.`ouCmpStat` AS `ouMnlStat`
                                     FROM 
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"-(ouMnlStat;ouMnlStat~)\"] */
                                            SELECT DISTINCT isect0.`actExecutingOU`, isect0.`actExecutingOU` AS `actExecutingOU1`
                                            FROM `Activity` AS isect0
                                            WHERE NOT EXISTS (SELECT * FROM 
                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                  ECps [\"ouMnlStat\",\"ouMnlStat~\"] */
                                                               
                                                               SELECT DISTINCT ECps0.`OrgUnit`, ECps1.`OrgUnit` AS `OrgUnit1`
                                                               FROM `OrgUnit` AS ECps0,
                                                                    
                                                                    ( /* case: EFlp x. */
                                                                      SELECT DISTINCT `OrgUnit`, `ouMnlStat`
                                                                      FROM `OrgUnit`
                                                                      WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL
                                                                    ) AS ECps1
                                                               WHERE ECps0.`ouMnlStat`=ECps1.`ouMnlStat`
                                                             ) AS cp
                                                        WHERE isect0.`actExecutingOU`=cp.`OrgUnit` AND isect0.`actExecutingOU`=cp.`OrgUnit1`) AND isect0.`actExecutingOU` IS NOT NULL AND isect0.`actExecutingOU` IS NOT NULL
                                          ) AS ECps0,
                                          `OrgUnit` AS ECps1
                                     WHERE ECps0.`actExecutingOU1`=ECps1.`OrgUnit`
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `OrgUnit` AS cp
                                      WHERE isect0.`OrgUnit`=cp.`OrgUnit` AND isect0.`ouMnlStat`=cp.`ouStatus`) AND isect0.`OrgUnit` IS NOT NULL AND isect0.`ouMnlStat` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouStatus;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultOrgUnitStatus' =>
        array ( 'name' => 'defaultOrgUnitStatus'
              , 'ruleAdl' => 'I[OrgUnit] |- ouStatus;ouStatus~'
              , 'origin' => 'line 111, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'OrgUnit'
              // original expression:
              //     -(-I[OrgUnit] \\/ ouStatus;ouStatus~)
              // <=> { De Morgan }
              //     I[OrgUnit]/\\-(ouStatus;ouStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[OrgUnit]\",\"-(ouStatus;ouStatus~)\"] */
                          SELECT DISTINCT isect0.`actExecutingOU` AS src, isect0.`actExecutingOU1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `actExecutingOU`, `actExecutingOU` AS `actExecutingOU1`
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"ouStatus\",\"ouStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`OrgUnit`, ECps1.`OrgUnit` AS `OrgUnit1`
                                             FROM `OrgUnit` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `OrgUnit`, `ouStatus`
                                                    FROM `OrgUnit`
                                                    WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`ouStatus`=ECps1.`ouStatus`
                                           ) AS cp
                                      WHERE isect0.`actExecutingOU`=cp.`OrgUnit` AND isect0.`actExecutingOU1`=cp.`OrgUnit1`) AND isect0.`actExecutingOU` IS NOT NULL AND isect0.`actExecutingOU1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouStatus;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                 FROM `Activity`
                                 WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsSvcComponentStatus' =>
        array ( 'name' => 'InsSvcComponentStatus'
              , 'ruleAdl' => 'scMnlStat \\/ (I/\\-(scMnlStat;scMnlStat~));scCmpStat |- scStatus'
              , 'origin' => 'line 117, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(scMnlStat \\/ (I/\\-(scMnlStat;scMnlStat~));scCmpStat) \\/ scStatus)
              // <=> { De Morgan }
              //     (scMnlStat \\/ (I/\\-(scMnlStat;scMnlStat~));scCmpStat)/\\-scStatus
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scMnlStat \\\\/ (I/\\\\-(scMnlStat;scMnlStat~));scCmpStat\",\"-scStatus\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scMnlStat` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"scMnlStat\",\"(I/\\\\-(scMnlStat;scMnlStat~));scCmpStat\"] */
                                 (SELECT DISTINCT `SvcComponent`, `scMnlStat`
                                     FROM `SvcComponent`
                                     WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"I/\\\\-(scMnlStat;scMnlStat~)\",\"scCmpStat\"] */
                                     
                                     SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`scCmpStat` AS `scMnlStat`
                                     FROM 
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"-(scMnlStat;scMnlStat~)\"] */
                                            SELECT DISTINCT isect0.`SvcComponent`, isect0.`SvcComponent` AS `SvcComponent1`
                                            FROM `SvcComponent` AS isect0
                                            WHERE NOT EXISTS (SELECT * FROM 
                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                  ECps [\"scMnlStat\",\"scMnlStat~\"] */
                                                               
                                                               SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                                               FROM `SvcComponent` AS ECps0,
                                                                    
                                                                    ( /* case: EFlp x. */
                                                                      SELECT DISTINCT `SvcComponent`, `scMnlStat`
                                                                      FROM `SvcComponent`
                                                                      WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL
                                                                    ) AS ECps1
                                                               WHERE ECps0.`scMnlStat`=ECps1.`scMnlStat`
                                                             ) AS cp
                                                        WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent` IS NOT NULL
                                          ) AS ECps0,
                                          `SvcComponent` AS ECps1
                                     WHERE ECps0.`SvcComponent1`=ECps1.`SvcComponent`
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`scMnlStat`=cp.`scStatus`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scMnlStat` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultSvcComponentStatus' =>
        array ( 'name' => 'defaultSvcComponentStatus'
              , 'ruleAdl' => 'I[SvcComponent] |- scStatus;scStatus~'
              , 'origin' => 'line 120, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-I[SvcComponent] \\/ scStatus;scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\-(scStatus;scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"-(scStatus;scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`scStatus`=ECps1.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsComputerStatus' =>
        array ( 'name' => 'InsComputerStatus'
              , 'ruleAdl' => 'compMnlStat \\/ (I/\\-(compMnlStat;compMnlStat~));compCmpStat |- compStatus'
              , 'origin' => 'line 126, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(compMnlStat \\/ (I/\\-(compMnlStat;compMnlStat~));compCmpStat) \\/ compStatus)
              // <=> { De Morgan }
              //     (compMnlStat \\/ (I/\\-(compMnlStat;compMnlStat~));compCmpStat)/\\-compStatus
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compMnlStat \\\\/ (I/\\\\-(compMnlStat;compMnlStat~));compCmpStat\",\"-compStatus\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compMnlStat` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"compMnlStat\",\"(I/\\\\-(compMnlStat;compMnlStat~));compCmpStat\"] */
                                 (SELECT DISTINCT `Computer`, `compMnlStat`
                                     FROM `Computer`
                                     WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"I/\\\\-(compMnlStat;compMnlStat~)\",\"compCmpStat\"] */
                                     
                                     SELECT DISTINCT ECps0.`Computer`, ECps1.`compCmpStat` AS `compMnlStat`
                                     FROM 
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"-(compMnlStat;compMnlStat~)\"] */
                                            SELECT DISTINCT isect0.`Computer`, isect0.`Computer` AS `Computer1`
                                            FROM `Computer` AS isect0
                                            WHERE NOT EXISTS (SELECT * FROM 
                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                  ECps [\"compMnlStat\",\"compMnlStat~\"] */
                                                               
                                                               SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                                               FROM `Computer` AS ECps0,
                                                                    
                                                                    ( /* case: EFlp x. */
                                                                      SELECT DISTINCT `Computer`, `compMnlStat`
                                                                      FROM `Computer`
                                                                      WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL
                                                                    ) AS ECps1
                                                               WHERE ECps0.`compMnlStat`=ECps1.`compMnlStat`
                                                             ) AS cp
                                                        WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer` IS NOT NULL
                                          ) AS ECps0,
                                          `Computer` AS ECps1
                                     WHERE ECps0.`Computer1`=ECps1.`Computer`
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`compMnlStat`=cp.`compStatus`) AND isect0.`Computer` IS NOT NULL AND isect0.`compMnlStat` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Status` AS src, `Status` AS tgt
                                 FROM `Status`
                                 WHERE `Status` IS NOT NULL AND `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultComputerStatus' =>
        array ( 'name' => 'defaultComputerStatus'
              , 'ruleAdl' => 'I[Computer] |- compStatus;compStatus~'
              , 'origin' => 'line 129, file "CSA_Op Status.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-I[Computer] \\/ compStatus;compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\-(compStatus;compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"-(compStatus;compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`compStatus`=ECps1.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'Create path within network' =>
        array ( 'name' => 'Create path within network'
              , 'ruleAdl' => 'routerNeedsPathTo/\\routerNW;routerNW~/\\-I |- rrtStar'
              , 'origin' => 'line 10, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'Any routes within a network, for which there is a need, must exist.'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerNeedsPathTo/\\routerNW;routerNW~/\\-I) \\/ rrtStar)
              // <=> { De Morgan }
              //     routerNeedsPathTo/\\routerNW;routerNW~/\\-I/\\-rrtStar
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNeedsPathTo\",\"routerNW;routerNW~\",\"-I\",\"-rrtStar\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `routerNeedsPathTo` AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW\",\"routerNW~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                 FROM `Router` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect1
                          WHERE (isect0.`sRouter` = isect1.`Router` AND isect0.`tRouter` = isect1.`Router1`) AND isect0.`sRouter` <> isect0.`tRouter` AND NOT EXISTS (SELECT * FROM `rrtStar` AS cp
                                      WHERE isect0.`sRouter`=cp.`sRouter` AND isect0.`tRouter`=cp.`tRouter`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;rrtDirect;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Remove routes from non-network routers' =>
        array ( 'name' => 'Remove routes from non-network routers'
              , 'ruleAdl' => 'rrtDirect |- routerNW;(I \\/ -I);routerNW~'
              , 'origin' => 'line 15, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'Routes from or to a router that is not part of a network cannot exist.'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-rrtDirect \\/ routerNW;(I \\/ -I);routerNW~)
              // <=> { De Morgan }
              //     rrtDirect/\\-(routerNW;(I \\/ -I);routerNW~)
              // <=> { distribute \\/ over ; }
              //     rrtDirect/\\-(routerNW;(routerNW~ \\/ -I;routerNW~))
              // <=> { distr \\/ over ; }
              //     rrtDirect/\\-(routerNW;routerNW~ \\/ routerNW;-I;routerNW~)
              // <=> { De Morgan }
              //     rrtDirect/\\-(routerNW;routerNW~)/\\-(routerNW;-I;routerNW~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrtDirect\",\"-(routerNW;routerNW~)\",\"-(routerNW;-I;routerNW~)\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `rrtDirect` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNW\",\"routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                           ) AS cp
                                      WHERE isect0.`sRouter`=cp.`Router` AND isect0.`tRouter`=cp.`Router1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNW\",\"-I\",\"routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl [ \"I\" ] */
                                                    SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                                    FROM `Network` AS cfst,
                                                         `Network` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM `Network` AS cp
                                                      WHERE cfst.`Network`=cp.`Network` AND csnd.`Network`=cp.`Network`)
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`routerNW`=ECps1.`Network`
                                               AND ECps1.`Network1`=ECps2.`routerNW`
                                           ) AS cp
                                      WHERE isect0.`sRouter`=cp.`Router` AND isect0.`tRouter`=cp.`Router1`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerRoutesTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Remove computers from non-network routers' =>
        array ( 'name' => 'Remove computers from non-network routers'
              , 'ruleAdl' => 'compRouter |- compRouter;(I/\\routerNW;routerNW~)'
              , 'origin' => 'line 21, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'Computers may not be connected to routers that are not part of a network.'
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-compRouter \\/ compRouter;(I/\\routerNW;routerNW~))
              // <=> { De Morgan }
              //     compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRouter\",\"-(compRouter;(I/\\\\routerNW;routerNW~))\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Router` AS tgt
                          FROM `compRouter` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Router1` AS `Router`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"I\",\"routerNW;routerNW~\"] */
                                                    SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"routerNW\",\"routerNW~\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                           FROM `Router` AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router`, `routerNW`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                         ) AS isect0, `Router` AS isect1
                                                    WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Router`=cp.`Router`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsnwAllCompCommReqsSatisfied' =>
        array ( 'name' => 'InsnwAllCompCommReqsSatisfied'
              , 'ruleAdl' => 'I[Network]/\\-routerNW~!(routerAllCommReqsSatisfied;routerNW) |- nwAllCompCommReqsSatisfied'
              , 'origin' => 'line 29, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(I[Network]/\\-routerNW~!(routerAllCommReqsSatisfied;routerNW)) \\/ nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network]/\\-routerNW~!(routerAllCommReqsSatisfied;routerNW)/\\-nwAllCompCommReqsSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Network]\",\"-routerNW~!(routerAllCommReqsSatisfied;routerNW)\",\"-nwAllCompCommReqsSatisfied\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Network`, `Network` AS `Network1`
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-routerNW~\",\"routerAllCommReqsSatisfied;routerNW\"] */
                                 /* case: ECpl e
                                    ECpl [ \"--routerNW~;-(routerAllCommReqsSatisfied;routerNW)\" ] */
                                 SELECT DISTINCT cfst.`Network` AS `routerNW`, csnd.`Network` AS `routerNW1`
                                 FROM `Network` AS cfst,
                                      `Network` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"--routerNW~\",\"-(routerAllCommReqsSatisfied;routerNW)\"] */
                                          
                                          SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"-routerNW~\" ] */
                                                 SELECT DISTINCT cfst.`Network` AS `routerNW`, csnd.`Router`
                                                 FROM `Network` AS cfst,
                                                      `Router` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          /* case: ECpl e
                                                             ECpl [ \"routerNW\" ] */
                                                          SELECT DISTINCT cfst.`Router`, csnd.`Network` AS `routerNW`
                                                          FROM `Router` AS cfst,
                                                               `Network` AS csnd
                                                          WHERE NOT EXISTS
                                                           (SELECT * FROM `Router` AS cp
                                                            WHERE cfst.`Router`=cp.`Router` AND csnd.`Network`=cp.`routerNW`)
                                                        ) AS cp
                                                   WHERE cfst.`Network`=cp.`routerNW` AND csnd.`Router`=cp.`Router`)
                                               ) AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"routerAllCommReqsSatisfied;routerNW\" ] */
                                                 SELECT DISTINCT cfst.`Router`, csnd.`Network` AS `routerNW`
                                                 FROM `Router` AS cfst,
                                                      `Network` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"routerAllCommReqsSatisfied\",\"routerNW\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`Router`, ECps1.`routerNW`
                                                          FROM `Router` AS ECps0,
                                                               `Router` AS ECps1
                                                          WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.`Router`
                                                        ) AS cp
                                                   WHERE cfst.`Router`=cp.`Router` AND csnd.`Network`=cp.`routerNW`)
                                               ) AS ECps1
                                          WHERE ECps0.`Router`=ECps1.`Router`
                                        ) AS cp
                                   WHERE cfst.`Network`=cp.`routerNW` AND csnd.`Network`=cp.`routerNW1`)
                               ) AS isect1
                          WHERE (isect0.`Network` = isect1.`routerNW` AND isect0.`Network1` = isect1.`routerNW1`) AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`nwAllCompCommReqsSatisfied`) AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwAllCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'DelnwAllCompCommReqsSatisfied' =>
        array ( 'name' => 'DelnwAllCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwAllCompCommReqsSatisfied |- I[Network]/\\-routerNW~!(routerAllCommReqsSatisfied;routerNW)'
              , 'origin' => 'line 32, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-nwAllCompCommReqsSatisfied \\/ (I[Network]/\\-routerNW~!(routerAllCommReqsSatisfied;routerNW)))
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied/\\-(I[Network]/\\-routerNW~!(routerAllCommReqsSatisfied;routerNW))
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied/\\(-I[Network] \\/ -(-routerNW~!(routerAllCommReqsSatisfied;routerNW)))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwAllCompCommReqsSatisfied\",\"-I[Network] \\\\/ -(-routerNW~!(routerAllCommReqsSatisfied;routerNW))\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwAllCompCommReqsSatisfied` AS tgt
                          FROM `Network` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[Network]\",\"-(-routerNW~!(routerAllCommReqsSatisfied;routerNW))\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[Network]\" ] */
                                     SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                     FROM `Network` AS cfst,
                                          `Network` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `Network`, `Network` AS `Network1`
                                              FROM `Network`
                                              WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`Network`=cp.`Network` AND csnd.`Network`=cp.`Network1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"-routerNW~!(routerAllCommReqsSatisfied;routerNW)\" ] */
                                     SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                     FROM `Network` AS cfst,
                                          `Network` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ERad es@(_:_:_)
                                                 ERad [\"-routerNW~\",\"routerAllCommReqsSatisfied;routerNW\"] */
                                              /* case: ECpl e
                                                 ECpl [ \"--routerNW~;-(routerAllCommReqsSatisfied;routerNW)\" ] */
                                              SELECT DISTINCT cfst.`Network` AS `routerNW`, csnd.`Network` AS `routerNW1`
                                              FROM `Network` AS cfst,
                                                   `Network` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"--routerNW~\",\"-(routerAllCommReqsSatisfied;routerNW)\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                                       FROM 
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"-routerNW~\" ] */
                                                              SELECT DISTINCT cfst.`Network` AS `routerNW`, csnd.`Router`
                                                              FROM `Network` AS cfst,
                                                                   `Router` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: EFlp x. */
                                                                       /* case: ECpl e
                                                                          ECpl [ \"routerNW\" ] */
                                                                       SELECT DISTINCT cfst.`Router`, csnd.`Network` AS `routerNW`
                                                                       FROM `Router` AS cfst,
                                                                            `Network` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM `Router` AS cp
                                                                         WHERE cfst.`Router`=cp.`Router` AND csnd.`Network`=cp.`routerNW`)
                                                                     ) AS cp
                                                                WHERE cfst.`Network`=cp.`routerNW` AND csnd.`Router`=cp.`Router`)
                                                            ) AS ECps0,
                                                            
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"routerAllCommReqsSatisfied;routerNW\" ] */
                                                              SELECT DISTINCT cfst.`Router`, csnd.`Network` AS `routerNW`
                                                              FROM `Router` AS cfst,
                                                                   `Network` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                          ECps [\"routerAllCommReqsSatisfied\",\"routerNW\"] */
                                                                       
                                                                       SELECT DISTINCT ECps0.`Router`, ECps1.`routerNW`
                                                                       FROM `Router` AS ECps0,
                                                                            `Router` AS ECps1
                                                                       WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.`Router`
                                                                     ) AS cp
                                                                WHERE cfst.`Router`=cp.`Router` AND csnd.`Network`=cp.`routerNW`)
                                                            ) AS ECps1
                                                       WHERE ECps0.`Router`=ECps1.`Router`
                                                     ) AS cp
                                                WHERE cfst.`Network`=cp.`routerNW` AND csnd.`Network`=cp.`routerNW1`)
                                            ) AS cp
                                       WHERE cfst.`Network`=cp.`routerNW` AND csnd.`Network`=cp.`routerNW1`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Network` = isect1.`Network` AND isect0.`nwAllCompCommReqsSatisfied` = isect1.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`nwAllCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;nwAllCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'InsnwNoCompCommReqsSatisfied' =>
        array ( 'name' => 'InsnwNoCompCommReqsSatisfied'
              , 'ruleAdl' => 'I[Network]/\\-(routerNW~;-routerNoCommReqsSatisfied;routerNW) |- nwNoCompCommReqsSatisfied'
              , 'origin' => 'line 37, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(I[Network]/\\-(routerNW~;-routerNoCommReqsSatisfied;routerNW)) \\/ nwNoCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network]/\\-(routerNW~;-routerNoCommReqsSatisfied;routerNW)/\\-nwNoCompCommReqsSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Network]\",\"-(routerNW~;-routerNoCommReqsSatisfied;routerNW)\",\"-nwNoCompCommReqsSatisfied\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Network`, `Network` AS `Network1`
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNW~\",\"-routerNoCommReqsSatisfied\",\"routerNW\"] */
                                             
                                             SELECT DISTINCT ECps0.`routerNW`, ECps2.`routerNW` AS `routerNW1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: ECpl e
                                                       ECpl [ \"routerNoCommReqsSatisfied\" ] */
                                                    SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `routerNoCommReqsSatisfied`
                                                    FROM `Router` AS cfst,
                                                         `Router` AS csnd
                                                    WHERE NOT EXISTS
                                                     (SELECT * FROM `Router` AS cp
                                                      WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`routerNoCommReqsSatisfied`)
                                                  ) AS ECps1,
                                                  `Router` AS ECps2
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                               AND ECps1.`routerNoCommReqsSatisfied`=ECps2.`Router`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`routerNW` AND isect0.`Network1`=cp.`routerNW1`) AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`nwNoCompCommReqsSatisfied`) AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwNoCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'DelnwNoCompCommReqsSatisfied' =>
        array ( 'name' => 'DelnwNoCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwNoCompCommReqsSatisfied |- I[Network]/\\-(routerNW~;-routerNoCommReqsSatisfied;routerNW)'
              , 'origin' => 'line 40, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-nwNoCompCommReqsSatisfied \\/ (I[Network]/\\-(routerNW~;-routerNoCommReqsSatisfied;routerNW)))
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied/\\-(I[Network]/\\-(routerNW~;-routerNoCommReqsSatisfied;routerNW))
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied/\\(-I[Network] \\/ routerNW~;-routerNoCommReqsSatisfied;routerNW)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwNoCompCommReqsSatisfied\",\"-I[Network] \\\\/ routerNW~;-routerNoCommReqsSatisfied;routerNW\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwNoCompCommReqsSatisfied` AS tgt
                          FROM `Network` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[Network]\",\"routerNW~;-routerNoCommReqsSatisfied;routerNW\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[Network]\" ] */
                                     SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                     FROM `Network` AS cfst,
                                          `Network` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `Network`, `Network` AS `Network1`
                                              FROM `Network`
                                              WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`Network`=cp.`Network` AND csnd.`Network`=cp.`Network1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"routerNW~\",\"-routerNoCommReqsSatisfied\",\"routerNW\"] */
                                     
                                     SELECT DISTINCT ECps0.`routerNW` AS `Network`, ECps2.`routerNW` AS `Network1`
                                     FROM 
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Router`, `routerNW`
                                            FROM `Router`
                                            WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                          ) AS ECps0,
                                          
                                          ( /* case: ECpl e
                                               ECpl [ \"routerNoCommReqsSatisfied\" ] */
                                            SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `routerNoCommReqsSatisfied`
                                            FROM `Router` AS cfst,
                                                 `Router` AS csnd
                                            WHERE NOT EXISTS
                                             (SELECT * FROM `Router` AS cp
                                              WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`routerNoCommReqsSatisfied`)
                                          ) AS ECps1,
                                          `Router` AS ECps2
                                     WHERE ECps0.`Router`=ECps1.`Router`
                                       AND ECps1.`routerNoCommReqsSatisfied`=ECps2.`Router`
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Network` = isect1.`Network` AND isect0.`nwNoCompCommReqsSatisfied` = isect1.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`nwNoCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;nwNoCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'rrtCompTransitiveClosure' =>
        array ( 'name' => 'rrtCompTransitiveClosure'
              , 'ruleAdl' => 'routerRoutesTo = rrtDirect'
              , 'origin' => 'line 50, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -((-routerRoutesTo \\/ rrtDirect)/\\(-rrtDirect \\/ routerRoutesTo))
              // <=> { De Morgan }
              //     -(-routerRoutesTo \\/ rrtDirect) \\/ -(-rrtDirect \\/ routerRoutesTo)
              // <=> { De Morgan and De Morgan }
              //     (routerRoutesTo/\\-rrtDirect) \\/ (rrtDirect/\\-routerRoutesTo)
              // <=> { Distribute:    (x/\\y)\\/z  <=>  x\\/z /\\ y\\/z }
              //     (routerRoutesTo \\/ rrtDirect)/\\(routerRoutesTo \\/ -routerRoutesTo)/\\(-rrtDirect \\/ rrtDirect)/\\(-rrtDirect \\/ -routerRoutesTo)
              // <=> { let routerRoutesTo = e. Since -e\\/e = V we get and let rrtDirect = e. Since -e\\/e = V we get }
              //     (routerRoutesTo \\/ rrtDirect)/\\(-rrtDirect \\/ -routerRoutesTo)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerRoutesTo \\\\/ rrtDirect\",\"-rrtDirect \\\\/ -routerRoutesTo\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"routerRoutesTo\",\"rrtDirect\"] */
                                 (SELECT DISTINCT `sRouter`, `tRouter`
                                     FROM `routerRoutesTo`
                                     WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                 ) UNION (SELECT DISTINCT `sRouter`, `tRouter`
                                     FROM `rrtDirect`
                                     WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                 
                                 )
                               ) AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-rrtDirect\",\"-routerRoutesTo\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"rrtDirect\" ] */
                                     SELECT DISTINCT cfst.`Router` AS `sRouter`, csnd.`Router` AS `tRouter`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `rrtDirect` AS cp
                                       WHERE cfst.`Router`=cp.`sRouter` AND csnd.`Router`=cp.`tRouter`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"routerRoutesTo\" ] */
                                     SELECT DISTINCT cfst.`Router` AS `sRouter`, csnd.`Router` AS `tRouter`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `routerRoutesTo` AS cp
                                       WHERE cfst.`Router`=cp.`sRouter` AND csnd.`Router`=cp.`tRouter`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`sRouter` = isect1.`sRouter` AND isect0.`tRouter` = isect1.`tRouter`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} TransitiveClosure;routerRoutesTo;Router;rrtDirect;rrtStar')
                    )
              )
    , 'rrtStar Transitive closure integrity' =>
        array ( 'name' => 'rrtStar Transitive closure integrity'
              , 'ruleAdl' => 'rrtStar;rrtStar |- rrtStar'
              , 'origin' => 'line 55, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'Violation of this rule means that the demo is becoming more complex than was expected, and therefore may produce signals that are not correct. Please read the documentation (in the source code)'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(rrtStar;rrtStar) \\/ rrtStar)
              // <=> { De Morgan }
              //     rrtStar;rrtStar/\\-rrtStar
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrtStar;rrtStar\",\"-rrtStar\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrtStar\",\"rrtStar\"] */
                                 
                                 SELECT DISTINCT ECps0.`sRouter`, ECps1.`tRouter`
                                 FROM `rrtStar` AS ECps0,
                                      `rrtStar` AS ECps1
                                 WHERE ECps0.`tRouter`=ECps1.`sRouter`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `rrtStar` AS cp
                                      WHERE isect0.`sRouter`=cp.`sRouter` AND isect0.`tRouter`=cp.`tRouter`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'InsrouterNeedsPathTo' =>
        array ( 'name' => 'InsrouterNeedsPathTo'
              , 'ruleAdl' => 'compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter/\\-I |- routerNeedsPathTo'
              , 'origin' => 'line 61, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'A router needs a path to another router if both routers are connected to computers that need to communicate but do not have a communications path to do this.'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter/\\-I) \\/ routerNeedsPathTo)
              // <=> { De Morgan }
              //     compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter/\\-I/\\-routerNeedsPathTo
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRouter~;(compReqCommWith/\\\\-(compRouter;rrtStar;compRouter~));compRouter\",\"-I\",\"-routerNeedsPathTo\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter~\",\"compReqCommWith/\\\\-(compRouter;rrtStar;compRouter~)\",\"compRouter\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst@(_:_:_))
                                           EIsc [\"compReqCommWith\",\"-(compRouter;rrtStar;compRouter~)\"] */
                                        SELECT DISTINCT isect0.`sComputer`, isect0.`tComputer`
                                        FROM `compReqCommWith` AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                                           FROM `compRouter` AS ECps0,
                                                                `rrtStar` AS ECps1,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Computer`, `Router`
                                                                  FROM `compRouter`
                                                                  WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                ) AS ECps2
                                                           WHERE ECps0.`Router`=ECps1.`sRouter`
                                                             AND ECps1.`tRouter`=ECps2.`Router`
                                                         ) AS cp
                                                    WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`tComputer`=cp.`Computer1`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL
                                      ) AS ECps1,
                                      `compRouter` AS ECps2
                                 WHERE ECps0.`Computer`=ECps1.`sComputer`
                                   AND ECps1.`tComputer`=ECps2.`Computer`
                               ) AS isect0
                          WHERE isect0.`Router` <> isect0.`Router1` AND NOT EXISTS (SELECT * FROM `routerNeedsPathTo` AS cp
                                      WHERE isect0.`Router`=cp.`sRouter` AND isect0.`Router1`=cp.`tRouter`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerNeedsPathTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterNeedsPathTo' =>
        array ( 'name' => 'DelrouterNeedsPathTo'
              , 'ruleAdl' => 'routerNeedsPathTo |- compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter/\\-I'
              , 'origin' => 'line 65, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-routerNeedsPathTo \\/ (compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter/\\-I))
              // <=> { De Morgan }
              //     routerNeedsPathTo/\\-(compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter/\\-I)
              // <=> { De Morgan }
              //     routerNeedsPathTo/\\(-(compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter) \\/ I)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNeedsPathTo\",\"-(compRouter~;(compReqCommWith/\\\\-(compRouter;rrtStar;compRouter~));compRouter) \\\\/ I\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `routerNeedsPathTo` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-(compRouter~;(compReqCommWith/\\\\-(compRouter;rrtStar;compRouter~));compRouter)\",\"I\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"compRouter~;(compReqCommWith/\\-(compRouter;rrtStar;compRouter~));compRouter\" ] */
                                     SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `Router1`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"compRouter~\",\"compReqCommWith/\\\\-(compRouter;rrtStar;compRouter~)\",\"compRouter\"] */
                                              
                                              SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                              FROM 
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Computer`, `Router`
                                                     FROM `compRouter`
                                                     WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                   ) AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst@(_:_:_))
                                                        EIsc [\"compReqCommWith\",\"-(compRouter;rrtStar;compRouter~)\"] */
                                                     SELECT DISTINCT isect0.`sComputer`, isect0.`tComputer`
                                                     FROM `compReqCommWith` AS isect0
                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                      ( /* case: (ECps es), with two or more elements in es.
                                                                           ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                                                        
                                                                        SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                                                        FROM `compRouter` AS ECps0,
                                                                             `rrtStar` AS ECps1,
                                                                             
                                                                             ( /* case: EFlp x. */
                                                                               SELECT DISTINCT `Computer`, `Router`
                                                                               FROM `compRouter`
                                                                               WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                             ) AS ECps2
                                                                        WHERE ECps0.`Router`=ECps1.`sRouter`
                                                                          AND ECps1.`tRouter`=ECps2.`Router`
                                                                      ) AS cp
                                                                 WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`tComputer`=cp.`Computer1`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL
                                                   ) AS ECps1,
                                                   `compRouter` AS ECps2
                                              WHERE ECps0.`Computer`=ECps1.`sComputer`
                                                AND ECps1.`tComputer`=ECps2.`Computer`
                                            ) AS cp
                                       WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`Router1`)
                                 ) UNION (SELECT DISTINCT `Router`, `Router` AS `Router1`
                                     FROM `Router`
                                     WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`sRouter` = isect1.`Router` AND isect0.`tRouter` = isect1.`Router1`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerNeedsPathTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsrouterAllCommReqsSatisfied' =>
        array ( 'name' => 'InsrouterAllCommReqsSatisfied'
              , 'ruleAdl' => 'I[Router]/\\-(routerNeedsPathTo;routerNeedsPathTo~) |- routerAllCommReqsSatisfied'
              , 'origin' => 'line 70, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\-(routerNeedsPathTo;routerNeedsPathTo~)) \\/ routerAllCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Router]/\\-(routerNeedsPathTo;routerNeedsPathTo~)/\\-routerAllCommReqsSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"-(routerNeedsPathTo;routerNeedsPathTo~)\",\"-routerAllCommReqsSatisfied\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNeedsPathTo\",\"routerNeedsPathTo~\"] */
                                             
                                             SELECT DISTINCT ECps0.`sRouter`, ECps1.`sRouter` AS `sRouter1`
                                             FROM `routerNeedsPathTo` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `sRouter`, `tRouter`
                                                    FROM `routerNeedsPathTo`
                                                    WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`tRouter`=ECps1.`tRouter`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`sRouter` AND isect0.`Router1`=cp.`sRouter1`) AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`routerAllCommReqsSatisfied`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerAllCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterAllCommReqsSatisfied' =>
        array ( 'name' => 'DelrouterAllCommReqsSatisfied'
              , 'ruleAdl' => 'routerAllCommReqsSatisfied |- I[Router]/\\-(routerNeedsPathTo;routerNeedsPathTo~)'
              , 'origin' => 'line 73, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-routerAllCommReqsSatisfied \\/ (I[Router]/\\-(routerNeedsPathTo;routerNeedsPathTo~)))
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied/\\-(I[Router]/\\-(routerNeedsPathTo;routerNeedsPathTo~))
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied/\\(-I[Router] \\/ routerNeedsPathTo;routerNeedsPathTo~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerAllCommReqsSatisfied\",\"-I[Router] \\\\/ routerNeedsPathTo;routerNeedsPathTo~\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerAllCommReqsSatisfied` AS tgt
                          FROM `Router` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[Router]\",\"routerNeedsPathTo;routerNeedsPathTo~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[Router]\" ] */
                                     SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `Router1`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `Router`, `Router` AS `Router1`
                                              FROM `Router`
                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`Router1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"routerNeedsPathTo\",\"routerNeedsPathTo~\"] */
                                     
                                     SELECT DISTINCT ECps0.`sRouter` AS `Router`, ECps1.`sRouter` AS `Router1`
                                     FROM `routerNeedsPathTo` AS ECps0,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `sRouter`, `tRouter`
                                            FROM `routerNeedsPathTo`
                                            WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                          ) AS ECps1
                                     WHERE ECps0.`tRouter`=ECps1.`tRouter`
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`routerAllCommReqsSatisfied` = isect1.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerAllCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsrouterNoCommReqsSatisfied' =>
        array ( 'name' => 'InsrouterNoCommReqsSatisfied'
              , 'ruleAdl' => 'I[Router]/\\compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter |- routerNoCommReqsSatisfied'
              , 'origin' => 'line 78, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter) \\/ routerNoCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Router]/\\compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter/\\-routerNoCommReqsSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"compRouter~;(I[Computer]/\\\\compReqCommWith/\\\\-compHasCommWith);compRouter\",\"-routerNoCommReqsSatisfied\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter~\",\"I[Computer]/\\\\compReqCommWith/\\\\-compHasCommWith\",\"compRouter\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst@(_:_:_))
                                           EIsc [\"I[Computer]\",\"compReqCommWith\",\"-compHasCommWith\"] */
                                        SELECT DISTINCT isect0.`Computer`, isect0.`Computer1`
                                        FROM 
                                             ( /* case: ETyp x _
                                                  ETyp ( \"I\" ) _ */
                                               SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                               FROM `Computer`
                                               WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                                             ) AS isect0, `compReqCommWith` AS isect1
                                        WHERE (isect0.`Computer` = isect1.`sComputer` AND isect0.`Computer1` = isect1.`tComputer`) AND NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                    WHERE isect0.`Computer`=cp.`sComputer` AND isect0.`Computer1`=cp.`tComputer`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL
                                      ) AS ECps1,
                                      `compRouter` AS ECps2
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                                   AND ECps1.`Computer1`=ECps2.`Computer`
                               ) AS isect1
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`Router1` = isect1.`Router1`) AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`routerNoCommReqsSatisfied`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerNoCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterNoCommReqsSatisfied' =>
        array ( 'name' => 'DelrouterNoCommReqsSatisfied'
              , 'ruleAdl' => 'routerNoCommReqsSatisfied |- I[Router]/\\compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter'
              , 'origin' => 'line 81, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-routerNoCommReqsSatisfied \\/ (I[Router]/\\compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter))
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied/\\-(I[Router]/\\compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied/\\(-I[Router] \\/ -(compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNoCommReqsSatisfied\",\"-I[Router] \\\\/ -(compRouter~;(I[Computer]/\\\\compReqCommWith/\\\\-compHasCommWith);compRouter)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerNoCommReqsSatisfied` AS tgt
                          FROM `Router` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[Router]\",\"-(compRouter~;(I[Computer]/\\\\compReqCommWith/\\\\-compHasCommWith);compRouter)\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[Router]\" ] */
                                     SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `Router1`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `Router`, `Router` AS `Router1`
                                              FROM `Router`
                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`Router1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"compRouter~;(I[Computer]/\\compReqCommWith/\\-compHasCommWith);compRouter\" ] */
                                     SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `Router1`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"compRouter~\",\"I[Computer]/\\\\compReqCommWith/\\\\-compHasCommWith\",\"compRouter\"] */
                                              
                                              SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                              FROM 
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Computer`, `Router`
                                                     FROM `compRouter`
                                                     WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                   ) AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst@(_:_:_))
                                                        EIsc [\"I[Computer]\",\"compReqCommWith\",\"-compHasCommWith\"] */
                                                     SELECT DISTINCT isect0.`Computer`, isect0.`Computer1`
                                                     FROM 
                                                          ( /* case: ETyp x _
                                                               ETyp ( \"I\" ) _ */
                                                            SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                                            FROM `Computer`
                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                                                          ) AS isect0, `compReqCommWith` AS isect1
                                                     WHERE (isect0.`Computer` = isect1.`sComputer` AND isect0.`Computer1` = isect1.`tComputer`) AND NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                                 WHERE isect0.`Computer`=cp.`sComputer` AND isect0.`Computer1`=cp.`tComputer`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL
                                                   ) AS ECps1,
                                                   `compRouter` AS ECps2
                                              WHERE ECps0.`Computer`=ECps1.`Computer`
                                                AND ECps1.`Computer1`=ECps2.`Computer`
                                            ) AS cp
                                       WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`Router1`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`routerNoCommReqsSatisfied` = isect1.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`routerNoCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerNoCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InscompReqCommWith' =>
        array ( 'name' => 'InscompReqCommWith'
              , 'ruleAdl' => 'scDeployedOn~;scReqCommWith;scDeployedOn |- compReqCommWith'
              , 'origin' => 'line 88, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(scDeployedOn~;scReqCommWith;scDeployedOn) \\/ compReqCommWith)
              // <=> { De Morgan }
              //     scDeployedOn~;scReqCommWith;scDeployedOn/\\-compReqCommWith
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scDeployedOn~;scReqCommWith;scDeployedOn\",\"-compReqCommWith\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scDeployedOn~\",\"scReqCommWith\",\"scDeployedOn\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps0,
                                      `scReqCommWith` AS ECps1,
                                      `scDeployedOn` AS ECps2
                                 WHERE ECps0.`SvcComponent`=ECps1.`sSvcComponent`
                                   AND ECps1.`tSvcComponent`=ECps2.`SvcComponent`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `compReqCommWith` AS cp
                                      WHERE isect0.`Computer`=cp.`sComputer` AND isect0.`Computer1`=cp.`tComputer`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompReqCommWith' =>
        array ( 'name' => 'DelcompReqCommWith'
              , 'ruleAdl' => 'compReqCommWith |- scDeployedOn~;scReqCommWith;scDeployedOn'
              , 'origin' => 'line 91, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-compReqCommWith \\/ scDeployedOn~;scReqCommWith;scDeployedOn)
              // <=> { De Morgan }
              //     compReqCommWith/\\-(scDeployedOn~;scReqCommWith;scDeployedOn)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compReqCommWith\",\"-(scDeployedOn~;scReqCommWith;scDeployedOn)\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                          FROM `compReqCommWith` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scDeployedOn~\",\"scReqCommWith\",\"scDeployedOn\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Computer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps0,
                                                  `scReqCommWith` AS ECps1,
                                                  `scDeployedOn` AS ECps2
                                             WHERE ECps0.`SvcComponent`=ECps1.`sSvcComponent`
                                               AND ECps1.`tSvcComponent`=ECps2.`SvcComponent`
                                           ) AS cp
                                      WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`tComputer`=cp.`Computer1`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompHasCommWith' =>
        array ( 'name' => 'InscompHasCommWith'
              , 'ruleAdl' => 'compReqCommWith/\\compRouter;rrtStar;compRouter~/\\-I |- compHasCommWith'
              , 'origin' => 'line 96, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compReqCommWith/\\compRouter;rrtStar;compRouter~/\\-I) \\/ compHasCommWith)
              // <=> { De Morgan }
              //     compReqCommWith/\\compRouter;rrtStar;compRouter~/\\-I/\\-compHasCommWith
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compReqCommWith\",\"compRouter;rrtStar;compRouter~\",\"-I\",\"-compHasCommWith\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                          FROM `compReqCommWith` AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                 FROM `compRouter` AS ECps0,
                                      `rrtStar` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`Router`=ECps1.`sRouter`
                                   AND ECps1.`tRouter`=ECps2.`Router`
                               ) AS isect1
                          WHERE (isect0.`sComputer` = isect1.`Computer` AND isect0.`tComputer` = isect1.`Computer1`) AND isect0.`sComputer` <> isect0.`tComputer` AND NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                      WHERE isect0.`sComputer`=cp.`sComputer` AND isect0.`tComputer`=cp.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compHasCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompHasCommWith' =>
        array ( 'name' => 'DelcompHasCommWith'
              , 'ruleAdl' => 'compHasCommWith |- compReqCommWith/\\compRouter;rrtStar;compRouter~/\\-I'
              , 'origin' => 'line 99, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-compHasCommWith \\/ (compReqCommWith/\\compRouter;rrtStar;compRouter~/\\-I))
              // <=> { De Morgan }
              //     compHasCommWith/\\-(compReqCommWith/\\compRouter;rrtStar;compRouter~/\\-I)
              // <=> { De Morgan }
              //     compHasCommWith/\\(-compReqCommWith \\/ -(compRouter;rrtStar;compRouter~) \\/ I)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compHasCommWith\",\"-compReqCommWith \\\\/ -(compRouter;rrtStar;compRouter~) \\\\/ I\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                          FROM `compHasCommWith` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-compReqCommWith\",\"-(compRouter;rrtStar;compRouter~)\",\"I\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"compReqCommWith\" ] */
                                     SELECT DISTINCT cfst.`Computer` AS `sComputer`, csnd.`Computer` AS `tComputer`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `compReqCommWith` AS cp
                                       WHERE cfst.`Computer`=cp.`sComputer` AND csnd.`Computer`=cp.`tComputer`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"compRouter;rrtStar;compRouter~\" ] */
                                     SELECT DISTINCT cfst.`Computer` AS `sComputer`, csnd.`Computer` AS `tComputer`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                              
                                              SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                              FROM `compRouter` AS ECps0,
                                                   `rrtStar` AS ECps1,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `Computer`, `Router`
                                                     FROM `compRouter`
                                                     WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                   ) AS ECps2
                                              WHERE ECps0.`Router`=ECps1.`sRouter`
                                                AND ECps1.`tRouter`=ECps2.`Router`
                                            ) AS cp
                                       WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer1`)
                                 ) UNION (SELECT DISTINCT `Computer` AS `sComputer`, `Computer` AS `tComputer`
                                     FROM `Computer`
                                     WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`sComputer` = isect1.`sComputer` AND isect0.`tComputer` = isect1.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compHasCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompRequiresComm' =>
        array ( 'name' => 'InscompRequiresComm'
              , 'ruleAdl' => 'I/\\compReqCommWith;compReqCommWith~ |- compRequiresComm'
              , 'origin' => 'line 104, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I/\\compReqCommWith;compReqCommWith~) \\/ compRequiresComm)
              // <=> { De Morgan }
              //     I/\\compReqCommWith;compReqCommWith~/\\-compRequiresComm
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"compReqCommWith;compReqCommWith~\",\"-compRequiresComm\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`sComputer1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compReqCommWith\",\"compReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sComputer`, ECps1.`sComputer` AS `sComputer1`
                                 FROM `compReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sComputer`, `tComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tComputer`=ECps1.`tComputer`
                               ) AS isect0, `Computer` AS isect1
                          WHERE isect0.`sComputer` = isect0.`sComputer1` AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`sComputer1`=cp.`compRequiresComm`) AND isect0.`sComputer` IS NOT NULL AND isect0.`sComputer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compRequiresComm;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompRequiresComm' =>
        array ( 'name' => 'DelcompRequiresComm'
              , 'ruleAdl' => 'compRequiresComm |- I/\\compReqCommWith;compReqCommWith~'
              , 'origin' => 'line 107, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-compRequiresComm \\/ (I/\\compReqCommWith;compReqCommWith~))
              // <=> { De Morgan }
              //     compRequiresComm/\\-(I/\\compReqCommWith;compReqCommWith~)
              // <=> { De Morgan }
              //     compRequiresComm/\\(-I \\/ -(compReqCommWith;compReqCommWith~))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRequiresComm\",\"-I \\\\/ -(compReqCommWith;compReqCommWith~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compRequiresComm` AS tgt
                          FROM `Computer` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"-(compReqCommWith;compReqCommWith~)\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `Computer` AS cp
                                       WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"compReqCommWith;compReqCommWith~\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"compReqCommWith\",\"compReqCommWith~\"] */
                                              
                                              SELECT DISTINCT ECps0.`sComputer`, ECps1.`sComputer` AS `sComputer1`
                                              FROM `compReqCommWith` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `sComputer`, `tComputer`
                                                     FROM `compReqCommWith`
                                                     WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`tComputer`=ECps1.`tComputer`
                                            ) AS cp
                                       WHERE cfst.`Computer`=cp.`sComputer` AND csnd.`Computer`=cp.`sComputer1`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`compRequiresComm` = isect1.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`compRequiresComm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compRequiresComm;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompAllReqCommSatisfied' =>
        array ( 'name' => 'InscompAllReqCommSatisfied'
              , 'ruleAdl' => 'I/\\-compReqCommWith!(compRouter;rrtStar;compRouter~)~ |- compAllReqCommSatisfied'
              , 'origin' => 'line 112, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I/\\-compReqCommWith!(compRouter;rrtStar;compRouter~)~) \\/ compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     I/\\-compReqCommWith!(compRouter;rrtStar;compRouter~)~/\\-compAllReqCommSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-compReqCommWith!(compRouter;rrtStar;compRouter~)~\",\"-compAllReqCommSatisfied\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`Computer` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-compReqCommWith\",\"(compRouter;rrtStar;compRouter~)~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"compReqCommWith;-(compRouter;rrtStar;compRouter~)~\" ] */
                                 SELECT DISTINCT cfst.`Computer` AS `sComputer`, csnd.`Computer`
                                 FROM `Computer` AS cfst,
                                      `Computer` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"compReqCommWith\",\"-(compRouter;rrtStar;compRouter~)~\"] */
                                          
                                          SELECT DISTINCT ECps0.`sComputer`, ECps1.`Computer1` AS `Computer`
                                          FROM `compReqCommWith` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"(compRouter;rrtStar;compRouter~)~\" ] */
                                                 SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                                 FROM `Computer` AS cfst,
                                                      `Computer` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`Computer` AS `Computer1`, ECps2.`Computer`
                                                          FROM `compRouter` AS ECps0,
                                                               `rrtStar` AS ECps1,
                                                               
                                                               ( /* case: EFlp x. */
                                                                 SELECT DISTINCT `Computer`, `Router`
                                                                 FROM `compRouter`
                                                                 WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                               ) AS ECps2
                                                          WHERE ECps0.`Router`=ECps1.`sRouter`
                                                            AND ECps1.`tRouter`=ECps2.`Router`
                                                        ) AS cp
                                                   WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer1`)
                                               ) AS ECps1
                                          WHERE ECps0.`tComputer`=ECps1.`Computer`
                                        ) AS cp
                                   WHERE cfst.`Computer`=cp.`sComputer` AND csnd.`Computer`=cp.`Computer`)
                               ) AS isect0, `Computer` AS isect1
                          WHERE isect0.`sComputer` = isect0.`Computer` AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`Computer`=cp.`compAllReqCommSatisfied`) AND isect0.`sComputer` IS NOT NULL AND isect0.`Computer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compAllReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelCompAllReqCommSatisfied' =>
        array ( 'name' => 'DelCompAllReqCommSatisfied'
              , 'ruleAdl' => 'compAllReqCommSatisfied |- I/\\-compReqCommWith!(compRouter;rrtStar;compRouter~)~'
              , 'origin' => 'line 115, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-compAllReqCommSatisfied \\/ (I/\\-compReqCommWith!(compRouter;rrtStar;compRouter~)~))
              // <=> { De Morgan }
              //     compAllReqCommSatisfied/\\-(I/\\-compReqCommWith!(compRouter;rrtStar;compRouter~)~)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied/\\(-I \\/ -(-compReqCommWith!(compRouter;rrtStar;compRouter~)~))
              // <=> { De Morgan }
              //     compAllReqCommSatisfied/\\(-I \\/ compReqCommWith;-(compRouter;rrtStar;compRouter~)~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compAllReqCommSatisfied\",\"-I \\\\/ compReqCommWith;-(compRouter;rrtStar;compRouter~)~\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compAllReqCommSatisfied` AS tgt
                          FROM `Computer` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"compReqCommWith;-(compRouter;rrtStar;compRouter~)~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `Computer` AS cp
                                       WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"compReqCommWith\",\"-(compRouter;rrtStar;compRouter~)~\"] */
                                     
                                     SELECT DISTINCT ECps0.`sComputer` AS `Computer`, ECps1.`Computer1`
                                     FROM `compReqCommWith` AS ECps0,
                                          
                                          ( /* case: ECpl e
                                               ECpl [ \"(compRouter;rrtStar;compRouter~)~\" ] */
                                            SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                            FROM `Computer` AS cfst,
                                                 `Computer` AS csnd
                                            WHERE NOT EXISTS
                                             (SELECT * FROM 
                                                   ( /* case: EFlp x. */
                                                     /* case: (ECps es), with two or more elements in es.
                                                        ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                                     
                                                     SELECT DISTINCT ECps0.`Computer` AS `Computer1`, ECps2.`Computer`
                                                     FROM `compRouter` AS ECps0,
                                                          `rrtStar` AS ECps1,
                                                          
                                                          ( /* case: EFlp x. */
                                                            SELECT DISTINCT `Computer`, `Router`
                                                            FROM `compRouter`
                                                            WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                          ) AS ECps2
                                                     WHERE ECps0.`Router`=ECps1.`sRouter`
                                                       AND ECps1.`tRouter`=ECps2.`Router`
                                                   ) AS cp
                                              WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer1`)
                                          ) AS ECps1
                                     WHERE ECps0.`tComputer`=ECps1.`Computer`
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`compAllReqCommSatisfied` = isect1.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compAllReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompNoReqCommSatisfied' =>
        array ( 'name' => 'InscompNoReqCommSatisfied'
              , 'ruleAdl' => 'I/\\-(compReqCommWith;(compRouter;rrtStar;compRouter~)~) |- compNoReqCommSatisfied'
              , 'origin' => 'line 120, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I/\\-(compReqCommWith;(compRouter;rrtStar;compRouter~)~)) \\/ compNoReqCommSatisfied)
              // <=> { De Morgan }
              //     I/\\-(compReqCommWith;(compRouter;rrtStar;compRouter~)~)/\\-compNoReqCommSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(compReqCommWith;(compRouter;rrtStar;compRouter~)~)\",\"-compNoReqCommSatisfied\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer` AS tgt
                          FROM `Computer` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compReqCommWith\",\"(compRouter;rrtStar;compRouter~)~\"] */
                                             
                                             SELECT DISTINCT ECps0.`sComputer`, ECps1.`Computer1` AS `Computer`
                                             FROM `compReqCommWith` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: (ECps es), with two or more elements in es.
                                                       ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`Computer` AS `Computer1`, ECps2.`Computer`
                                                    FROM `compRouter` AS ECps0,
                                                         `rrtStar` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Computer`, `Router`
                                                           FROM `compRouter`
                                                           WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`Router`=ECps1.`sRouter`
                                                      AND ECps1.`tRouter`=ECps2.`Router`
                                                  ) AS ECps1
                                             WHERE ECps0.`tComputer`=ECps1.`Computer`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`sComputer` AND isect0.`Computer`=cp.`Computer`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer`=cp.`compNoReqCommSatisfied`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compNoReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelCompNoReqCommSatisfied' =>
        array ( 'name' => 'DelCompNoReqCommSatisfied'
              , 'ruleAdl' => 'compNoReqCommSatisfied |- I/\\-(compReqCommWith;(compRouter;rrtStar;compRouter~)~)'
              , 'origin' => 'line 123, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-compNoReqCommSatisfied \\/ (I/\\-(compReqCommWith;(compRouter;rrtStar;compRouter~)~)))
              // <=> { De Morgan }
              //     compNoReqCommSatisfied/\\-(I/\\-(compReqCommWith;(compRouter;rrtStar;compRouter~)~))
              // <=> { De Morgan }
              //     compNoReqCommSatisfied/\\(-I \\/ compReqCommWith;(compRouter;rrtStar;compRouter~)~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compNoReqCommSatisfied\",\"-I \\\\/ compReqCommWith;(compRouter;rrtStar;compRouter~)~\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compNoReqCommSatisfied` AS tgt
                          FROM `Computer` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"compReqCommWith;(compRouter;rrtStar;compRouter~)~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `Computer` AS cp
                                       WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"compReqCommWith\",\"(compRouter;rrtStar;compRouter~)~\"] */
                                     
                                     SELECT DISTINCT ECps0.`sComputer` AS `Computer`, ECps1.`Computer1`
                                     FROM `compReqCommWith` AS ECps0,
                                          
                                          ( /* case: EFlp x. */
                                            /* case: (ECps es), with two or more elements in es.
                                               ECps [\"compRouter\",\"rrtStar\",\"compRouter~\"] */
                                            
                                            SELECT DISTINCT ECps0.`Computer` AS `Computer1`, ECps2.`Computer`
                                            FROM `compRouter` AS ECps0,
                                                 `rrtStar` AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Computer`, `Router`
                                                   FROM `compRouter`
                                                   WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Router`=ECps1.`sRouter`
                                              AND ECps1.`tRouter`=ECps2.`Router`
                                          ) AS ECps1
                                     WHERE ECps0.`tComputer`=ECps1.`Computer`
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`compNoReqCommSatisfied` = isect1.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`compNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compNoReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InsscHasCommWith' =>
        array ( 'name' => 'InsscHasCommWith'
              , 'ruleAdl' => 'scReqCommWith/\\scDeployedOn;compHasCommWith;scDeployedOn~ |- scHasCommWith'
              , 'origin' => 'line 129, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scReqCommWith/\\scDeployedOn;compHasCommWith;scDeployedOn~) \\/ scHasCommWith)
              // <=> { De Morgan }
              //     scReqCommWith/\\scDeployedOn;compHasCommWith;scDeployedOn~/\\-scHasCommWith
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scReqCommWith\",\"scDeployedOn;compHasCommWith;scDeployedOn~\",\"-scHasCommWith\"] */
                          SELECT DISTINCT isect0.`sSvcComponent` AS src, isect0.`tSvcComponent` AS tgt
                          FROM `scReqCommWith` AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scDeployedOn\",\"compHasCommWith\",\"scDeployedOn~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                 FROM `scDeployedOn` AS ECps0,
                                      `compHasCommWith` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps2
                                 WHERE ECps0.`Computer`=ECps1.`sComputer`
                                   AND ECps1.`tComputer`=ECps2.`Computer`
                               ) AS isect1
                          WHERE (isect0.`sSvcComponent` = isect1.`SvcComponent` AND isect0.`tSvcComponent` = isect1.`SvcComponent1`) AND NOT EXISTS (SELECT * FROM `scHasCommWith` AS cp
                                      WHERE isect0.`sSvcComponent`=cp.`sSvcComponent` AND isect0.`tSvcComponent`=cp.`tSvcComponent`) AND isect0.`sSvcComponent` IS NOT NULL AND isect0.`tSvcComponent` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scHasCommWith;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'DelscHasCommWith' =>
        array ( 'name' => 'DelscHasCommWith'
              , 'ruleAdl' => 'scHasCommWith |- scReqCommWith/\\scDeployedOn;compHasCommWith;scDeployedOn~'
              , 'origin' => 'line 132, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-scHasCommWith \\/ (scReqCommWith/\\scDeployedOn;compHasCommWith;scDeployedOn~))
              // <=> { De Morgan }
              //     scHasCommWith/\\-(scReqCommWith/\\scDeployedOn;compHasCommWith;scDeployedOn~)
              // <=> { De Morgan }
              //     scHasCommWith/\\(-scReqCommWith \\/ -(scDeployedOn;compHasCommWith;scDeployedOn~))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scHasCommWith\",\"-scReqCommWith \\\\/ -(scDeployedOn;compHasCommWith;scDeployedOn~)\"] */
                          SELECT DISTINCT isect0.`sSvcComponent` AS src, isect0.`tSvcComponent` AS tgt
                          FROM `scHasCommWith` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-scReqCommWith\",\"-(scDeployedOn;compHasCommWith;scDeployedOn~)\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"scReqCommWith\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent` AS `sSvcComponent`, csnd.`SvcComponent` AS `tSvcComponent`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `scReqCommWith` AS cp
                                       WHERE cfst.`SvcComponent`=cp.`sSvcComponent` AND csnd.`SvcComponent`=cp.`tSvcComponent`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"scDeployedOn;compHasCommWith;scDeployedOn~\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent` AS `sSvcComponent`, csnd.`SvcComponent` AS `tSvcComponent`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"scDeployedOn\",\"compHasCommWith\",\"scDeployedOn~\"] */
                                              
                                              SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                              FROM `scDeployedOn` AS ECps0,
                                                   `compHasCommWith` AS ECps1,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `SvcComponent`, `Computer`
                                                     FROM `scDeployedOn`
                                                     WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                   ) AS ECps2
                                              WHERE ECps0.`Computer`=ECps1.`sComputer`
                                                AND ECps1.`tComputer`=ECps2.`Computer`
                                            ) AS cp
                                       WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent1`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`sSvcComponent` = isect1.`sSvcComponent` AND isect0.`tSvcComponent` = isect1.`tSvcComponent`) AND isect0.`sSvcComponent` IS NOT NULL AND isect0.`tSvcComponent` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;scHasCommWith;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'InsscAllReqCommSatisfied' =>
        array ( 'name' => 'InsscAllReqCommSatisfied'
              , 'ruleAdl' => 'I/\\scReqCommWith;scReqCommWith~/\\-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~ |- scAllReqCommSatisfied'
              , 'origin' => 'line 139, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I/\\scReqCommWith;scReqCommWith~/\\-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~) \\/ scAllReqCommSatisfied)
              // <=> { De Morgan }
              //     I/\\scReqCommWith;scReqCommWith~/\\-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~/\\-scAllReqCommSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"scReqCommWith;scReqCommWith~\",\"-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~\",\"-scAllReqCommSatisfied\"] */
                          SELECT DISTINCT isect0.`sSvcComponent` AS src, isect0.`sSvcComponent1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-scReqCommWith\",\"(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"scReqCommWith;-(scDeployedOn;compHasCommWith;scDeployedOn~)~\" ] */
                                 SELECT DISTINCT cfst.`SvcComponent` AS `sSvcComponent`, csnd.`SvcComponent`
                                 FROM `SvcComponent` AS cfst,
                                      `SvcComponent` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"scReqCommWith\",\"-(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                          
                                          SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`SvcComponent1` AS `SvcComponent`
                                          FROM `scReqCommWith` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"(scDeployedOn;compHasCommWith;scDeployedOn~)~\" ] */
                                                 SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                                 FROM `SvcComponent` AS cfst,
                                                      `SvcComponent` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"scDeployedOn\",\"compHasCommWith\",\"scDeployedOn~\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`SvcComponent` AS `SvcComponent1`, ECps2.`SvcComponent`
                                                          FROM `scDeployedOn` AS ECps0,
                                                               `compHasCommWith` AS ECps1,
                                                               
                                                               ( /* case: EFlp x. */
                                                                 SELECT DISTINCT `SvcComponent`, `Computer`
                                                                 FROM `scDeployedOn`
                                                                 WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                               ) AS ECps2
                                                          WHERE ECps0.`Computer`=ECps1.`sComputer`
                                                            AND ECps1.`tComputer`=ECps2.`Computer`
                                                        ) AS cp
                                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent1`)
                                               ) AS ECps1
                                          WHERE ECps0.`tSvcComponent`=ECps1.`SvcComponent`
                                        ) AS cp
                                   WHERE cfst.`SvcComponent`=cp.`sSvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                               ) AS isect1, `SvcComponent` AS isect2
                          WHERE (isect0.`sSvcComponent` = isect1.`sSvcComponent` AND isect0.`sSvcComponent1` = isect1.`SvcComponent`) AND isect0.`sSvcComponent` = isect0.`sSvcComponent1` AND NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                      WHERE isect0.`sSvcComponent`=cp.`SvcComponent` AND isect0.`sSvcComponent1`=cp.`scAllReqCommSatisfied`) AND isect0.`sSvcComponent` IS NOT NULL AND isect0.`sSvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scAllReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'DelscAllReqCommSatisfied' =>
        array ( 'name' => 'DelscAllReqCommSatisfied'
              , 'ruleAdl' => 'scAllReqCommSatisfied |- I/\\scReqCommWith;scReqCommWith~/\\-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~'
              , 'origin' => 'line 142, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-scAllReqCommSatisfied \\/ (I/\\scReqCommWith;scReqCommWith~/\\-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~))
              // <=> { De Morgan }
              //     scAllReqCommSatisfied/\\-(I/\\scReqCommWith;scReqCommWith~/\\-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied/\\(-I \\/ -(scReqCommWith;scReqCommWith~) \\/ -(-scReqCommWith!(scDeployedOn;compHasCommWith;scDeployedOn~)~))
              // <=> { De Morgan }
              //     scAllReqCommSatisfied/\\(-I \\/ -(scReqCommWith;scReqCommWith~) \\/ scReqCommWith;-(scDeployedOn;compHasCommWith;scDeployedOn~)~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scAllReqCommSatisfied\",\"-I \\\\/ -(scReqCommWith;scReqCommWith~) \\\\/ scReqCommWith;-(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scAllReqCommSatisfied` AS tgt
                          FROM `SvcComponent` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"-(scReqCommWith;scReqCommWith~)\",\"scReqCommWith;-(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `SvcComponent` AS cp
                                       WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"scReqCommWith;scReqCommWith~\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                              
                                              SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                              FROM `scReqCommWith` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                                     FROM `scReqCommWith`
                                                     WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                                            ) AS cp
                                       WHERE cfst.`SvcComponent`=cp.`sSvcComponent` AND csnd.`SvcComponent`=cp.`sSvcComponent1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"scReqCommWith\",\"-(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                     
                                     SELECT DISTINCT ECps0.`sSvcComponent` AS `SvcComponent`, ECps1.`SvcComponent1`
                                     FROM `scReqCommWith` AS ECps0,
                                          
                                          ( /* case: ECpl e
                                               ECpl [ \"(scDeployedOn;compHasCommWith;scDeployedOn~)~\" ] */
                                            SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                            FROM `SvcComponent` AS cfst,
                                                 `SvcComponent` AS csnd
                                            WHERE NOT EXISTS
                                             (SELECT * FROM 
                                                   ( /* case: EFlp x. */
                                                     /* case: (ECps es), with two or more elements in es.
                                                        ECps [\"scDeployedOn\",\"compHasCommWith\",\"scDeployedOn~\"] */
                                                     
                                                     SELECT DISTINCT ECps0.`SvcComponent` AS `SvcComponent1`, ECps2.`SvcComponent`
                                                     FROM `scDeployedOn` AS ECps0,
                                                          `compHasCommWith` AS ECps1,
                                                          
                                                          ( /* case: EFlp x. */
                                                            SELECT DISTINCT `SvcComponent`, `Computer`
                                                            FROM `scDeployedOn`
                                                            WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                          ) AS ECps2
                                                     WHERE ECps0.`Computer`=ECps1.`sComputer`
                                                       AND ECps1.`tComputer`=ECps2.`Computer`
                                                   ) AS cp
                                              WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent1`)
                                          ) AS ECps1
                                     WHERE ECps0.`tSvcComponent`=ECps1.`SvcComponent`
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`scAllReqCommSatisfied` = isect1.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;scAllReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'InsscNoReqCommSatisfied' =>
        array ( 'name' => 'InsscNoReqCommSatisfied'
              , 'ruleAdl' => 'I/\\scReqCommWith;scReqCommWith~/\\-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~) |- scNoReqCommSatisfied'
              , 'origin' => 'line 147, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I/\\scReqCommWith;scReqCommWith~/\\-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~)) \\/ scNoReqCommSatisfied)
              // <=> { De Morgan }
              //     I/\\scReqCommWith;scReqCommWith~/\\-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~)/\\-scNoReqCommSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"scReqCommWith;scReqCommWith~\",\"-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~)\",\"-scNoReqCommSatisfied\"] */
                          SELECT DISTINCT isect0.`sSvcComponent` AS src, isect0.`sSvcComponent1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect0, `SvcComponent` AS isect1
                          WHERE isect0.`sSvcComponent` = isect0.`sSvcComponent1` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scReqCommWith\",\"(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                             
                                             SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`SvcComponent1` AS `SvcComponent`
                                             FROM `scReqCommWith` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    /* case: (ECps es), with two or more elements in es.
                                                       ECps [\"scDeployedOn\",\"compHasCommWith\",\"scDeployedOn~\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`SvcComponent` AS `SvcComponent1`, ECps2.`SvcComponent`
                                                    FROM `scDeployedOn` AS ECps0,
                                                         `compHasCommWith` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `SvcComponent`, `Computer`
                                                           FROM `scDeployedOn`
                                                           WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`Computer`=ECps1.`sComputer`
                                                      AND ECps1.`tComputer`=ECps2.`Computer`
                                                  ) AS ECps1
                                             WHERE ECps0.`tSvcComponent`=ECps1.`SvcComponent`
                                           ) AS cp
                                      WHERE isect0.`sSvcComponent`=cp.`sSvcComponent` AND isect0.`sSvcComponent1`=cp.`SvcComponent`) AND NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                      WHERE isect0.`sSvcComponent`=cp.`SvcComponent` AND isect0.`sSvcComponent1`=cp.`scNoReqCommSatisfied`) AND isect0.`sSvcComponent` IS NOT NULL AND isect0.`sSvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scNoReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'DelscNoReqCommSatisfied' =>
        array ( 'name' => 'DelscNoReqCommSatisfied'
              , 'ruleAdl' => 'scNoReqCommSatisfied |- I/\\scReqCommWith;scReqCommWith~/\\-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~)'
              , 'origin' => 'line 150, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-scNoReqCommSatisfied \\/ (I/\\scReqCommWith;scReqCommWith~/\\-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~)))
              // <=> { De Morgan }
              //     scNoReqCommSatisfied/\\-(I/\\scReqCommWith;scReqCommWith~/\\-(scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~))
              // <=> { De Morgan }
              //     scNoReqCommSatisfied/\\(-I \\/ -(scReqCommWith;scReqCommWith~) \\/ scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scNoReqCommSatisfied\",\"-I \\\\/ -(scReqCommWith;scReqCommWith~) \\\\/ scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scNoReqCommSatisfied` AS tgt
                          FROM `SvcComponent` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"-(scReqCommWith;scReqCommWith~)\",\"scReqCommWith;(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `SvcComponent` AS cp
                                       WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"scReqCommWith;scReqCommWith~\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                              
                                              SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                              FROM `scReqCommWith` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                                     FROM `scReqCommWith`
                                                     WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                                            ) AS cp
                                       WHERE cfst.`SvcComponent`=cp.`sSvcComponent` AND csnd.`SvcComponent`=cp.`sSvcComponent1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"scReqCommWith\",\"(scDeployedOn;compHasCommWith;scDeployedOn~)~\"] */
                                     
                                     SELECT DISTINCT ECps0.`sSvcComponent` AS `SvcComponent`, ECps1.`SvcComponent1`
                                     FROM `scReqCommWith` AS ECps0,
                                          
                                          ( /* case: EFlp x. */
                                            /* case: (ECps es), with two or more elements in es.
                                               ECps [\"scDeployedOn\",\"compHasCommWith\",\"scDeployedOn~\"] */
                                            
                                            SELECT DISTINCT ECps0.`SvcComponent` AS `SvcComponent1`, ECps2.`SvcComponent`
                                            FROM `scDeployedOn` AS ECps0,
                                                 `compHasCommWith` AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `SvcComponent`, `Computer`
                                                   FROM `scDeployedOn`
                                                   WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Computer`=ECps1.`sComputer`
                                              AND ECps1.`tComputer`=ECps2.`Computer`
                                          ) AS ECps1
                                     WHERE ECps0.`tSvcComponent`=ECps1.`SvcComponent`
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`scNoReqCommSatisfied` = isect1.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;scNoReqCommSatisfied;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'InssvcAllSvcCompReqsSatisfied' =>
        array ( 'name' => 'InssvcAllSvcCompReqsSatisfied'
              , 'ruleAdl' => 'I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scAllReqCommSatisfied;scImplements) |- svcAllSvcCompReqsSatisfied'
              , 'origin' => 'line 157, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scAllReqCommSatisfied;scImplements)) \\/ svcAllSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scAllReqCommSatisfied;scImplements)/\\-svcAllSvcCompReqsSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Service]\",\"scImplements~;scImplements\",\"-scImplements~!(scAllReqCommSatisfied;scImplements)\",\"-svcAllSvcCompReqsSatisfied\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Service`, `Service` AS `Service1`
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scImplements~\",\"scImplements\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Service`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps0,
                                      `scImplements` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect1, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-scImplements~\",\"scAllReqCommSatisfied;scImplements\"] */
                                 /* case: ECpl e
                                    ECpl [ \"--scImplements~;-(scAllReqCommSatisfied;scImplements)\" ] */
                                 SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                 FROM `Service` AS cfst,
                                      `Service` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"--scImplements~\",\"-(scAllReqCommSatisfied;scImplements)\"] */
                                          
                                          SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"-scImplements~\" ] */
                                                 SELECT DISTINCT cfst.`Service`, csnd.`SvcComponent`
                                                 FROM `Service` AS cfst,
                                                      `SvcComponent` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          /* case: ECpl e
                                                             ECpl [ \"scImplements\" ] */
                                                          SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                          FROM `SvcComponent` AS cfst,
                                                               `Service` AS csnd
                                                          WHERE NOT EXISTS
                                                           (SELECT * FROM `scImplements` AS cp
                                                            WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                                        ) AS cp
                                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                               ) AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"scAllReqCommSatisfied;scImplements\" ] */
                                                 SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                 FROM `SvcComponent` AS cfst,
                                                      `Service` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"scAllReqCommSatisfied\",\"scImplements\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`Service`
                                                          FROM `SvcComponent` AS ECps0,
                                                               `scImplements` AS ECps1
                                                          WHERE ECps0.`scAllReqCommSatisfied`=ECps1.`SvcComponent`
                                                        ) AS cp
                                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                               ) AS ECps1
                                          WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                        ) AS cp
                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                               ) AS isect2
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`Service1` = isect1.`Service1`) AND (isect0.`Service` = isect2.`Service` AND isect0.`Service1` = isect2.`Service1`) AND NOT EXISTS (SELECT * FROM `Service` AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`svcAllSvcCompReqsSatisfied`) AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcAllSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'DelsvcAllSvcCompReqsSatisfied' =>
        array ( 'name' => 'DelsvcAllSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcAllSvcCompReqsSatisfied |- I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scAllReqCommSatisfied;scImplements)'
              , 'origin' => 'line 161, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-svcAllSvcCompReqsSatisfied \\/ (I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scAllReqCommSatisfied;scImplements)))
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied/\\-(I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scAllReqCommSatisfied;scImplements))
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied/\\(-I[Service] \\/ -(scImplements~;scImplements) \\/ -(-scImplements~!(scAllReqCommSatisfied;scImplements)))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcAllSvcCompReqsSatisfied\",\"-I[Service] \\\\/ -(scImplements~;scImplements) \\\\/ -(-scImplements~!(scAllReqCommSatisfied;scImplements))\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcAllSvcCompReqsSatisfied` AS tgt
                          FROM `Service` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[Service]\",\"-(scImplements~;scImplements)\",\"-(-scImplements~!(scAllReqCommSatisfied;scImplements))\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[Service]\" ] */
                                     SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                     FROM `Service` AS cfst,
                                          `Service` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `Service`, `Service` AS `Service1`
                                              FROM `Service`
                                              WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"scImplements~;scImplements\" ] */
                                     SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                     FROM `Service` AS cfst,
                                          `Service` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"scImplements~\",\"scImplements\"] */
                                              
                                              SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                              FROM 
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `SvcComponent`, `Service`
                                                     FROM `scImplements`
                                                     WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                   ) AS ECps0,
                                                   `scImplements` AS ECps1
                                              WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                            ) AS cp
                                       WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"-scImplements~!(scAllReqCommSatisfied;scImplements)\" ] */
                                     SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                     FROM `Service` AS cfst,
                                          `Service` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ERad es@(_:_:_)
                                                 ERad [\"-scImplements~\",\"scAllReqCommSatisfied;scImplements\"] */
                                              /* case: ECpl e
                                                 ECpl [ \"--scImplements~;-(scAllReqCommSatisfied;scImplements)\" ] */
                                              SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                              FROM `Service` AS cfst,
                                                   `Service` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"--scImplements~\",\"-(scAllReqCommSatisfied;scImplements)\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                                       FROM 
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"-scImplements~\" ] */
                                                              SELECT DISTINCT cfst.`Service`, csnd.`SvcComponent`
                                                              FROM `Service` AS cfst,
                                                                   `SvcComponent` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: EFlp x. */
                                                                       /* case: ECpl e
                                                                          ECpl [ \"scImplements\" ] */
                                                                       SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                                       FROM `SvcComponent` AS cfst,
                                                                            `Service` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM `scImplements` AS cp
                                                                         WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                                                     ) AS cp
                                                                WHERE cfst.`Service`=cp.`Service` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                                            ) AS ECps0,
                                                            
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"scAllReqCommSatisfied;scImplements\" ] */
                                                              SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                              FROM `SvcComponent` AS cfst,
                                                                   `Service` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                          ECps [\"scAllReqCommSatisfied\",\"scImplements\"] */
                                                                       
                                                                       SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`Service`
                                                                       FROM `SvcComponent` AS ECps0,
                                                                            `scImplements` AS ECps1
                                                                       WHERE ECps0.`scAllReqCommSatisfied`=ECps1.`SvcComponent`
                                                                     ) AS cp
                                                                WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                                            ) AS ECps1
                                                       WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                     ) AS cp
                                                WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                            ) AS cp
                                       WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`svcAllSvcCompReqsSatisfied` = isect1.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`svcAllSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;svcAllSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'InssvcNoSvcCompReqsSatisfied' =>
        array ( 'name' => 'InssvcNoSvcCompReqsSatisfied'
              , 'ruleAdl' => 'I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scNoReqCommSatisfied;scImplements) |- svcNoSvcCompReqsSatisfied'
              , 'origin' => 'line 167, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scNoReqCommSatisfied;scImplements)) \\/ svcNoSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scNoReqCommSatisfied;scImplements)/\\-svcNoSvcCompReqsSatisfied
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Service]\",\"scImplements~;scImplements\",\"-scImplements~!(scNoReqCommSatisfied;scImplements)\",\"-svcNoSvcCompReqsSatisfied\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Service`, `Service` AS `Service1`
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scImplements~\",\"scImplements\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Service`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps0,
                                      `scImplements` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect1, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-scImplements~\",\"scNoReqCommSatisfied;scImplements\"] */
                                 /* case: ECpl e
                                    ECpl [ \"--scImplements~;-(scNoReqCommSatisfied;scImplements)\" ] */
                                 SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                 FROM `Service` AS cfst,
                                      `Service` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"--scImplements~\",\"-(scNoReqCommSatisfied;scImplements)\"] */
                                          
                                          SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"-scImplements~\" ] */
                                                 SELECT DISTINCT cfst.`Service`, csnd.`SvcComponent`
                                                 FROM `Service` AS cfst,
                                                      `SvcComponent` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          /* case: ECpl e
                                                             ECpl [ \"scImplements\" ] */
                                                          SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                          FROM `SvcComponent` AS cfst,
                                                               `Service` AS csnd
                                                          WHERE NOT EXISTS
                                                           (SELECT * FROM `scImplements` AS cp
                                                            WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                                        ) AS cp
                                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                               ) AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"scNoReqCommSatisfied;scImplements\" ] */
                                                 SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                 FROM `SvcComponent` AS cfst,
                                                      `Service` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: (ECps es), with two or more elements in es.
                                                             ECps [\"scNoReqCommSatisfied\",\"scImplements\"] */
                                                          
                                                          SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`Service`
                                                          FROM `SvcComponent` AS ECps0,
                                                               `scImplements` AS ECps1
                                                          WHERE ECps0.`scNoReqCommSatisfied`=ECps1.`SvcComponent`
                                                        ) AS cp
                                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                               ) AS ECps1
                                          WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                        ) AS cp
                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                               ) AS isect2
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`Service1` = isect1.`Service1`) AND (isect0.`Service` = isect2.`Service` AND isect0.`Service1` = isect2.`Service1`) AND NOT EXISTS (SELECT * FROM `Service` AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`svcNoSvcCompReqsSatisfied`) AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcNoSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'DelsvcNoSvcCompReqsSatisfied' =>
        array ( 'name' => 'DelsvcNoSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcNoSvcCompReqsSatisfied |- I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scNoReqCommSatisfied;scImplements)'
              , 'origin' => 'line 171, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-svcNoSvcCompReqsSatisfied \\/ (I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scNoReqCommSatisfied;scImplements)))
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied/\\-(I[Service]/\\scImplements~;scImplements/\\-scImplements~!(scNoReqCommSatisfied;scImplements))
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied/\\(-I[Service] \\/ -(scImplements~;scImplements) \\/ -(-scImplements~!(scNoReqCommSatisfied;scImplements)))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcNoSvcCompReqsSatisfied\",\"-I[Service] \\\\/ -(scImplements~;scImplements) \\\\/ -(-scImplements~!(scNoReqCommSatisfied;scImplements))\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcNoSvcCompReqsSatisfied` AS tgt
                          FROM `Service` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I[Service]\",\"-(scImplements~;scImplements)\",\"-(-scImplements~!(scNoReqCommSatisfied;scImplements))\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I[Service]\" ] */
                                     SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                     FROM `Service` AS cfst,
                                          `Service` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ETyp x _
                                                 ETyp ( \"I\" ) _ */
                                              SELECT DISTINCT `Service`, `Service` AS `Service1`
                                              FROM `Service`
                                              WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                                            ) AS cp
                                       WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"scImplements~;scImplements\" ] */
                                     SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                     FROM `Service` AS cfst,
                                          `Service` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"scImplements~\",\"scImplements\"] */
                                              
                                              SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                              FROM 
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `SvcComponent`, `Service`
                                                     FROM `scImplements`
                                                     WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                   ) AS ECps0,
                                                   `scImplements` AS ECps1
                                              WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                            ) AS cp
                                       WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"-scImplements~!(scNoReqCommSatisfied;scImplements)\" ] */
                                     SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                     FROM `Service` AS cfst,
                                          `Service` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: ERad es@(_:_:_)
                                                 ERad [\"-scImplements~\",\"scNoReqCommSatisfied;scImplements\"] */
                                              /* case: ECpl e
                                                 ECpl [ \"--scImplements~;-(scNoReqCommSatisfied;scImplements)\" ] */
                                              SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                              FROM `Service` AS cfst,
                                                   `Service` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"--scImplements~\",\"-(scNoReqCommSatisfied;scImplements)\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                                       FROM 
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"-scImplements~\" ] */
                                                              SELECT DISTINCT cfst.`Service`, csnd.`SvcComponent`
                                                              FROM `Service` AS cfst,
                                                                   `SvcComponent` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: EFlp x. */
                                                                       /* case: ECpl e
                                                                          ECpl [ \"scImplements\" ] */
                                                                       SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                                       FROM `SvcComponent` AS cfst,
                                                                            `Service` AS csnd
                                                                       WHERE NOT EXISTS
                                                                        (SELECT * FROM `scImplements` AS cp
                                                                         WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                                                     ) AS cp
                                                                WHERE cfst.`Service`=cp.`Service` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                                            ) AS ECps0,
                                                            
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"scNoReqCommSatisfied;scImplements\" ] */
                                                              SELECT DISTINCT cfst.`SvcComponent`, csnd.`Service`
                                                              FROM `SvcComponent` AS cfst,
                                                                   `Service` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                          ECps [\"scNoReqCommSatisfied\",\"scImplements\"] */
                                                                       
                                                                       SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`Service`
                                                                       FROM `SvcComponent` AS ECps0,
                                                                            `scImplements` AS ECps1
                                                                       WHERE ECps0.`scNoReqCommSatisfied`=ECps1.`SvcComponent`
                                                                     ) AS cp
                                                                WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Service`=cp.`Service`)
                                                            ) AS ECps1
                                                       WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                     ) AS cp
                                                WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                            ) AS cp
                                       WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`svcNoSvcCompReqsSatisfied` = isect1.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`svcNoSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;svcNoSvcCompReqsSatisfied;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    )
              )
    , 'Connect computer to network router' =>
        array ( 'name' => 'Connect computer to network router'
              , 'ruleAdl' => 'I/\\compReqCommWith;compReqCommWith~ |- compRouter;(I/\\routerNW;routerNW~);compRouter~'
              , 'origin' => 'line 12, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'A computer that needs to communicate with another computer must be connected to a network-router'
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I/\\compReqCommWith;compReqCommWith~) \\/ compRouter;(I/\\routerNW;routerNW~);compRouter~)
              // <=> { De Morgan }
              //     I/\\compReqCommWith;compReqCommWith~/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"compReqCommWith;compReqCommWith~\",\"-(compRouter;(I/\\\\routerNW;routerNW~);compRouter~)\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`sComputer1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compReqCommWith\",\"compReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sComputer`, ECps1.`sComputer` AS `sComputer1`
                                 FROM `compReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sComputer`, `tComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tComputer`=ECps1.`tComputer`
                               ) AS isect0, `Computer` AS isect1
                          WHERE isect0.`sComputer` = isect0.`sComputer1` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\",\"compRouter~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"I\",\"routerNW;routerNW~\"] */
                                                    SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"routerNW\",\"routerNW~\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                           FROM `Router` AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router`, `routerNW`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                         ) AS isect0, `Router` AS isect1
                                                    WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `Router`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                               AND ECps1.`Router1`=ECps2.`Router`
                                           ) AS cp
                                      WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`sComputer1`=cp.`Computer1`) AND isect0.`sComputer` IS NOT NULL AND isect0.`sComputer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be connected to a network-router.')
                    )
              )
    , 'insconnectComputerToNetworkRouter' =>
        array ( 'name' => 'insconnectComputerToNetworkRouter'
              , 'ruleAdl' => '(I/\\compReqCommWith;compReqCommWith~)/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~) |- connectComputerToNetworkRouter'
              , 'origin' => 'line 17, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I/\\compReqCommWith;compReqCommWith~/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~)) \\/ connectComputerToNetworkRouter)
              // <=> { De Morgan }
              //     I/\\compReqCommWith;compReqCommWith~/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~)/\\-connectComputerToNetworkRouter
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"compReqCommWith;compReqCommWith~\",\"-(compRouter;(I/\\\\routerNW;routerNW~);compRouter~)\",\"-connectComputerToNetworkRouter\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`sComputer1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compReqCommWith\",\"compReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sComputer`, ECps1.`sComputer` AS `sComputer1`
                                 FROM `compReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sComputer`, `tComputer`
                                        FROM `compReqCommWith`
                                        WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tComputer`=ECps1.`tComputer`
                               ) AS isect0, `Computer` AS isect1
                          WHERE isect0.`sComputer` = isect0.`sComputer1` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\",\"compRouter~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"I\",\"routerNW;routerNW~\"] */
                                                    SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"routerNW\",\"routerNW~\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                           FROM `Router` AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router`, `routerNW`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                         ) AS isect0, `Router` AS isect1
                                                    WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                                  ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `Router`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                               AND ECps1.`Router1`=ECps2.`Router`
                                           ) AS cp
                                      WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`sComputer1`=cp.`Computer1`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`sComputer`=cp.`Computer` AND isect0.`sComputer1`=cp.`connectComputerToNetworkRouter`) AND isect0.`sComputer` IS NOT NULL AND isect0.`sComputer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;connectComputerToNetworkRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'delconnectComputerToNetworkRouter' =>
        array ( 'name' => 'delconnectComputerToNetworkRouter'
              , 'ruleAdl' => 'connectComputerToNetworkRouter |- (I/\\compReqCommWith;compReqCommWith~)/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~)'
              , 'origin' => 'line 20, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-connectComputerToNetworkRouter \\/ (I/\\compReqCommWith;compReqCommWith~/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~)))
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter/\\-(I/\\compReqCommWith;compReqCommWith~/\\-(compRouter;(I/\\routerNW;routerNW~);compRouter~))
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter/\\(-I \\/ -(compReqCommWith;compReqCommWith~) \\/ compRouter;(I/\\routerNW;routerNW~);compRouter~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"connectComputerToNetworkRouter\",\"-I \\\\/ -(compReqCommWith;compReqCommWith~) \\\\/ compRouter;(I/\\\\routerNW;routerNW~);compRouter~\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`connectComputerToNetworkRouter` AS tgt
                          FROM `Computer` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"-(compReqCommWith;compReqCommWith~)\",\"compRouter;(I/\\\\routerNW;routerNW~);compRouter~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `Computer` AS cp
                                       WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"compReqCommWith;compReqCommWith~\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"compReqCommWith\",\"compReqCommWith~\"] */
                                              
                                              SELECT DISTINCT ECps0.`sComputer`, ECps1.`sComputer` AS `sComputer1`
                                              FROM `compReqCommWith` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `sComputer`, `tComputer`
                                                     FROM `compReqCommWith`
                                                     WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`tComputer`=ECps1.`tComputer`
                                            ) AS cp
                                       WHERE cfst.`Computer`=cp.`sComputer` AND csnd.`Computer`=cp.`sComputer1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\",\"compRouter~\"] */
                                     
                                     SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                     FROM `compRouter` AS ECps0,
                                          
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"routerNW;routerNW~\"] */
                                            SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                            FROM 
                                                 ( /* case: (ECps es), with two or more elements in es.
                                                      ECps [\"routerNW\",\"routerNW~\"] */
                                                   
                                                   SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                   FROM `Router` AS ECps0,
                                                        
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Router`, `routerNW`
                                                          FROM `Router`
                                                          WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                        ) AS ECps1
                                                   WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                 ) AS isect0, `Router` AS isect1
                                            WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                          ) AS ECps1,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Computer`, `Router`
                                            FROM `compRouter`
                                            WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                          ) AS ECps2
                                     WHERE ECps0.`Router`=ECps1.`Router`
                                       AND ECps1.`Router1`=ECps2.`Router`
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`connectComputerToNetworkRouter` = isect1.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`connectComputerToNetworkRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;connectComputerToNetworkRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Create router paths' =>
        array ( 'name' => 'Create router paths'
              , 'ruleAdl' => 'routerNeedsPathTo |- -V'
              , 'origin' => 'line 24, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'A router must have a path to another router if a computer is connected to it that has an unsatisfied communication requirement with another computer that is connected to the other router.'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-routerNeedsPathTo \\/ -V)
              // <=> { De Morgan }
              //     routerNeedsPathTo/\\V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNeedsPathTo\",\"V\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `routerNeedsPathTo` AS isect0, ( /* case: (ERel (V (Sign s t)))
                               ERel [ \"V[Router]\" ] */
                            SELECT DISTINCT cfst0.`Router`
                            FROM `Router` AS cfst0, `Router` AS cfst1 ) AS isect1
                          WHERE (isect0.`sRouter` = isect1.`Router` AND isect0.`tRouter` = isect1.`Router`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'A path must exist from router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' to ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Routes to be discarded' =>
        array ( 'name' => 'Routes to be discarded'
              , 'ruleAdl' => 'rrtDirect |- routerNW;V;routerNW~'
              , 'origin' => 'line 29, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'Routing can only be done by routers that are part of a network.'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-rrtDirect \\/ routerNW;V;routerNW~)
              // <=> { De Morgan }
              //     rrtDirect/\\-(routerNW;V;routerNW~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrtDirect\",\"-(routerNW;V;routerNW~)\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `rrtDirect` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: ECps (e:ERel (V _):f:fx)
                                                ECps [\"routerNW\",\"V\",\"routerNW~\"] */
                                             SELECT DISTINCT fst.`Router`, snd.`Router` AS `Router1`
                                             FROM `Router` AS fst,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS snd
                                             WHERE fst.`Router` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`sRouter`=cp.`Router` AND isect0.`tRouter`=cp.`Router1`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Route from ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' to ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' should be removed.')
                    )
              )
    , 'insroutesToBeDiscarded' =>
        array ( 'name' => 'insroutesToBeDiscarded'
              , 'ruleAdl' => 'rrtDirect/\\-(routerNW;V;routerNW~) |- routesToBeDiscarded'
              , 'origin' => 'line 34, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(rrtDirect/\\-(routerNW;V;routerNW~)) \\/ routesToBeDiscarded)
              // <=> { De Morgan }
              //     rrtDirect/\\-(routerNW;V;routerNW~)/\\-routesToBeDiscarded
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrtDirect\",\"-(routerNW;V;routerNW~)\",\"-routesToBeDiscarded\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `rrtDirect` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: ECps (e:ERel (V _):f:fx)
                                                ECps [\"routerNW\",\"V\",\"routerNW~\"] */
                                             SELECT DISTINCT fst.`Router`, snd.`Router` AS `Router1`
                                             FROM `Router` AS fst,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS snd
                                             WHERE fst.`Router` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`sRouter`=cp.`Router` AND isect0.`tRouter`=cp.`Router1`) AND NOT EXISTS (SELECT * FROM `routesToBeDiscarded` AS cp
                                      WHERE isect0.`sRouter`=cp.`sRouter` AND isect0.`tRouter`=cp.`tRouter`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routesToBeDiscarded;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'delroutesToBeDiscarded' =>
        array ( 'name' => 'delroutesToBeDiscarded'
              , 'ruleAdl' => 'routesToBeDiscarded |- rrtDirect/\\-(routerNW;V;routerNW~)'
              , 'origin' => 'line 37, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-routesToBeDiscarded \\/ (rrtDirect/\\-(routerNW;V;routerNW~)))
              // <=> { De Morgan }
              //     routesToBeDiscarded/\\-(rrtDirect/\\-(routerNW;V;routerNW~))
              // <=> { De Morgan }
              //     routesToBeDiscarded/\\(-rrtDirect \\/ routerNW;V;routerNW~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routesToBeDiscarded\",\"-rrtDirect \\\\/ routerNW;V;routerNW~\"] */
                          SELECT DISTINCT isect0.`sRouter` AS src, isect0.`tRouter` AS tgt
                          FROM `routesToBeDiscarded` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-rrtDirect\",\"routerNW;V;routerNW~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"rrtDirect\" ] */
                                     SELECT DISTINCT cfst.`Router` AS `sRouter`, csnd.`Router` AS `tRouter`
                                     FROM `Router` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `rrtDirect` AS cp
                                       WHERE cfst.`Router`=cp.`sRouter` AND csnd.`Router`=cp.`tRouter`)
                                 ) UNION (/* case: ECps (e:ERel (V _):f:fx)
                                        ECps [\"routerNW\",\"V\",\"routerNW~\"] */
                                     SELECT DISTINCT fst.`Router` AS `sRouter`, snd.`Router` AS `tRouter`
                                     FROM `Router` AS fst,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Router`, `routerNW`
                                            FROM `Router`
                                            WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                          ) AS snd
                                     WHERE fst.`Router` IS NOT NULL
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`sRouter` = isect1.`sRouter` AND isect0.`tRouter` = isect1.`tRouter`) AND isect0.`sRouter` IS NOT NULL AND isect0.`tRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routesToBeDiscarded;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Computers to be disconnected' =>
        array ( 'name' => 'Computers to be disconnected'
              , 'ruleAdl' => 'compRouter |- compRouter;(I/\\routerNW;routerNW~)'
              , 'origin' => 'line 41, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'A router to which a computer is connected must be part of a network.'
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-compRouter \\/ compRouter;(I/\\routerNW;routerNW~))
              // <=> { De Morgan }
              //     compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRouter\",\"-(compRouter;(I/\\\\routerNW;routerNW~))\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Router` AS tgt
                          FROM `compRouter` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Router1` AS `Router`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"I\",\"routerNW;routerNW~\"] */
                                                    SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"routerNW\",\"routerNW~\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                           FROM `Router` AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router`, `routerNW`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                         ) AS isect0, `Router` AS isect1
                                                    WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Router`=cp.`Router`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Computer ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' cannot be connected to router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' as the latter is not connected to a network.')
                    )
              )
    , 'inscomputerToBeDisconnected' =>
        array ( 'name' => 'inscomputerToBeDisconnected'
              , 'ruleAdl' => 'compRouter/\\-(compRouter;(I/\\routerNW;routerNW~)) |- computerToBeDisconnected'
              , 'origin' => 'line 46, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))) \\/ computerToBeDisconnected)
              // <=> { De Morgan }
              //     compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))/\\-computerToBeDisconnected
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRouter\",\"-(compRouter;(I/\\\\routerNW;routerNW~))\",\"-computerToBeDisconnected\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Router` AS tgt
                          FROM `compRouter` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Router1` AS `Router`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"I\",\"routerNW;routerNW~\"] */
                                                    SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"routerNW\",\"routerNW~\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                           FROM `Router` AS ECps0,
                                                                
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Router`, `routerNW`
                                                                  FROM `Router`
                                                                  WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                ) AS ECps1
                                                           WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                         ) AS isect0, `Router` AS isect1
                                                    WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Router`=cp.`Router`) AND NOT EXISTS (SELECT * FROM `computerToBeDisconnected` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Router`=cp.`Router`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;computerToBeDisconnected;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'delcomputerToBeDisconnected' =>
        array ( 'name' => 'delcomputerToBeDisconnected'
              , 'ruleAdl' => 'computerToBeDisconnected |- compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))'
              , 'origin' => 'line 49, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-computerToBeDisconnected \\/ (compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))))
              // <=> { De Morgan }
              //     computerToBeDisconnected/\\-(compRouter/\\-(compRouter;(I/\\routerNW;routerNW~)))
              // <=> { De Morgan }
              //     computerToBeDisconnected/\\(-compRouter \\/ compRouter;(I/\\routerNW;routerNW~))
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"computerToBeDisconnected\",\"-compRouter \\\\/ compRouter;(I/\\\\routerNW;routerNW~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Router` AS tgt
                          FROM `computerToBeDisconnected` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-compRouter\",\"compRouter;(I/\\\\routerNW;routerNW~)\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"compRouter\" ] */
                                     SELECT DISTINCT cfst.`Computer`, csnd.`Router`
                                     FROM `Computer` AS cfst,
                                          `Router` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `compRouter` AS cp
                                       WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Router`=cp.`Router`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\"] */
                                     
                                     SELECT DISTINCT ECps0.`Computer`, ECps1.`Router1` AS `Router`
                                     FROM `compRouter` AS ECps0,
                                          
                                          ( /* case: (EIsc lst@(_:_:_))
                                               EIsc [\"I\",\"routerNW;routerNW~\"] */
                                            SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                            FROM 
                                                 ( /* case: (ECps es), with two or more elements in es.
                                                      ECps [\"routerNW\",\"routerNW~\"] */
                                                   
                                                   SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                   FROM `Router` AS ECps0,
                                                        
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Router`, `routerNW`
                                                          FROM `Router`
                                                          WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                        ) AS ECps1
                                                   WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                 ) AS isect0, `Router` AS isect1
                                            WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                          ) AS ECps1
                                     WHERE ECps0.`Router`=ECps1.`Router`
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Router` = isect1.`Router`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;computerToBeDisconnected;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Set up computer-computer communications' =>
        array ( 'name' => 'Set up computer-computer communications'
              , 'ruleAdl' => 'compReqCommWith |- compHasCommWith'
              , 'origin' => 'line 53, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'When a computer requires communication with another computer, it must be actually capable of doing so'
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-compReqCommWith \\/ compHasCommWith)
              // <=> { De Morgan }
              //     compReqCommWith/\\-compHasCommWith
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compReqCommWith\",\"-compHasCommWith\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                          FROM `compReqCommWith` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                      WHERE isect0.`sComputer`=cp.`sComputer` AND isect0.`tComputer`=cp.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Computer ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' requires a comm.link with ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'inssetupComputerComputerCommunications' =>
        array ( 'name' => 'inssetupComputerComputerCommunications'
              , 'ruleAdl' => 'compReqCommWith/\\-compHasCommWith |- setupComputerComputerCommunications'
              , 'origin' => 'line 58, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compReqCommWith/\\-compHasCommWith) \\/ setupComputerComputerCommunications)
              // <=> { De Morgan }
              //     compReqCommWith/\\-compHasCommWith/\\-setupComputerComputerCommunications
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compReqCommWith\",\"-compHasCommWith\",\"-setupComputerComputerCommunications\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                          FROM `compReqCommWith` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                      WHERE isect0.`sComputer`=cp.`sComputer` AND isect0.`tComputer`=cp.`tComputer`) AND NOT EXISTS (SELECT * FROM `setupComputerComputerCommunications` AS cp
                                      WHERE isect0.`sComputer`=cp.`sComputer` AND isect0.`tComputer`=cp.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;setupComputerComputerCommunications;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'delsetupComputerComputerCommunications' =>
        array ( 'name' => 'delsetupComputerComputerCommunications'
              , 'ruleAdl' => 'setupComputerComputerCommunications |- compReqCommWith/\\-compHasCommWith'
              , 'origin' => 'line 61, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-setupComputerComputerCommunications \\/ (compReqCommWith/\\-compHasCommWith))
              // <=> { De Morgan }
              //     setupComputerComputerCommunications/\\-(compReqCommWith/\\-compHasCommWith)
              // <=> { De Morgan }
              //     setupComputerComputerCommunications/\\(-compReqCommWith \\/ compHasCommWith)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"setupComputerComputerCommunications\",\"-compReqCommWith \\\\/ compHasCommWith\"] */
                          SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                          FROM `setupComputerComputerCommunications` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-compReqCommWith\",\"compHasCommWith\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"compReqCommWith\" ] */
                                     SELECT DISTINCT cfst.`Computer` AS `sComputer`, csnd.`Computer` AS `tComputer`
                                     FROM `Computer` AS cfst,
                                          `Computer` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `compReqCommWith` AS cp
                                       WHERE cfst.`Computer`=cp.`sComputer` AND csnd.`Computer`=cp.`tComputer`)
                                 ) UNION (SELECT DISTINCT `sComputer`, `tComputer`
                                     FROM `compHasCommWith`
                                     WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`sComputer` = isect1.`sComputer` AND isect0.`tComputer` = isect1.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;setupComputerComputerCommunications;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Start running service components' =>
        array ( 'name' => 'Start running service components'
              , 'ruleAdl' => 'I/\\scImplements;scImplements~ |- scDeployedOn;scDeployedOn~'
              , 'origin' => 'line 65, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'Every service component that is required for a service must run (at least one) instance on a computer'
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I/\\scImplements;scImplements~) \\/ scDeployedOn;scDeployedOn~)
              // <=> { De Morgan }
              //     I/\\scImplements;scImplements~/\\-(scDeployedOn;scDeployedOn~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"scImplements;scImplements~\",\"-(scDeployedOn;scDeployedOn~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scImplements\",\"scImplements~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                 FROM `scImplements` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Service`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0, `SvcComponent` AS isect1
                          WHERE isect0.`SvcComponent` = isect0.`SvcComponent1` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `scDeployedOn` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Computer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'An instance of ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be started on some computer.')
                    )
              )
    , 'insstartRunningServiceComponents' =>
        array ( 'name' => 'insstartRunningServiceComponents'
              , 'ruleAdl' => '(I/\\scImplements;scImplements~)/\\-(scDeployedOn;scDeployedOn~) |- startRunningServiceComponents'
              , 'origin' => 'line 70, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I/\\scImplements;scImplements~/\\-(scDeployedOn;scDeployedOn~)) \\/ startRunningServiceComponents)
              // <=> { De Morgan }
              //     I/\\scImplements;scImplements~/\\-(scDeployedOn;scDeployedOn~)/\\-startRunningServiceComponents
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"scImplements;scImplements~\",\"-(scDeployedOn;scDeployedOn~)\",\"-startRunningServiceComponents\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scImplements\",\"scImplements~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                 FROM `scImplements` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Service`
                                        FROM `scImplements`
                                        WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0, `SvcComponent` AS isect1
                          WHERE isect0.`SvcComponent` = isect0.`SvcComponent1` AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `scDeployedOn` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Computer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`startRunningServiceComponents`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;startRunningServiceComponents;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'delstartRunningServiceComponents' =>
        array ( 'name' => 'delstartRunningServiceComponents'
              , 'ruleAdl' => 'startRunningServiceComponents |- (I/\\scImplements;scImplements~)/\\-(scDeployedOn;scDeployedOn~)'
              , 'origin' => 'line 73, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-startRunningServiceComponents \\/ (I/\\scImplements;scImplements~/\\-(scDeployedOn;scDeployedOn~)))
              // <=> { De Morgan }
              //     startRunningServiceComponents/\\-(I/\\scImplements;scImplements~/\\-(scDeployedOn;scDeployedOn~))
              // <=> { De Morgan }
              //     startRunningServiceComponents/\\(-I \\/ -(scImplements;scImplements~) \\/ scDeployedOn;scDeployedOn~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"startRunningServiceComponents\",\"-I \\\\/ -(scImplements;scImplements~) \\\\/ scDeployedOn;scDeployedOn~\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`startRunningServiceComponents` AS tgt
                          FROM `SvcComponent` AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-I\",\"-(scImplements;scImplements~)\",\"scDeployedOn;scDeployedOn~\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"I\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `SvcComponent` AS cp
                                       WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"scImplements;scImplements~\" ] */
                                     SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                     FROM `SvcComponent` AS cfst,
                                          `SvcComponent` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"scImplements\",\"scImplements~\"] */
                                              
                                              SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                              FROM `scImplements` AS ECps0,
                                                   
                                                   ( /* case: EFlp x. */
                                                     SELECT DISTINCT `SvcComponent`, `Service`
                                                     FROM `scImplements`
                                                     WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`Service`=ECps1.`Service`
                                            ) AS cp
                                       WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent1`)
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                     
                                     SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                     FROM `scDeployedOn` AS ECps0,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `SvcComponent`, `Computer`
                                            FROM `scDeployedOn`
                                            WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                          ) AS ECps1
                                     WHERE ECps0.`Computer`=ECps1.`Computer`
                                 
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`startRunningServiceComponents` = isect1.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`startRunningServiceComponents` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;startRunningServiceComponents;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'Network status integrity check' =>
        array ( 'name' => 'Network status integrity check'
              , 'ruleAdl' => 'routerNW~;routerNW/\\nwAllCompCommReqsSatisfied/\\nwNoCompCommReqsSatisfied |- -I'
              , 'origin' => 'line 19, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => 'Network status integrity check'
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(routerNW~;routerNW/\\nwAllCompCommReqsSatisfied/\\nwNoCompCommReqsSatisfied) \\/ -I)
              // <=> { De Morgan }
              //     routerNW~;routerNW/\\nwAllCompCommReqsSatisfied/\\nwNoCompCommReqsSatisfied/\\I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNW~;routerNW\",\"nwAllCompCommReqsSatisfied\",\"nwNoCompCommReqsSatisfied\",\"I\"] */
                          SELECT DISTINCT isect0.`routerNW` AS src, isect0.`routerNW1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW~\",\"routerNW\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0, `Network` AS isect1, `Network` AS isect2, `Network` AS isect3
                          WHERE (isect0.`routerNW` = isect1.`Network` AND isect0.`routerNW1` = isect1.`nwAllCompCommReqsSatisfied`) AND (isect0.`routerNW` = isect2.`Network` AND isect0.`routerNW1` = isect2.`nwNoCompCommReqsSatisfied`) AND isect0.`routerNW` = isect0.`routerNW1` AND isect0.`routerNW` IS NOT NULL AND isect0.`routerNW1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent network properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    )
              )
    , 'Network status \'Green\'' =>
        array ( 'name' => 'Network status \'Green\''
              , 'ruleAdl' => 'I[Network]/\\routerNW~;routerNW/\\nwAllCompCommReqsSatisfied |- nwStatus;\'Green\';nwStatus~'
              , 'origin' => 'line 24, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(I[Network]/\\routerNW~;routerNW/\\nwAllCompCommReqsSatisfied) \\/ nwStatus;\'Green\';nwStatus~)
              // <=> { De Morgan }
              //     I[Network]/\\routerNW~;routerNW/\\nwAllCompCommReqsSatisfied/\\-(nwStatus;\'Green\';nwStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Network]\",\"routerNW~;routerNW\",\"nwAllCompCommReqsSatisfied\",\"-(nwStatus;\'Green\';nwStatus~)\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Network`, `Network` AS `Network1`
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW~\",\"routerNW\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1, `Network` AS isect2
                          WHERE (isect0.`Network` = isect1.`routerNW` AND isect0.`Network1` = isect1.`routerNW1`) AND (isect0.`Network` = isect2.`Network` AND isect0.`Network1` = isect2.`nwAllCompCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"nwStatus\",\"\'Green\'\",\"nwStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Network`, ECps2.`Network` AS `Network1`
                                             FROM `Network` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network`, `nwStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`nwStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`nwStatus`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Network status \'Yellow\'' =>
        array ( 'name' => 'Network status \'Yellow\''
              , 'ruleAdl' => 'I[Network]/\\routerNW~;routerNW/\\-nwAllCompCommReqsSatisfied/\\-nwNoCompCommReqsSatisfied |- nwStatus;\'Yellow\';nwStatus~'
              , 'origin' => 'line 29, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(I[Network]/\\routerNW~;routerNW/\\-nwAllCompCommReqsSatisfied/\\-nwNoCompCommReqsSatisfied) \\/ nwStatus;\'Yellow\';nwStatus~)
              // <=> { De Morgan }
              //     I[Network]/\\routerNW~;routerNW/\\-nwAllCompCommReqsSatisfied/\\-nwNoCompCommReqsSatisfied/\\-(nwStatus;\'Yellow\';nwStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Network]\",\"routerNW~;routerNW\",\"-nwAllCompCommReqsSatisfied\",\"-nwNoCompCommReqsSatisfied\",\"-(nwStatus;\'Yellow\';nwStatus~)\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Network`, `Network` AS `Network1`
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW~\",\"routerNW\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1
                          WHERE (isect0.`Network` = isect1.`routerNW` AND isect0.`Network1` = isect1.`routerNW1`) AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`nwAllCompCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`nwNoCompCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"nwStatus\",\"\'Yellow\'\",\"nwStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Network`, ECps2.`Network` AS `Network1`
                                             FROM `Network` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network`, `nwStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`nwStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`nwStatus`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Network status \'Red\'' =>
        array ( 'name' => 'Network status \'Red\''
              , 'ruleAdl' => 'I[Network]/\\routerNW~;routerNW/\\nwNoCompCommReqsSatisfied |- nwStatus;\'Red\';nwStatus~'
              , 'origin' => 'line 34, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(I[Network]/\\routerNW~;routerNW/\\nwNoCompCommReqsSatisfied) \\/ nwStatus;\'Red\';nwStatus~)
              // <=> { De Morgan }
              //     I[Network]/\\routerNW~;routerNW/\\nwNoCompCommReqsSatisfied/\\-(nwStatus;\'Red\';nwStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Network]\",\"routerNW~;routerNW\",\"nwNoCompCommReqsSatisfied\",\"-(nwStatus;\'Red\';nwStatus~)\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Network`, `Network` AS `Network1`
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW~\",\"routerNW\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1, `Network` AS isect2
                          WHERE (isect0.`Network` = isect1.`routerNW` AND isect0.`Network1` = isect1.`routerNW1`) AND (isect0.`Network` = isect2.`Network` AND isect0.`Network1` = isect2.`nwNoCompCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"nwStatus\",\"\'Red\'\",\"nwStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Network`, ECps2.`Network` AS `Network1`
                                             FROM `Network` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network`, `nwStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`nwStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`nwStatus`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Network status \'Blue\'' =>
        array ( 'name' => 'Network status \'Blue\''
              , 'ruleAdl' => 'I[Network]/\\-(routerNW~;routerNW) |- nwStatus;\'Blue\';nwStatus~'
              , 'origin' => 'line 39, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(I[Network]/\\-(routerNW~;routerNW)) \\/ nwStatus;\'Blue\';nwStatus~)
              // <=> { De Morgan }
              //     I[Network]/\\-(routerNW~;routerNW)/\\-(nwStatus;\'Blue\';nwStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Network]\",\"-(routerNW~;routerNW)\",\"-(nwStatus;\'Blue\';nwStatus~)\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Network`, `Network` AS `Network1`
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNW~\",\"routerNW\"] */
                                             
                                             SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps0,
                                                  `Router` AS ECps1
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`routerNW` AND isect0.`Network1`=cp.`routerNW1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"nwStatus\",\"\'Blue\'\",\"nwStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Network`, ECps2.`Network` AS `Network1`
                                             FROM `Network` AS ECps0,
                                                  ( SELECT \'Blue\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network`, `nwStatus`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`nwStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`nwStatus`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network1`=cp.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Router status integrity check' =>
        array ( 'name' => 'Router status integrity check'
              , 'ruleAdl' => 'routerAllCommReqsSatisfied/\\routerNoCommReqsSatisfied |- -I'
              , 'origin' => 'line 57, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => 'Router status integrity check'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerAllCommReqsSatisfied/\\routerNoCommReqsSatisfied) \\/ -I)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied/\\routerNoCommReqsSatisfied/\\I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerAllCommReqsSatisfied\",\"routerNoCommReqsSatisfied\",\"I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerAllCommReqsSatisfied` AS tgt
                          FROM `Router` AS isect0, `Router` AS isect1, `Router` AS isect2
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`routerAllCommReqsSatisfied` = isect1.`routerNoCommReqsSatisfied`) AND isect0.`Router` = isect0.`routerAllCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent router properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Router status \'Green\'' =>
        array ( 'name' => 'Router status \'Green\''
              , 'ruleAdl' => 'I[Router]/\\routerNW;routerNW~/\\routerAllCommReqsSatisfied |- routerStatus;\'Green\';routerStatus~'
              , 'origin' => 'line 62, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\routerNW;routerNW~/\\routerAllCommReqsSatisfied) \\/ routerStatus;\'Green\';routerStatus~)
              // <=> { De Morgan }
              //     I[Router]/\\routerNW;routerNW~/\\routerAllCommReqsSatisfied/\\-(routerStatus;\'Green\';routerStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"routerNW;routerNW~\",\"routerAllCommReqsSatisfied\",\"-(routerStatus;\'Green\';routerStatus~)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW\",\"routerNW~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                 FROM `Router` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect1, `Router` AS isect2
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`Router1` = isect1.`Router1`) AND (isect0.`Router` = isect2.`Router` AND isect0.`Router1` = isect2.`routerAllCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerStatus\",\"\'Green\'\",\"routerStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`routerStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`routerStatus`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Router status \'Yellow\'' =>
        array ( 'name' => 'Router status \'Yellow\''
              , 'ruleAdl' => 'I[Router]/\\routerNW;routerNW~/\\-routerAllCommReqsSatisfied/\\-routerNoCommReqsSatisfied |- routerStatus;\'Yellow\';routerStatus~'
              , 'origin' => 'line 67, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\routerNW;routerNW~/\\-routerAllCommReqsSatisfied/\\-routerNoCommReqsSatisfied) \\/ routerStatus;\'Yellow\';routerStatus~)
              // <=> { De Morgan }
              //     I[Router]/\\routerNW;routerNW~/\\-routerAllCommReqsSatisfied/\\-routerNoCommReqsSatisfied/\\-(routerStatus;\'Yellow\';routerStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"routerNW;routerNW~\",\"-routerAllCommReqsSatisfied\",\"-routerNoCommReqsSatisfied\",\"-(routerStatus;\'Yellow\';routerStatus~)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW\",\"routerNW~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                 FROM `Router` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect1
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`Router1` = isect1.`Router1`) AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`routerAllCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`routerNoCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerStatus\",\"\'Yellow\'\",\"routerStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`routerStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`routerStatus`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Router status \'Red\'' =>
        array ( 'name' => 'Router status \'Red\''
              , 'ruleAdl' => 'I[Router]/\\routerNW;routerNW~/\\routerNoCommReqsSatisfied |- routerStatus;\'Red\';routerStatus~'
              , 'origin' => 'line 72, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\routerNW;routerNW~/\\routerNoCommReqsSatisfied) \\/ routerStatus;\'Red\';routerStatus~)
              // <=> { De Morgan }
              //     I[Router]/\\routerNW;routerNW~/\\routerNoCommReqsSatisfied/\\-(routerStatus;\'Red\';routerStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"routerNW;routerNW~\",\"routerNoCommReqsSatisfied\",\"-(routerStatus;\'Red\';routerStatus~)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW\",\"routerNW~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                 FROM `Router` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect1, `Router` AS isect2
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`Router1` = isect1.`Router1`) AND (isect0.`Router` = isect2.`Router` AND isect0.`Router1` = isect2.`routerNoCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerStatus\",\"\'Red\'\",\"routerStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`routerStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`routerStatus`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Router status \'Blue\'' =>
        array ( 'name' => 'Router status \'Blue\''
              , 'ruleAdl' => 'I[Router]/\\-(routerNW;routerNW~) |- routerStatus;\'Blue\';routerStatus~'
              , 'origin' => 'line 77, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\-(routerNW;routerNW~)) \\/ routerStatus;\'Blue\';routerStatus~)
              // <=> { De Morgan }
              //     I[Router]/\\-(routerNW;routerNW~)/\\-(routerStatus;\'Blue\';routerStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"-(routerNW;routerNW~)\",\"-(routerStatus;\'Blue\';routerStatus~)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNW\",\"routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`Router1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerStatus\",\"\'Blue\'\",\"routerStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps2.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  ( SELECT \'Blue\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerStatus`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`routerStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`routerStatus`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Computer status integrity check' =>
        array ( 'name' => 'Computer status integrity check'
              , 'ruleAdl' => 'compAllReqCommSatisfied/\\compNoReqCommSatisfied |- -I'
              , 'origin' => 'line 97, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => 'Computer status integrity check'
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compAllReqCommSatisfied/\\compNoReqCommSatisfied) \\/ -I)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied/\\compNoReqCommSatisfied/\\I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compAllReqCommSatisfied\",\"compNoReqCommSatisfied\",\"I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compAllReqCommSatisfied` AS tgt
                          FROM `Computer` AS isect0, `Computer` AS isect1, `Computer` AS isect2
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`compAllReqCommSatisfied` = isect1.`compNoReqCommSatisfied`) AND isect0.`Computer` = isect0.`compAllReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent computer properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Computer status \'Green\'' =>
        array ( 'name' => 'Computer status \'Green\''
              , 'ruleAdl' => 'I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\compAllReqCommSatisfied |- compStatus;\'Green\';compStatus~'
              , 'origin' => 'line 102, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\compAllReqCommSatisfied) \\/ compStatus;\'Green\';compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\compAllReqCommSatisfied/\\-(compStatus;\'Green\';compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"compRequiresComm\",\"compRouter;compRouter~\",\"compAllReqCommSatisfied\",\"-(compStatus;\'Green\';compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0, `Computer` AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter\",\"compRouter~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                 FROM `compRouter` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect2, `Computer` AS isect3
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Computer1` = isect1.`compRequiresComm`) AND (isect0.`Computer` = isect2.`Computer` AND isect0.`Computer1` = isect2.`Computer1`) AND (isect0.`Computer` = isect3.`Computer` AND isect0.`Computer1` = isect3.`compAllReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"\'Green\'\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`compStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Computer status \'Yellow\'' =>
        array ( 'name' => 'Computer status \'Yellow\''
              , 'ruleAdl' => 'I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\-compAllReqCommSatisfied/\\-compNoReqCommSatisfied |- compStatus;\'Yellow\';compStatus~'
              , 'origin' => 'line 107, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\-compAllReqCommSatisfied/\\-compNoReqCommSatisfied) \\/ compStatus;\'Yellow\';compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\-compAllReqCommSatisfied/\\-compNoReqCommSatisfied/\\-(compStatus;\'Yellow\';compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"compRequiresComm\",\"compRouter;compRouter~\",\"-compAllReqCommSatisfied\",\"-compNoReqCommSatisfied\",\"-(compStatus;\'Yellow\';compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0, `Computer` AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter\",\"compRouter~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                 FROM `compRouter` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect2
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Computer1` = isect1.`compRequiresComm`) AND (isect0.`Computer` = isect2.`Computer` AND isect0.`Computer1` = isect2.`Computer1`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`compAllReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`compNoReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"\'Yellow\'\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`compStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Computer status \'Red\'' =>
        array ( 'name' => 'Computer status \'Red\''
              , 'ruleAdl' => 'I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\compNoReqCommSatisfied |- compStatus;\'Red\';compStatus~'
              , 'origin' => 'line 112, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\compNoReqCommSatisfied) \\/ compStatus;\'Red\';compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\compRequiresComm/\\compRouter;compRouter~/\\compNoReqCommSatisfied/\\-(compStatus;\'Red\';compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"compRequiresComm\",\"compRouter;compRouter~\",\"compNoReqCommSatisfied\",\"-(compStatus;\'Red\';compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0, `Computer` AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter\",\"compRouter~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                 FROM `compRouter` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect2, `Computer` AS isect3
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Computer1` = isect1.`compRequiresComm`) AND (isect0.`Computer` = isect2.`Computer` AND isect0.`Computer1` = isect2.`Computer1`) AND (isect0.`Computer` = isect3.`Computer` AND isect0.`Computer1` = isect3.`compNoReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"\'Red\'\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`compStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Computer status \'Black\'' =>
        array ( 'name' => 'Computer status \'Black\''
              , 'ruleAdl' => 'I[Computer]/\\compRequiresComm/\\-(compRouter;compRouter~) |- compStatus;\'Black\';compStatus~'
              , 'origin' => 'line 117, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I[Computer]/\\compRequiresComm/\\-(compRouter;compRouter~)) \\/ compStatus;\'Black\';compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\compRequiresComm/\\-(compRouter;compRouter~)/\\-(compStatus;\'Black\';compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"compRequiresComm\",\"-(compRouter;compRouter~)\",\"-(compStatus;\'Black\';compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0, `Computer` AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Computer1` = isect1.`compRequiresComm`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"compRouter~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `Router`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"\'Black\'\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  ( SELECT \'Black\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`compStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Black')
                    )
              )
    , 'Computer status \'Blue\'' =>
        array ( 'name' => 'Computer status \'Blue\''
              , 'ruleAdl' => 'I[Computer]/\\-compRequiresComm/\\compRouter;compRouter~ |- compStatus;\'Blue\';compStatus~'
              , 'origin' => 'line 122, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I[Computer]/\\-compRequiresComm/\\compRouter;compRouter~) \\/ compStatus;\'Blue\';compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\-compRequiresComm/\\compRouter;compRouter~/\\-(compStatus;\'Blue\';compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"-compRequiresComm\",\"compRouter;compRouter~\",\"-(compStatus;\'Blue\';compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRouter\",\"compRouter~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                 FROM `compRouter` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `Router`
                                        FROM `compRouter`
                                        WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Computer1` = isect1.`Computer1`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`compRequiresComm`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"\'Blue\'\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  ( SELECT \'Blue\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`compStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Computer status \'White\'' =>
        array ( 'name' => 'Computer status \'White\''
              , 'ruleAdl' => 'I[Computer]/\\-compRequiresComm/\\-(compRouter;compRouter~) |- compStatus;\'White\';compStatus~'
              , 'origin' => 'line 127, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(I[Computer]/\\-compRequiresComm/\\-(compRouter;compRouter~)) \\/ compStatus;\'White\';compStatus~)
              // <=> { De Morgan }
              //     I[Computer]/\\-compRequiresComm/\\-(compRouter;compRouter~)/\\-(compStatus;\'White\';compStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Computer]\",\"-compRequiresComm\",\"-(compRouter;compRouter~)\",\"-(compStatus;\'White\';compStatus~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Computer`, `Computer` AS `Computer1`
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Computer` AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`compRequiresComm`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compRouter\",\"compRouter~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                             FROM `compRouter` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `Router`
                                                    FROM `compRouter`
                                                    WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Router`=ECps1.`Router`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compStatus\",\"\'White\'\",\"compStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps2.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  ( SELECT \'White\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compStatus`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`compStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`compStatus`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer1`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'SvcComponent status integrity check' =>
        array ( 'name' => 'SvcComponent status integrity check'
              , 'ruleAdl' => 'scAllReqCommSatisfied/\\scNoReqCommSatisfied |- -I'
              , 'origin' => 'line 147, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => 'SvcComponent status integrity check'
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scAllReqCommSatisfied/\\scNoReqCommSatisfied) \\/ -I)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied/\\scNoReqCommSatisfied/\\I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scAllReqCommSatisfied\",\"scNoReqCommSatisfied\",\"I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scAllReqCommSatisfied` AS tgt
                          FROM `SvcComponent` AS isect0, `SvcComponent` AS isect1, `SvcComponent` AS isect2
                          WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`scAllReqCommSatisfied` = isect1.`scNoReqCommSatisfied`) AND isect0.`SvcComponent` = isect0.`scAllReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent service component properties')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    )
              )
    , 'SvcComponent status \'Green\'' =>
        array ( 'name' => 'SvcComponent status \'Green\''
              , 'ruleAdl' => 'I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\scAllReqCommSatisfied |- scStatus;\'Green\';scStatus~'
              , 'origin' => 'line 152, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\scAllReqCommSatisfied) \\/ scStatus;\'Green\';scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\scAllReqCommSatisfied/\\-(scStatus;\'Green\';scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"scReqCommWith;scReqCommWith~\",\"scDeployedOn;scDeployedOn~\",\"scAllReqCommSatisfied\",\"-(scStatus;\'Green\';scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                 FROM `scDeployedOn` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect2, `SvcComponent` AS isect3
                          WHERE (isect0.`SvcComponent` = isect1.`sSvcComponent` AND isect0.`SvcComponent1` = isect1.`sSvcComponent1`) AND (isect0.`SvcComponent` = isect2.`SvcComponent` AND isect0.`SvcComponent1` = isect2.`SvcComponent1`) AND (isect0.`SvcComponent` = isect3.`SvcComponent` AND isect0.`SvcComponent1` = isect3.`scAllReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"\'Green\'\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`scStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'SvcComponent status \'Yellow\'' =>
        array ( 'name' => 'SvcComponent status \'Yellow\''
              , 'ruleAdl' => 'I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\-scAllReqCommSatisfied/\\-scNoReqCommSatisfied |- scStatus;\'Yellow\';scStatus~'
              , 'origin' => 'line 157, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\-scAllReqCommSatisfied/\\-scNoReqCommSatisfied) \\/ scStatus;\'Yellow\';scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\-scAllReqCommSatisfied/\\-scNoReqCommSatisfied/\\-(scStatus;\'Yellow\';scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"scReqCommWith;scReqCommWith~\",\"scDeployedOn;scDeployedOn~\",\"-scAllReqCommSatisfied\",\"-scNoReqCommSatisfied\",\"-(scStatus;\'Yellow\';scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                 FROM `scDeployedOn` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect2
                          WHERE (isect0.`SvcComponent` = isect1.`sSvcComponent` AND isect0.`SvcComponent1` = isect1.`sSvcComponent1`) AND (isect0.`SvcComponent` = isect2.`SvcComponent` AND isect0.`SvcComponent1` = isect2.`SvcComponent1`) AND NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`scAllReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`scNoReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"\'Yellow\'\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`scStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'SvcComponent status \'Red\'' =>
        array ( 'name' => 'SvcComponent status \'Red\''
              , 'ruleAdl' => 'I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\scNoReqCommSatisfied |- scStatus;\'Red\';scStatus~'
              , 'origin' => 'line 162, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\scNoReqCommSatisfied) \\/ scStatus;\'Red\';scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\scDeployedOn;scDeployedOn~/\\scNoReqCommSatisfied/\\-(scStatus;\'Red\';scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"scReqCommWith;scReqCommWith~\",\"scDeployedOn;scDeployedOn~\",\"scNoReqCommSatisfied\",\"-(scStatus;\'Red\';scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                 FROM `scDeployedOn` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect2, `SvcComponent` AS isect3
                          WHERE (isect0.`SvcComponent` = isect1.`sSvcComponent` AND isect0.`SvcComponent1` = isect1.`sSvcComponent1`) AND (isect0.`SvcComponent` = isect2.`SvcComponent` AND isect0.`SvcComponent1` = isect2.`SvcComponent1`) AND (isect0.`SvcComponent` = isect3.`SvcComponent` AND isect0.`SvcComponent1` = isect3.`scNoReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"\'Red\'\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`scStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'SvcComponent status \'Black\'' =>
        array ( 'name' => 'SvcComponent status \'Black\''
              , 'ruleAdl' => 'I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\-(scDeployedOn;scDeployedOn~) |- scStatus;\'Black\';scStatus~'
              , 'origin' => 'line 167, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\-(scDeployedOn;scDeployedOn~)) \\/ scStatus;\'Black\';scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\scReqCommWith;scReqCommWith~/\\-(scDeployedOn;scDeployedOn~)/\\-(scStatus;\'Black\';scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"scReqCommWith;scReqCommWith~\",\"-(scDeployedOn;scDeployedOn~)\",\"-(scStatus;\'Black\';scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`sSvcComponent` AND isect0.`SvcComponent1` = isect1.`sSvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `scDeployedOn` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Computer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"\'Black\'\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  ( SELECT \'Black\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`scStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Black')
                    )
              )
    , 'SvcComponent status \'Blue\'' =>
        array ( 'name' => 'SvcComponent status \'Blue\''
              , 'ruleAdl' => 'I[SvcComponent]/\\-(scReqCommWith;scReqCommWith~)/\\scDeployedOn;scDeployedOn~ |- scStatus;\'Blue\';scStatus~'
              , 'origin' => 'line 172, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\-(scReqCommWith;scReqCommWith~)/\\scDeployedOn;scDeployedOn~) \\/ scStatus;\'Blue\';scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\-(scReqCommWith;scReqCommWith~)/\\scDeployedOn;scDeployedOn~/\\-(scStatus;\'Blue\';scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"-(scReqCommWith;scReqCommWith~)\",\"scDeployedOn;scDeployedOn~\",\"-(scStatus;\'Blue\';scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                 FROM `scDeployedOn` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                        FROM `scDeployedOn`
                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`SvcComponent1` = isect1.`SvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                             
                                             SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                             FROM `scReqCommWith` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                                    FROM `scReqCommWith`
                                                    WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`sSvcComponent` AND isect0.`SvcComponent1`=cp.`sSvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"\'Blue\'\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  ( SELECT \'Blue\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`scStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'SvcComponent status \'White\'' =>
        array ( 'name' => 'SvcComponent status \'White\''
              , 'ruleAdl' => 'I[SvcComponent]/\\-(scReqCommWith;scReqCommWith~)/\\-(scDeployedOn;scDeployedOn~) |- scStatus;\'White\';scStatus~'
              , 'origin' => 'line 177, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\-(scReqCommWith;scReqCommWith~)/\\-(scDeployedOn;scDeployedOn~)) \\/ scStatus;\'White\';scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent]/\\-(scReqCommWith;scReqCommWith~)/\\-(scDeployedOn;scDeployedOn~)/\\-(scStatus;\'White\';scStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"-(scReqCommWith;scReqCommWith~)\",\"-(scDeployedOn;scDeployedOn~)\",\"-(scStatus;\'White\';scStatus~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                             
                                             SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                             FROM `scReqCommWith` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                                    FROM `scReqCommWith`
                                                    WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`sSvcComponent` AND isect0.`SvcComponent1`=cp.`sSvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scDeployedOn\",\"scDeployedOn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `scDeployedOn` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Computer`
                                                    FROM `scDeployedOn`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scStatus\",\"\'White\'\",\"scStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps2.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  ( SELECT \'White\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scStatus`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`scStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`scStatus`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'Service status integrity check' =>
        array ( 'name' => 'Service status integrity check'
              , 'ruleAdl' => 'svcAllSvcCompReqsSatisfied/\\svcNoSvcCompReqsSatisfied |- -I'
              , 'origin' => 'line 194, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => 'Service status integrity check'
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcAllSvcCompReqsSatisfied/\\svcNoSvcCompReqsSatisfied) \\/ -I)
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied/\\svcNoSvcCompReqsSatisfied/\\I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcAllSvcCompReqsSatisfied\",\"svcNoSvcCompReqsSatisfied\",\"I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcAllSvcCompReqsSatisfied` AS tgt
                          FROM `Service` AS isect0, `Service` AS isect1, `Service` AS isect2
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`svcAllSvcCompReqsSatisfied` = isect1.`svcNoSvcCompReqsSatisfied`) AND isect0.`Service` = isect0.`svcAllSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcAllSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent service properties for ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '(')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ')')
                    )
              )
    , 'Service status \'Green\'' =>
        array ( 'name' => 'Service status \'Green\''
              , 'ruleAdl' => 'I[Service]/\\svcAllSvcCompReqsSatisfied |- svcStatus;\'Green\';svcStatus~'
              , 'origin' => 'line 199, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(I[Service]/\\svcAllSvcCompReqsSatisfied) \\/ svcStatus;\'Green\';svcStatus~)
              // <=> { De Morgan }
              //     I[Service]/\\svcAllSvcCompReqsSatisfied/\\-(svcStatus;\'Green\';svcStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Service]\",\"svcAllSvcCompReqsSatisfied\",\"-(svcStatus;\'Green\';svcStatus~)\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Service`, `Service` AS `Service1`
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                               ) AS isect0, `Service` AS isect1
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`Service1` = isect1.`svcAllSvcCompReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"svcStatus\",\"\'Green\'\",\"svcStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Service`, ECps2.`Service` AS `Service1`
                                             FROM `Service` AS ECps0,
                                                  ( SELECT \'Green\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service`, `svcStatus`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`svcStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`svcStatus`
                                           ) AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Service status \'Yellow\'' =>
        array ( 'name' => 'Service status \'Yellow\''
              , 'ruleAdl' => 'I[Service]/\\-svcAllSvcCompReqsSatisfied/\\-svcNoSvcCompReqsSatisfied |- svcStatus;\'Yellow\';svcStatus~'
              , 'origin' => 'line 204, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(I[Service]/\\-svcAllSvcCompReqsSatisfied/\\-svcNoSvcCompReqsSatisfied) \\/ svcStatus;\'Yellow\';svcStatus~)
              // <=> { De Morgan }
              //     I[Service]/\\-svcAllSvcCompReqsSatisfied/\\-svcNoSvcCompReqsSatisfied/\\-(svcStatus;\'Yellow\';svcStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Service]\",\"-svcAllSvcCompReqsSatisfied\",\"-svcNoSvcCompReqsSatisfied\",\"-(svcStatus;\'Yellow\';svcStatus~)\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Service`, `Service` AS `Service1`
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Service` AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`svcAllSvcCompReqsSatisfied`) AND NOT EXISTS (SELECT * FROM `Service` AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`svcNoSvcCompReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"svcStatus\",\"\'Yellow\'\",\"svcStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Service`, ECps2.`Service` AS `Service1`
                                             FROM `Service` AS ECps0,
                                                  ( SELECT \'Yellow\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service`, `svcStatus`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`svcStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`svcStatus`
                                           ) AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Service status \'Red\'' =>
        array ( 'name' => 'Service status \'Red\''
              , 'ruleAdl' => 'I[Service]/\\svcNoSvcCompReqsSatisfied |- svcStatus;\'Red\';svcStatus~'
              , 'origin' => 'line 209, file "..\\\\CyberSA\\\\CSA_StatusRules.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(I[Service]/\\svcNoSvcCompReqsSatisfied) \\/ svcStatus;\'Red\';svcStatus~)
              // <=> { De Morgan }
              //     I[Service]/\\svcNoSvcCompReqsSatisfied/\\-(svcStatus;\'Red\';svcStatus~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Service]\",\"svcNoSvcCompReqsSatisfied\",\"-(svcStatus;\'Red\';svcStatus~)\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Service`, `Service` AS `Service1`
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL
                               ) AS isect0, `Service` AS isect1
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`Service1` = isect1.`svcNoSvcCompReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"svcStatus\",\"\'Red\'\",\"svcStatus~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Service`, ECps2.`Service` AS `Service1`
                                             FROM `Service` AS ECps0,
                                                  ( SELECT \'Red\' AS `MpStatus` ) AS ECps1,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service`, `svcStatus`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                                  ) AS ECps2
                                             WHERE ECps0.`svcStatus`=ECps1.`MpStatus`
                                               AND ECps1.`MpStatus`=ECps2.`svcStatus`
                                           ) AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service1`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Yes/No answer integrity' =>
        array ( 'name' => 'Yes/No answer integrity'
              , 'ruleAdl' => 'I[Yes/No answer] |- \'Yes\' \\/ \'No\''
              , 'origin' => 'line 31, file "CSA_Op.adl"'
              , 'meaning' => 'A Yes/No answer can only have the values \'Yes\' or \'No\''
              , 'message' => 'You may only specify \'Yes\' or \'No\' as an answer.'
              , 'srcConcept' => 'Yes/No answer'
              , 'tgtConcept' => 'Yes/No answer'
              // original expression:
              //     -(-I[Yes/No answer] \\/ \'Yes\' \\/ \'No\')
              // <=> { De Morgan }
              //     I[Yes/No answer]/\\-\'Yes\'/\\-\'No\'
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Yes/No answer]\",\"-\'Yes\'\",\"-\'No\'\"] */
                          SELECT DISTINCT isect0.`Yes/No answer` AS src, isect0.`Yes/No answer1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Yes/No answer`, `Yes/No answer` AS `Yes/No answer1`
                                 FROM `Yes/No answer`
                                 WHERE `Yes/No answer` IS NOT NULL AND `Yes/No answer` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT \'Yes\' AS `MpYes/No answer` ) AS cp
                                      WHERE isect0.`Yes/No answer`=cp.`MpYes/No answer` AND isect0.`Yes/No answer1`=cp.`MpYes/No answer`) AND NOT EXISTS (SELECT * FROM ( SELECT \'No\' AS `MpYes/No answer` ) AS cp
                                      WHERE isect0.`Yes/No answer`=cp.`MpYes/No answer` AND isect0.`Yes/No answer1`=cp.`MpYes/No answer`) AND isect0.`Yes/No answer` IS NOT NULL AND isect0.`Yes/No answer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'Activity executor must exist' =>
        array ( 'name' => 'Activity executor must exist'
              , 'ruleAdl' => 'I[Activity] |- actExecutingOU;actExecutingOU~'
              , 'origin' => 'line 41, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'For every activity, an OrgUnit must be appointed that executes te activity'
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-I[Activity] \\/ actExecutingOU;actExecutingOU~)
              // <=> { De Morgan }
              //     I[Activity]/\\-(actExecutingOU;actExecutingOU~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Activity]\",\"-(actExecutingOU;actExecutingOU~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Activity`, `Activity` AS `Activity1`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actExecutingOU\",\"actExecutingOU~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actExecutingOU`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'Activity plan must exist' =>
        array ( 'name' => 'Activity plan must exist'
              , 'ruleAdl' => 'I[Activity] |- actPlan;actPlan~'
              , 'origin' => 'line 46, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'For every activity, a Plan must exist that motivates doing the activity'
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-I[Activity] \\/ actPlan;actPlan~)
              // <=> { De Morgan }
              //     I[Activity]/\\-(actPlan;actPlan~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Activity]\",\"-(actPlan;actPlan~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Activity`, `Activity` AS `Activity1`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actPlan\",\"actPlan~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actPlan`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`actPlan`=ECps1.`actPlan`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity1`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'Router naming integrity' =>
        array ( 'name' => 'Router naming integrity'
              , 'ruleAdl' => 'routerName~;routerName |- I[RouterName]'
              , 'origin' => 'line 36, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Friendly names for routers must be unique.'
              , 'message' => ''
              , 'srcConcept' => 'RouterName'
              , 'tgtConcept' => 'RouterName'
              // original expression:
              //     -(-(routerName~;routerName) \\/ I[RouterName])
              // <=> { De Morgan }
              //     routerName~;routerName/\\-I[RouterName]
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerName~;routerName\",\"-I[RouterName]\"] */
                          SELECT DISTINCT isect0.`routerName` AS src, isect0.`routerName1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerName~\",\"routerName\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerName`, ECps1.`routerName` AS `routerName1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerName`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: ETyp x _
                                                ETyp ( \"I\" ) _ */
                                             SELECT DISTINCT `RouterName`, `RouterName` AS `RouterName1`
                                             FROM `RouterName`
                                             WHERE `RouterName` IS NOT NULL AND `RouterName` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`routerName`=cp.`RouterName` AND isect0.`routerName1`=cp.`RouterName1`) AND isect0.`routerName` IS NOT NULL AND isect0.`routerName1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is already an router called \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'RouterName'
                            , 'expSQL' =>
                                'SELECT DISTINCT `RouterName` AS src, `RouterName` AS tgt
                                 FROM `RouterName`
                                 WHERE `RouterName` IS NOT NULL AND `RouterName` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\'; please choose another name.')
                    )
              )
    , 'Router network integrity' =>
        array ( 'name' => 'Router network integrity'
              , 'ruleAdl' => 'I[Router]/\\rrtDirect;rrtDirect~ |- routerNW;routerNW~'
              , 'origin' => 'line 40, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Only routers that are part of a network may have routes'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(I[Router]/\\rrtDirect;rrtDirect~) \\/ routerNW;routerNW~)
              // <=> { De Morgan }
              //     I[Router]/\\rrtDirect;rrtDirect~/\\-(routerNW;routerNW~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Router]\",\"rrtDirect;rrtDirect~\",\"-(routerNW;routerNW~)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Router`, `Router` AS `Router1`
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrtDirect\",\"rrtDirect~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sRouter`, ECps1.`sRouter` AS `sRouter1`
                                 FROM `rrtDirect` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sRouter`, `tRouter`
                                        FROM `rrtDirect`
                                        WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tRouter`=ECps1.`tRouter`
                               ) AS isect1
                          WHERE (isect0.`Router` = isect1.`sRouter` AND isect0.`Router1` = isect1.`sRouter1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerNW\",\"routerNW~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerNW`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router1`=cp.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is not part of a network, and hence may not have routes.')
                    )
              )
    , 'Computer naming integrity' =>
        array ( 'name' => 'Computer naming integrity'
              , 'ruleAdl' => 'compName~;compName |- I[ComputerName]'
              , 'origin' => 'line 59, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Friendly names for computers must be unique.'
              , 'message' => ''
              , 'srcConcept' => 'ComputerName'
              , 'tgtConcept' => 'ComputerName'
              // original expression:
              //     -(-(compName~;compName) \\/ I[ComputerName])
              // <=> { De Morgan }
              //     compName~;compName/\\-I[ComputerName]
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compName~;compName\",\"-I[ComputerName]\"] */
                          SELECT DISTINCT isect0.`compName` AS src, isect0.`compName1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compName~\",\"compName\"] */
                                 
                                 SELECT DISTINCT ECps0.`compName`, ECps1.`compName` AS `compName1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compName`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: ETyp x _
                                                ETyp ( \"I\" ) _ */
                                             SELECT DISTINCT `ComputerName`, `ComputerName` AS `ComputerName1`
                                             FROM `ComputerName`
                                             WHERE `ComputerName` IS NOT NULL AND `ComputerName` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`compName`=cp.`ComputerName` AND isect0.`compName1`=cp.`ComputerName1`) AND isect0.`compName` IS NOT NULL AND isect0.`compName1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is already an computer called \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ComputerName'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ComputerName` AS src, `ComputerName` AS tgt
                                 FROM `ComputerName`
                                 WHERE `ComputerName` IS NOT NULL AND `ComputerName` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\'; please choose another name.')
                    )
              )
    , 'Service - component integrity' =>
        array ( 'name' => 'Service - component integrity'
              , 'ruleAdl' => 'I[SvcComponent]/\\-(scImplements;scImplements~) |- -(scReqCommWith;scReqCommWith~)'
              , 'origin' => 'line 86, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Only service components that are part of a service may send messages'
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(I[SvcComponent]/\\-(scImplements;scImplements~)) \\/ -(scReqCommWith;scReqCommWith~))
              // <=> { De Morgan }
              //     I[SvcComponent]/\\-(scImplements;scImplements~)/\\scReqCommWith;scReqCommWith~
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[SvcComponent]\",\"-(scImplements;scImplements~)\",\"scReqCommWith;scReqCommWith~\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `SvcComponent`, `SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scReqCommWith\",\"scReqCommWith~\"] */
                                 
                                 SELECT DISTINCT ECps0.`sSvcComponent`, ECps1.`sSvcComponent` AS `sSvcComponent1`
                                 FROM `scReqCommWith` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `sSvcComponent`, `tSvcComponent`
                                        FROM `scReqCommWith`
                                        WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`tSvcComponent`=ECps1.`tSvcComponent`
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`sSvcComponent` AND isect0.`SvcComponent1` = isect1.`sSvcComponent1`) AND NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scImplements\",\"scImplements~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `scImplements` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `Service`
                                                    FROM `scImplements`
                                                    WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Service`=ECps1.`Service`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent1`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'SvcComponent ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is not part of a service, and hence may not send messages.')
                    )
              )
    , 'SvcComponent naming integrity' =>
        array ( 'name' => 'SvcComponent naming integrity'
              , 'ruleAdl' => 'scName~;scName |- I[SvcComponentName]'
              , 'origin' => 'line 90, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Friendly names for service components must be unique.'
              , 'message' => ''
              , 'srcConcept' => 'SvcComponentName'
              , 'tgtConcept' => 'SvcComponentName'
              // original expression:
              //     -(-(scName~;scName) \\/ I[SvcComponentName])
              // <=> { De Morgan }
              //     scName~;scName/\\-I[SvcComponentName]
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scName~;scName\",\"-I[SvcComponentName]\"] */
                          SELECT DISTINCT isect0.`scName` AS src, isect0.`scName1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scName~\",\"scName\"] */
                                 
                                 SELECT DISTINCT ECps0.`scName`, ECps1.`scName` AS `scName1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scName`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: ETyp x _
                                                ETyp ( \"I\" ) _ */
                                             SELECT DISTINCT `SvcComponentName`, `SvcComponentName` AS `SvcComponentName1`
                                             FROM `SvcComponentName`
                                             WHERE `SvcComponentName` IS NOT NULL AND `SvcComponentName` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`scName`=cp.`SvcComponentName` AND isect0.`scName1`=cp.`SvcComponentName1`) AND isect0.`scName` IS NOT NULL AND isect0.`scName1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is already a service component called \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponentName'
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponentName` AS src, `SvcComponentName` AS tgt
                                 FROM `SvcComponentName`
                                 WHERE `SvcComponentName` IS NOT NULL AND `SvcComponentName` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\'; please choose another name.')
                    )
              )
    , 'uni planCmpStat' =>
        array ( 'name' => 'uni planCmpStat'
              , 'ruleAdl' => 'planCmpStat~;planCmpStat |- I'
              , 'origin' => 'line 25, file "CSA_Op Status.adl"'
              , 'meaning' => 'planCmpStat[Plan\\*Status] is univalent'
              , 'message' => 'planCmpStat[Plan\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(planCmpStat~;planCmpStat) \\/ I)
              // <=> { De Morgan }
              //     planCmpStat~;planCmpStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"planCmpStat~;planCmpStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`planCmpStat` AS src, isect0.`planCmpStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planCmpStat~\",\"planCmpStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`planCmpStat`, ECps1.`planCmpStat` AS `planCmpStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `planCmpStat`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      `Plan` AS ECps1
                                 WHERE ECps0.`Plan`=ECps1.`Plan`
                               ) AS isect0
                          WHERE isect0.`planCmpStat` <> isect0.`planCmpStat1` AND isect0.`planCmpStat` IS NOT NULL AND isect0.`planCmpStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym atStatusIsGreen' =>
        array ( 'name' => 'sym atStatusIsGreen'
              , 'ruleAdl' => 'atStatusIsGreen = atStatusIsGreen~'
              , 'origin' => 'line 43, file "CSA_Op Status.adl"'
              , 'meaning' => 'atStatusIsGreen[ActivityType] is symmetrisch.'
              , 'message' => 'atStatusIsGreen[ActivityType] is niet symmetrisch.'
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -((-atStatusIsGreen \\/ atStatusIsGreen)/\\(-atStatusIsGreen \\/ atStatusIsGreen))
              // <=> { De Morgan }
              //     -(-atStatusIsGreen \\/ atStatusIsGreen) \\/ -(-atStatusIsGreen \\/ atStatusIsGreen)
              // <=> { -(-atStatusIsGreen \\/ atStatusIsGreen)\\/-(-atStatusIsGreen \\/ atStatusIsGreen) = -(-atStatusIsGreen \\/ atStatusIsGreen) }
              //     -(-atStatusIsGreen \\/ atStatusIsGreen)
              // <=> { De Morgan }
              //     atStatusIsGreen/\\-atStatusIsGreen
              // <=> { atStatusIsGreen/\\-atStatusIsGreen = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy atStatusIsGreen' =>
        array ( 'name' => 'asy atStatusIsGreen'
              , 'ruleAdl' => 'atStatusIsGreen~/\\atStatusIsGreen |- I'
              , 'origin' => 'line 43, file "CSA_Op Status.adl"'
              , 'meaning' => 'atStatusIsGreen[ActivityType] is antisymmetrisch.'
              , 'message' => 'atStatusIsGreen[ActivityType] is niet antisymmetrisch.'
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(atStatusIsGreen/\\atStatusIsGreen) \\/ I)
              // <=> { De Morgan }
              //     atStatusIsGreen/\\atStatusIsGreen/\\-I
              // <=> { atStatusIsGreen/\\atStatusIsGreen = atStatusIsGreen }
              //     atStatusIsGreen/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atStatusIsGreen\",\"-I\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`atStatusIsGreen` AS tgt
                          FROM `ActivityType` AS isect0
                          WHERE isect0.`ActivityType` <> isect0.`atStatusIsGreen` AND isect0.`ActivityType` IS NOT NULL AND isect0.`atStatusIsGreen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni atStatusIsGreen' =>
        array ( 'name' => 'uni atStatusIsGreen'
              , 'ruleAdl' => 'atStatusIsGreen~;atStatusIsGreen |- I'
              , 'origin' => 'line 43, file "CSA_Op Status.adl"'
              , 'meaning' => 'atStatusIsGreen[ActivityType\\*ActivityType] is univalent'
              , 'message' => 'atStatusIsGreen[ActivityType\\*ActivityType] is niet univalent'
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(atStatusIsGreen;atStatusIsGreen) \\/ I)
              // <=> { De Morgan }
              //     atStatusIsGreen;atStatusIsGreen/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atStatusIsGreen;atStatusIsGreen\",\"-I\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`atStatusIsGreen` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atStatusIsGreen\",\"atStatusIsGreen\"] */
                                 
                                 SELECT DISTINCT ECps0.`ActivityType`, ECps1.`atStatusIsGreen`
                                 FROM `ActivityType` AS ECps0,
                                      `ActivityType` AS ECps1
                                 WHERE ECps0.`atStatusIsGreen`=ECps1.`ActivityType`
                               ) AS isect0
                          WHERE isect0.`ActivityType` <> isect0.`atStatusIsGreen` AND isect0.`ActivityType` IS NOT NULL AND isect0.`atStatusIsGreen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj atStatusIsGreen' =>
        array ( 'name' => 'inj atStatusIsGreen'
              , 'ruleAdl' => 'atStatusIsGreen;atStatusIsGreen~ |- I'
              , 'origin' => 'line 43, file "CSA_Op Status.adl"'
              , 'meaning' => 'atStatusIsGreen[ActivityType\\*ActivityType] is injectief'
              , 'message' => 'atStatusIsGreen[ActivityType\\*ActivityType] is niet injectief'
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(atStatusIsGreen;atStatusIsGreen) \\/ I)
              // <=> { De Morgan }
              //     atStatusIsGreen;atStatusIsGreen/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atStatusIsGreen;atStatusIsGreen\",\"-I\"] */
                          SELECT DISTINCT isect0.`ActivityType` AS src, isect0.`atStatusIsGreen` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atStatusIsGreen\",\"atStatusIsGreen\"] */
                                 
                                 SELECT DISTINCT ECps0.`ActivityType`, ECps1.`atStatusIsGreen`
                                 FROM `ActivityType` AS ECps0,
                                      `ActivityType` AS ECps1
                                 WHERE ECps0.`atStatusIsGreen`=ECps1.`ActivityType`
                               ) AS isect0
                          WHERE isect0.`ActivityType` <> isect0.`atStatusIsGreen` AND isect0.`ActivityType` IS NOT NULL AND isect0.`atStatusIsGreen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actCmpStat' =>
        array ( 'name' => 'uni actCmpStat'
              , 'ruleAdl' => 'actCmpStat~;actCmpStat |- I'
              , 'origin' => 'line 97, file "CSA_Op Status.adl"'
              , 'meaning' => 'actCmpStat[Activity\\*Status] is univalent'
              , 'message' => 'actCmpStat[Activity\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(actCmpStat~;actCmpStat) \\/ I)
              // <=> { De Morgan }
              //     actCmpStat~;actCmpStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actCmpStat~;actCmpStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`actCmpStat` AS src, isect0.`actCmpStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actCmpStat~\",\"actCmpStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`actCmpStat`, ECps1.`actCmpStat` AS `actCmpStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actCmpStat`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actCmpStat` <> isect0.`actCmpStat1` AND isect0.`actCmpStat` IS NOT NULL AND isect0.`actCmpStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni ouCmpStat' =>
        array ( 'name' => 'uni ouCmpStat'
              , 'ruleAdl' => 'ouCmpStat~;ouCmpStat |- I'
              , 'origin' => 'line 106, file "CSA_Op Status.adl"'
              , 'meaning' => 'ouCmpStat[OrgUnit\\*Status] is univalent'
              , 'message' => 'ouCmpStat[OrgUnit\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(ouCmpStat~;ouCmpStat) \\/ I)
              // <=> { De Morgan }
              //     ouCmpStat~;ouCmpStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ouCmpStat~;ouCmpStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`ouCmpStat` AS src, isect0.`ouCmpStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ouCmpStat~\",\"ouCmpStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`ouCmpStat`, ECps1.`ouCmpStat` AS `ouCmpStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit`, `ouCmpStat`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect0
                          WHERE isect0.`ouCmpStat` <> isect0.`ouCmpStat1` AND isect0.`ouCmpStat` IS NOT NULL AND isect0.`ouCmpStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scCmpStat' =>
        array ( 'name' => 'uni scCmpStat'
              , 'ruleAdl' => 'scCmpStat~;scCmpStat |- I'
              , 'origin' => 'line 115, file "CSA_Op Status.adl"'
              , 'meaning' => 'scCmpStat[SvcComponent\\*Status] is univalent'
              , 'message' => 'scCmpStat[SvcComponent\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(scCmpStat~;scCmpStat) \\/ I)
              // <=> { De Morgan }
              //     scCmpStat~;scCmpStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scCmpStat~;scCmpStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`scCmpStat` AS src, isect0.`scCmpStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scCmpStat~\",\"scCmpStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`scCmpStat`, ECps1.`scCmpStat` AS `scCmpStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scCmpStat`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`scCmpStat` <> isect0.`scCmpStat1` AND isect0.`scCmpStat` IS NOT NULL AND isect0.`scCmpStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compCmpStat' =>
        array ( 'name' => 'uni compCmpStat'
              , 'ruleAdl' => 'compCmpStat~;compCmpStat |- I'
              , 'origin' => 'line 124, file "CSA_Op Status.adl"'
              , 'meaning' => 'compCmpStat[Computer\\*Status] is univalent'
              , 'message' => 'compCmpStat[Computer\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(compCmpStat~;compCmpStat) \\/ I)
              // <=> { De Morgan }
              //     compCmpStat~;compCmpStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compCmpStat~;compCmpStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`compCmpStat` AS src, isect0.`compCmpStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compCmpStat~\",\"compCmpStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`compCmpStat`, ECps1.`compCmpStat` AS `compCmpStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compCmpStat`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compCmpStat` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compCmpStat` <> isect0.`compCmpStat1` AND isect0.`compCmpStat` IS NOT NULL AND isect0.`compCmpStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym nwAllCompCommReqsSatisfied' =>
        array ( 'name' => 'sym nwAllCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied~'
              , 'origin' => 'line 27, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwAllCompCommReqsSatisfied[Network] is symmetrisch.'
              , 'message' => 'nwAllCompCommReqsSatisfied[Network] is niet symmetrisch.'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -((-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied)/\\(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied))
              // <=> { De Morgan }
              //     -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied) \\/ -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied)
              // <=> { -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied)\\/-(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied) = -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied) }
              //     -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied/\\-nwAllCompCommReqsSatisfied
              // <=> { nwAllCompCommReqsSatisfied/\\-nwAllCompCommReqsSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy nwAllCompCommReqsSatisfied' =>
        array ( 'name' => 'asy nwAllCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwAllCompCommReqsSatisfied~/\\nwAllCompCommReqsSatisfied |- I'
              , 'origin' => 'line 27, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwAllCompCommReqsSatisfied[Network] is antisymmetrisch.'
              , 'message' => 'nwAllCompCommReqsSatisfied[Network] is niet antisymmetrisch.'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(nwAllCompCommReqsSatisfied/\\nwAllCompCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied/\\nwAllCompCommReqsSatisfied/\\-I
              // <=> { nwAllCompCommReqsSatisfied/\\nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied }
              //     nwAllCompCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwAllCompCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwAllCompCommReqsSatisfied` AS tgt
                          FROM `Network` AS isect0
                          WHERE isect0.`Network` <> isect0.`nwAllCompCommReqsSatisfied` AND isect0.`Network` IS NOT NULL AND isect0.`nwAllCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni nwAllCompCommReqsSatisfied' =>
        array ( 'name' => 'uni nwAllCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied |- I'
              , 'origin' => 'line 27, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwAllCompCommReqsSatisfied[Network\\*Network] is univalent'
              , 'message' => 'nwAllCompCommReqsSatisfied[Network\\*Network] is niet univalent'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwAllCompCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwAllCompCommReqsSatisfied\",\"nwAllCompCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Network`, ECps1.`nwAllCompCommReqsSatisfied`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwAllCompCommReqsSatisfied`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`Network` <> isect0.`nwAllCompCommReqsSatisfied` AND isect0.`Network` IS NOT NULL AND isect0.`nwAllCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj nwAllCompCommReqsSatisfied' =>
        array ( 'name' => 'inj nwAllCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ |- I'
              , 'origin' => 'line 27, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwAllCompCommReqsSatisfied[Network\\*Network] is injectief'
              , 'message' => 'nwAllCompCommReqsSatisfied[Network\\*Network] is niet injectief'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwAllCompCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwAllCompCommReqsSatisfied\",\"nwAllCompCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Network`, ECps1.`nwAllCompCommReqsSatisfied`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwAllCompCommReqsSatisfied`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`Network` <> isect0.`nwAllCompCommReqsSatisfied` AND isect0.`Network` IS NOT NULL AND isect0.`nwAllCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym nwNoCompCommReqsSatisfied' =>
        array ( 'name' => 'sym nwNoCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied~'
              , 'origin' => 'line 35, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwNoCompCommReqsSatisfied[Network] is symmetrisch.'
              , 'message' => 'nwNoCompCommReqsSatisfied[Network] is niet symmetrisch.'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -((-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied)/\\(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied))
              // <=> { De Morgan }
              //     -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied) \\/ -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied)
              // <=> { -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied)\\/-(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied) = -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied) }
              //     -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied/\\-nwNoCompCommReqsSatisfied
              // <=> { nwNoCompCommReqsSatisfied/\\-nwNoCompCommReqsSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy nwNoCompCommReqsSatisfied' =>
        array ( 'name' => 'asy nwNoCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwNoCompCommReqsSatisfied~/\\nwNoCompCommReqsSatisfied |- I'
              , 'origin' => 'line 35, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwNoCompCommReqsSatisfied[Network] is antisymmetrisch.'
              , 'message' => 'nwNoCompCommReqsSatisfied[Network] is niet antisymmetrisch.'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(nwNoCompCommReqsSatisfied/\\nwNoCompCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied/\\nwNoCompCommReqsSatisfied/\\-I
              // <=> { nwNoCompCommReqsSatisfied/\\nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied }
              //     nwNoCompCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwNoCompCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwNoCompCommReqsSatisfied` AS tgt
                          FROM `Network` AS isect0
                          WHERE isect0.`Network` <> isect0.`nwNoCompCommReqsSatisfied` AND isect0.`Network` IS NOT NULL AND isect0.`nwNoCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni nwNoCompCommReqsSatisfied' =>
        array ( 'name' => 'uni nwNoCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied |- I'
              , 'origin' => 'line 35, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwNoCompCommReqsSatisfied[Network\\*Network] is univalent'
              , 'message' => 'nwNoCompCommReqsSatisfied[Network\\*Network] is niet univalent'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwNoCompCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwNoCompCommReqsSatisfied\",\"nwNoCompCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Network`, ECps1.`nwNoCompCommReqsSatisfied`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwNoCompCommReqsSatisfied`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`Network` <> isect0.`nwNoCompCommReqsSatisfied` AND isect0.`Network` IS NOT NULL AND isect0.`nwNoCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj nwNoCompCommReqsSatisfied' =>
        array ( 'name' => 'inj nwNoCompCommReqsSatisfied'
              , 'ruleAdl' => 'nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ |- I'
              , 'origin' => 'line 35, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'nwNoCompCommReqsSatisfied[Network\\*Network] is injectief'
              , 'message' => 'nwNoCompCommReqsSatisfied[Network\\*Network] is niet injectief'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`nwNoCompCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwNoCompCommReqsSatisfied\",\"nwNoCompCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Network`, ECps1.`nwNoCompCommReqsSatisfied`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwNoCompCommReqsSatisfied`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`Network` <> isect0.`nwNoCompCommReqsSatisfied` AND isect0.`Network` IS NOT NULL AND isect0.`nwNoCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym routerAllCommReqsSatisfied' =>
        array ( 'name' => 'sym routerAllCommReqsSatisfied'
              , 'ruleAdl' => 'routerAllCommReqsSatisfied = routerAllCommReqsSatisfied~'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerAllCommReqsSatisfied[Router] is symmetrisch.'
              , 'message' => 'routerAllCommReqsSatisfied[Router] is niet symmetrisch.'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -((-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied)/\\(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied))
              // <=> { De Morgan }
              //     -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied) \\/ -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied)
              // <=> { -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied)\\/-(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied) = -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied) }
              //     -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied/\\-routerAllCommReqsSatisfied
              // <=> { routerAllCommReqsSatisfied/\\-routerAllCommReqsSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy routerAllCommReqsSatisfied' =>
        array ( 'name' => 'asy routerAllCommReqsSatisfied'
              , 'ruleAdl' => 'routerAllCommReqsSatisfied~/\\routerAllCommReqsSatisfied |- I'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerAllCommReqsSatisfied[Router] is antisymmetrisch.'
              , 'message' => 'routerAllCommReqsSatisfied[Router] is niet antisymmetrisch.'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerAllCommReqsSatisfied/\\routerAllCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied/\\routerAllCommReqsSatisfied/\\-I
              // <=> { routerAllCommReqsSatisfied/\\routerAllCommReqsSatisfied = routerAllCommReqsSatisfied }
              //     routerAllCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerAllCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerAllCommReqsSatisfied` AS tgt
                          FROM `Router` AS isect0
                          WHERE isect0.`Router` <> isect0.`routerAllCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni routerAllCommReqsSatisfied' =>
        array ( 'name' => 'uni routerAllCommReqsSatisfied'
              , 'ruleAdl' => 'routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied |- I'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerAllCommReqsSatisfied[Router\\*Router] is univalent'
              , 'message' => 'routerAllCommReqsSatisfied[Router\\*Router] is niet univalent'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerAllCommReqsSatisfied;routerAllCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerAllCommReqsSatisfied;routerAllCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerAllCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerAllCommReqsSatisfied\",\"routerAllCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`routerAllCommReqsSatisfied`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`Router` <> isect0.`routerAllCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj routerAllCommReqsSatisfied' =>
        array ( 'name' => 'inj routerAllCommReqsSatisfied'
              , 'ruleAdl' => 'routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ |- I'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerAllCommReqsSatisfied[Router\\*Router] is injectief'
              , 'message' => 'routerAllCommReqsSatisfied[Router\\*Router] is niet injectief'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerAllCommReqsSatisfied;routerAllCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerAllCommReqsSatisfied;routerAllCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerAllCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerAllCommReqsSatisfied\",\"routerAllCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`routerAllCommReqsSatisfied`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`Router` <> isect0.`routerAllCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym routerNoCommReqsSatisfied' =>
        array ( 'name' => 'sym routerNoCommReqsSatisfied'
              , 'ruleAdl' => 'routerNoCommReqsSatisfied = routerNoCommReqsSatisfied~'
              , 'origin' => 'line 76, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerNoCommReqsSatisfied[Router] is symmetrisch.'
              , 'message' => 'routerNoCommReqsSatisfied[Router] is niet symmetrisch.'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -((-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied)/\\(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied))
              // <=> { De Morgan }
              //     -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied) \\/ -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied)
              // <=> { -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied)\\/-(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied) = -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied) }
              //     -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied/\\-routerNoCommReqsSatisfied
              // <=> { routerNoCommReqsSatisfied/\\-routerNoCommReqsSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy routerNoCommReqsSatisfied' =>
        array ( 'name' => 'asy routerNoCommReqsSatisfied'
              , 'ruleAdl' => 'routerNoCommReqsSatisfied~/\\routerNoCommReqsSatisfied |- I'
              , 'origin' => 'line 76, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerNoCommReqsSatisfied[Router] is antisymmetrisch.'
              , 'message' => 'routerNoCommReqsSatisfied[Router] is niet antisymmetrisch.'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerNoCommReqsSatisfied/\\routerNoCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied/\\routerNoCommReqsSatisfied/\\-I
              // <=> { routerNoCommReqsSatisfied/\\routerNoCommReqsSatisfied = routerNoCommReqsSatisfied }
              //     routerNoCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNoCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerNoCommReqsSatisfied` AS tgt
                          FROM `Router` AS isect0
                          WHERE isect0.`Router` <> isect0.`routerNoCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerNoCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni routerNoCommReqsSatisfied' =>
        array ( 'name' => 'uni routerNoCommReqsSatisfied'
              , 'ruleAdl' => 'routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied |- I'
              , 'origin' => 'line 76, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerNoCommReqsSatisfied[Router\\*Router] is univalent'
              , 'message' => 'routerNoCommReqsSatisfied[Router\\*Router] is niet univalent'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerNoCommReqsSatisfied;routerNoCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNoCommReqsSatisfied;routerNoCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerNoCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNoCommReqsSatisfied\",\"routerNoCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`routerNoCommReqsSatisfied`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNoCommReqsSatisfied`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`Router` <> isect0.`routerNoCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerNoCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj routerNoCommReqsSatisfied' =>
        array ( 'name' => 'inj routerNoCommReqsSatisfied'
              , 'ruleAdl' => 'routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ |- I'
              , 'origin' => 'line 76, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'routerNoCommReqsSatisfied[Router\\*Router] is injectief'
              , 'message' => 'routerNoCommReqsSatisfied[Router\\*Router] is niet injectief'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(routerNoCommReqsSatisfied;routerNoCommReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNoCommReqsSatisfied;routerNoCommReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`routerNoCommReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNoCommReqsSatisfied\",\"routerNoCommReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Router`, ECps1.`routerNoCommReqsSatisfied`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNoCommReqsSatisfied`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`Router` <> isect0.`routerNoCommReqsSatisfied` AND isect0.`Router` IS NOT NULL AND isect0.`routerNoCommReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym compRequiresComm' =>
        array ( 'name' => 'sym compRequiresComm'
              , 'ruleAdl' => 'compRequiresComm = compRequiresComm~'
              , 'origin' => 'line 102, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compRequiresComm[Computer] is symmetrisch.'
              , 'message' => 'compRequiresComm[Computer] is niet symmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -((-compRequiresComm \\/ compRequiresComm)/\\(-compRequiresComm \\/ compRequiresComm))
              // <=> { De Morgan }
              //     -(-compRequiresComm \\/ compRequiresComm) \\/ -(-compRequiresComm \\/ compRequiresComm)
              // <=> { -(-compRequiresComm \\/ compRequiresComm)\\/-(-compRequiresComm \\/ compRequiresComm) = -(-compRequiresComm \\/ compRequiresComm) }
              //     -(-compRequiresComm \\/ compRequiresComm)
              // <=> { De Morgan }
              //     compRequiresComm/\\-compRequiresComm
              // <=> { compRequiresComm/\\-compRequiresComm = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy compRequiresComm' =>
        array ( 'name' => 'asy compRequiresComm'
              , 'ruleAdl' => 'compRequiresComm~/\\compRequiresComm |- I'
              , 'origin' => 'line 102, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compRequiresComm[Computer] is antisymmetrisch.'
              , 'message' => 'compRequiresComm[Computer] is niet antisymmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compRequiresComm/\\compRequiresComm) \\/ I)
              // <=> { De Morgan }
              //     compRequiresComm/\\compRequiresComm/\\-I
              // <=> { compRequiresComm/\\compRequiresComm = compRequiresComm }
              //     compRequiresComm/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRequiresComm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compRequiresComm` AS tgt
                          FROM `Computer` AS isect0
                          WHERE isect0.`Computer` <> isect0.`compRequiresComm` AND isect0.`Computer` IS NOT NULL AND isect0.`compRequiresComm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compRequiresComm' =>
        array ( 'name' => 'uni compRequiresComm'
              , 'ruleAdl' => 'compRequiresComm~;compRequiresComm |- I'
              , 'origin' => 'line 102, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compRequiresComm[Computer\\*Computer] is univalent'
              , 'message' => 'compRequiresComm[Computer\\*Computer] is niet univalent'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compRequiresComm;compRequiresComm) \\/ I)
              // <=> { De Morgan }
              //     compRequiresComm;compRequiresComm/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRequiresComm;compRequiresComm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compRequiresComm` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRequiresComm\",\"compRequiresComm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`compRequiresComm`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compRequiresComm`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`compRequiresComm` AND isect0.`Computer` IS NOT NULL AND isect0.`compRequiresComm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj compRequiresComm' =>
        array ( 'name' => 'inj compRequiresComm'
              , 'ruleAdl' => 'compRequiresComm;compRequiresComm~ |- I'
              , 'origin' => 'line 102, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compRequiresComm[Computer\\*Computer] is injectief'
              , 'message' => 'compRequiresComm[Computer\\*Computer] is niet injectief'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compRequiresComm;compRequiresComm) \\/ I)
              // <=> { De Morgan }
              //     compRequiresComm;compRequiresComm/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compRequiresComm;compRequiresComm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compRequiresComm` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compRequiresComm\",\"compRequiresComm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`compRequiresComm`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compRequiresComm`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`compRequiresComm` AND isect0.`Computer` IS NOT NULL AND isect0.`compRequiresComm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym compAllReqCommSatisfied' =>
        array ( 'name' => 'sym compAllReqCommSatisfied'
              , 'ruleAdl' => 'compAllReqCommSatisfied = compAllReqCommSatisfied~'
              , 'origin' => 'line 110, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compAllReqCommSatisfied[Computer] is symmetrisch.'
              , 'message' => 'compAllReqCommSatisfied[Computer] is niet symmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -((-compAllReqCommSatisfied \\/ compAllReqCommSatisfied)/\\(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied))
              // <=> { De Morgan }
              //     -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied) \\/ -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied)
              // <=> { -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied)\\/-(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied) = -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied) }
              //     -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied/\\-compAllReqCommSatisfied
              // <=> { compAllReqCommSatisfied/\\-compAllReqCommSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy compAllReqCommSatisfied' =>
        array ( 'name' => 'asy compAllReqCommSatisfied'
              , 'ruleAdl' => 'compAllReqCommSatisfied~/\\compAllReqCommSatisfied |- I'
              , 'origin' => 'line 110, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compAllReqCommSatisfied[Computer] is antisymmetrisch.'
              , 'message' => 'compAllReqCommSatisfied[Computer] is niet antisymmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compAllReqCommSatisfied/\\compAllReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied/\\compAllReqCommSatisfied/\\-I
              // <=> { compAllReqCommSatisfied/\\compAllReqCommSatisfied = compAllReqCommSatisfied }
              //     compAllReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compAllReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compAllReqCommSatisfied` AS tgt
                          FROM `Computer` AS isect0
                          WHERE isect0.`Computer` <> isect0.`compAllReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compAllReqCommSatisfied' =>
        array ( 'name' => 'uni compAllReqCommSatisfied'
              , 'ruleAdl' => 'compAllReqCommSatisfied~;compAllReqCommSatisfied |- I'
              , 'origin' => 'line 110, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compAllReqCommSatisfied[Computer\\*Computer] is univalent'
              , 'message' => 'compAllReqCommSatisfied[Computer\\*Computer] is niet univalent'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compAllReqCommSatisfied;compAllReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compAllReqCommSatisfied;compAllReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compAllReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compAllReqCommSatisfied\",\"compAllReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`compAllReqCommSatisfied`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compAllReqCommSatisfied`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`compAllReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj compAllReqCommSatisfied' =>
        array ( 'name' => 'inj compAllReqCommSatisfied'
              , 'ruleAdl' => 'compAllReqCommSatisfied;compAllReqCommSatisfied~ |- I'
              , 'origin' => 'line 110, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compAllReqCommSatisfied[Computer\\*Computer] is injectief'
              , 'message' => 'compAllReqCommSatisfied[Computer\\*Computer] is niet injectief'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compAllReqCommSatisfied;compAllReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compAllReqCommSatisfied;compAllReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compAllReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compAllReqCommSatisfied\",\"compAllReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`compAllReqCommSatisfied`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compAllReqCommSatisfied`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`compAllReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym compNoReqCommSatisfied' =>
        array ( 'name' => 'sym compNoReqCommSatisfied'
              , 'ruleAdl' => 'compNoReqCommSatisfied = compNoReqCommSatisfied~'
              , 'origin' => 'line 118, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compNoReqCommSatisfied[Computer] is symmetrisch.'
              , 'message' => 'compNoReqCommSatisfied[Computer] is niet symmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -((-compNoReqCommSatisfied \\/ compNoReqCommSatisfied)/\\(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied))
              // <=> { De Morgan }
              //     -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied) \\/ -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied)
              // <=> { -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied)\\/-(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied) = -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied) }
              //     -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied)
              // <=> { De Morgan }
              //     compNoReqCommSatisfied/\\-compNoReqCommSatisfied
              // <=> { compNoReqCommSatisfied/\\-compNoReqCommSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy compNoReqCommSatisfied' =>
        array ( 'name' => 'asy compNoReqCommSatisfied'
              , 'ruleAdl' => 'compNoReqCommSatisfied~/\\compNoReqCommSatisfied |- I'
              , 'origin' => 'line 118, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compNoReqCommSatisfied[Computer] is antisymmetrisch.'
              , 'message' => 'compNoReqCommSatisfied[Computer] is niet antisymmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compNoReqCommSatisfied/\\compNoReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     compNoReqCommSatisfied/\\compNoReqCommSatisfied/\\-I
              // <=> { compNoReqCommSatisfied/\\compNoReqCommSatisfied = compNoReqCommSatisfied }
              //     compNoReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compNoReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compNoReqCommSatisfied` AS tgt
                          FROM `Computer` AS isect0
                          WHERE isect0.`Computer` <> isect0.`compNoReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compNoReqCommSatisfied' =>
        array ( 'name' => 'uni compNoReqCommSatisfied'
              , 'ruleAdl' => 'compNoReqCommSatisfied~;compNoReqCommSatisfied |- I'
              , 'origin' => 'line 118, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compNoReqCommSatisfied[Computer\\*Computer] is univalent'
              , 'message' => 'compNoReqCommSatisfied[Computer\\*Computer] is niet univalent'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compNoReqCommSatisfied;compNoReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compNoReqCommSatisfied;compNoReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compNoReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compNoReqCommSatisfied\",\"compNoReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`compNoReqCommSatisfied`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compNoReqCommSatisfied`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`compNoReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj compNoReqCommSatisfied' =>
        array ( 'name' => 'inj compNoReqCommSatisfied'
              , 'ruleAdl' => 'compNoReqCommSatisfied;compNoReqCommSatisfied~ |- I'
              , 'origin' => 'line 118, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'compNoReqCommSatisfied[Computer\\*Computer] is injectief'
              , 'message' => 'compNoReqCommSatisfied[Computer\\*Computer] is niet injectief'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(compNoReqCommSatisfied;compNoReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compNoReqCommSatisfied;compNoReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`compNoReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compNoReqCommSatisfied\",\"compNoReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`compNoReqCommSatisfied`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compNoReqCommSatisfied`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`compNoReqCommSatisfied` AND isect0.`Computer` IS NOT NULL AND isect0.`compNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym scAllReqCommSatisfied' =>
        array ( 'name' => 'sym scAllReqCommSatisfied'
              , 'ruleAdl' => 'scAllReqCommSatisfied = scAllReqCommSatisfied~'
              , 'origin' => 'line 137, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scAllReqCommSatisfied[SvcComponent] is symmetrisch.'
              , 'message' => 'scAllReqCommSatisfied[SvcComponent] is niet symmetrisch.'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -((-scAllReqCommSatisfied \\/ scAllReqCommSatisfied)/\\(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied))
              // <=> { De Morgan }
              //     -(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied) \\/ -(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied)
              // <=> { -(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied)\\/-(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied) = -(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied) }
              //     -(-scAllReqCommSatisfied \\/ scAllReqCommSatisfied)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied/\\-scAllReqCommSatisfied
              // <=> { scAllReqCommSatisfied/\\-scAllReqCommSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy scAllReqCommSatisfied' =>
        array ( 'name' => 'asy scAllReqCommSatisfied'
              , 'ruleAdl' => 'scAllReqCommSatisfied~/\\scAllReqCommSatisfied |- I'
              , 'origin' => 'line 137, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scAllReqCommSatisfied[SvcComponent] is antisymmetrisch.'
              , 'message' => 'scAllReqCommSatisfied[SvcComponent] is niet antisymmetrisch.'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scAllReqCommSatisfied/\\scAllReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied/\\scAllReqCommSatisfied/\\-I
              // <=> { scAllReqCommSatisfied/\\scAllReqCommSatisfied = scAllReqCommSatisfied }
              //     scAllReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scAllReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scAllReqCommSatisfied` AS tgt
                          FROM `SvcComponent` AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`scAllReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scAllReqCommSatisfied' =>
        array ( 'name' => 'uni scAllReqCommSatisfied'
              , 'ruleAdl' => 'scAllReqCommSatisfied~;scAllReqCommSatisfied |- I'
              , 'origin' => 'line 137, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is univalent'
              , 'message' => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is niet univalent'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scAllReqCommSatisfied;scAllReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied;scAllReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scAllReqCommSatisfied;scAllReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scAllReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scAllReqCommSatisfied\",\"scAllReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`scAllReqCommSatisfied`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`scAllReqCommSatisfied`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`scAllReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj scAllReqCommSatisfied' =>
        array ( 'name' => 'inj scAllReqCommSatisfied'
              , 'ruleAdl' => 'scAllReqCommSatisfied;scAllReqCommSatisfied~ |- I'
              , 'origin' => 'line 137, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is injectief'
              , 'message' => 'scAllReqCommSatisfied[SvcComponent\\*SvcComponent] is niet injectief'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scAllReqCommSatisfied;scAllReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     scAllReqCommSatisfied;scAllReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scAllReqCommSatisfied;scAllReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scAllReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scAllReqCommSatisfied\",\"scAllReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`scAllReqCommSatisfied`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`scAllReqCommSatisfied`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`scAllReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scAllReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym scNoReqCommSatisfied' =>
        array ( 'name' => 'sym scNoReqCommSatisfied'
              , 'ruleAdl' => 'scNoReqCommSatisfied = scNoReqCommSatisfied~'
              , 'origin' => 'line 145, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scNoReqCommSatisfied[SvcComponent] is symmetrisch.'
              , 'message' => 'scNoReqCommSatisfied[SvcComponent] is niet symmetrisch.'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -((-scNoReqCommSatisfied \\/ scNoReqCommSatisfied)/\\(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied))
              // <=> { De Morgan }
              //     -(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied) \\/ -(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied)
              // <=> { -(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied)\\/-(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied) = -(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied) }
              //     -(-scNoReqCommSatisfied \\/ scNoReqCommSatisfied)
              // <=> { De Morgan }
              //     scNoReqCommSatisfied/\\-scNoReqCommSatisfied
              // <=> { scNoReqCommSatisfied/\\-scNoReqCommSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy scNoReqCommSatisfied' =>
        array ( 'name' => 'asy scNoReqCommSatisfied'
              , 'ruleAdl' => 'scNoReqCommSatisfied~/\\scNoReqCommSatisfied |- I'
              , 'origin' => 'line 145, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scNoReqCommSatisfied[SvcComponent] is antisymmetrisch.'
              , 'message' => 'scNoReqCommSatisfied[SvcComponent] is niet antisymmetrisch.'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scNoReqCommSatisfied/\\scNoReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     scNoReqCommSatisfied/\\scNoReqCommSatisfied/\\-I
              // <=> { scNoReqCommSatisfied/\\scNoReqCommSatisfied = scNoReqCommSatisfied }
              //     scNoReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scNoReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scNoReqCommSatisfied` AS tgt
                          FROM `SvcComponent` AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`scNoReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scNoReqCommSatisfied' =>
        array ( 'name' => 'uni scNoReqCommSatisfied'
              , 'ruleAdl' => 'scNoReqCommSatisfied~;scNoReqCommSatisfied |- I'
              , 'origin' => 'line 145, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is univalent'
              , 'message' => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is niet univalent'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scNoReqCommSatisfied;scNoReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     scNoReqCommSatisfied;scNoReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scNoReqCommSatisfied;scNoReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scNoReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scNoReqCommSatisfied\",\"scNoReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`scNoReqCommSatisfied`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`scNoReqCommSatisfied`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`scNoReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj scNoReqCommSatisfied' =>
        array ( 'name' => 'inj scNoReqCommSatisfied'
              , 'ruleAdl' => 'scNoReqCommSatisfied;scNoReqCommSatisfied~ |- I'
              , 'origin' => 'line 145, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is injectief'
              , 'message' => 'scNoReqCommSatisfied[SvcComponent\\*SvcComponent] is niet injectief'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(scNoReqCommSatisfied;scNoReqCommSatisfied) \\/ I)
              // <=> { De Morgan }
              //     scNoReqCommSatisfied;scNoReqCommSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scNoReqCommSatisfied;scNoReqCommSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`scNoReqCommSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scNoReqCommSatisfied\",\"scNoReqCommSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`scNoReqCommSatisfied`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`scNoReqCommSatisfied`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`scNoReqCommSatisfied` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`scNoReqCommSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym svcAllSvcCompReqsSatisfied' =>
        array ( 'name' => 'sym svcAllSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcAllSvcCompReqsSatisfied = svcAllSvcCompReqsSatisfied~'
              , 'origin' => 'line 155, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcAllSvcCompReqsSatisfied[Service] is symmetrisch.'
              , 'message' => 'svcAllSvcCompReqsSatisfied[Service] is niet symmetrisch.'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -((-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied)/\\(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied))
              // <=> { De Morgan }
              //     -(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied) \\/ -(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied)
              // <=> { -(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied)\\/-(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied) = -(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied) }
              //     -(-svcAllSvcCompReqsSatisfied \\/ svcAllSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied/\\-svcAllSvcCompReqsSatisfied
              // <=> { svcAllSvcCompReqsSatisfied/\\-svcAllSvcCompReqsSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy svcAllSvcCompReqsSatisfied' =>
        array ( 'name' => 'asy svcAllSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcAllSvcCompReqsSatisfied~/\\svcAllSvcCompReqsSatisfied |- I'
              , 'origin' => 'line 155, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcAllSvcCompReqsSatisfied[Service] is antisymmetrisch.'
              , 'message' => 'svcAllSvcCompReqsSatisfied[Service] is niet antisymmetrisch.'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcAllSvcCompReqsSatisfied/\\svcAllSvcCompReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied/\\svcAllSvcCompReqsSatisfied/\\-I
              // <=> { svcAllSvcCompReqsSatisfied/\\svcAllSvcCompReqsSatisfied = svcAllSvcCompReqsSatisfied }
              //     svcAllSvcCompReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcAllSvcCompReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcAllSvcCompReqsSatisfied` AS tgt
                          FROM `Service` AS isect0
                          WHERE isect0.`Service` <> isect0.`svcAllSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcAllSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni svcAllSvcCompReqsSatisfied' =>
        array ( 'name' => 'uni svcAllSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcAllSvcCompReqsSatisfied~;svcAllSvcCompReqsSatisfied |- I'
              , 'origin' => 'line 155, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is univalent'
              , 'message' => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is niet univalent'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcAllSvcCompReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcAllSvcCompReqsSatisfied\",\"svcAllSvcCompReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`svcAllSvcCompReqsSatisfied`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`svcAllSvcCompReqsSatisfied`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`Service` <> isect0.`svcAllSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcAllSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj svcAllSvcCompReqsSatisfied' =>
        array ( 'name' => 'inj svcAllSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied~ |- I'
              , 'origin' => 'line 155, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is injectief'
              , 'message' => 'svcAllSvcCompReqsSatisfied[Service\\*Service] is niet injectief'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcAllSvcCompReqsSatisfied;svcAllSvcCompReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcAllSvcCompReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcAllSvcCompReqsSatisfied\",\"svcAllSvcCompReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`svcAllSvcCompReqsSatisfied`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`svcAllSvcCompReqsSatisfied`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`Service` <> isect0.`svcAllSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcAllSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym svcNoSvcCompReqsSatisfied' =>
        array ( 'name' => 'sym svcNoSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcNoSvcCompReqsSatisfied = svcNoSvcCompReqsSatisfied~'
              , 'origin' => 'line 165, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcNoSvcCompReqsSatisfied[Service] is symmetrisch.'
              , 'message' => 'svcNoSvcCompReqsSatisfied[Service] is niet symmetrisch.'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -((-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied)/\\(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied))
              // <=> { De Morgan }
              //     -(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied) \\/ -(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied)
              // <=> { -(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied)\\/-(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied) = -(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied) }
              //     -(-svcNoSvcCompReqsSatisfied \\/ svcNoSvcCompReqsSatisfied)
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied/\\-svcNoSvcCompReqsSatisfied
              // <=> { svcNoSvcCompReqsSatisfied/\\-svcNoSvcCompReqsSatisfied = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy svcNoSvcCompReqsSatisfied' =>
        array ( 'name' => 'asy svcNoSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcNoSvcCompReqsSatisfied~/\\svcNoSvcCompReqsSatisfied |- I'
              , 'origin' => 'line 165, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcNoSvcCompReqsSatisfied[Service] is antisymmetrisch.'
              , 'message' => 'svcNoSvcCompReqsSatisfied[Service] is niet antisymmetrisch.'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcNoSvcCompReqsSatisfied/\\svcNoSvcCompReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied/\\svcNoSvcCompReqsSatisfied/\\-I
              // <=> { svcNoSvcCompReqsSatisfied/\\svcNoSvcCompReqsSatisfied = svcNoSvcCompReqsSatisfied }
              //     svcNoSvcCompReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcNoSvcCompReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcNoSvcCompReqsSatisfied` AS tgt
                          FROM `Service` AS isect0
                          WHERE isect0.`Service` <> isect0.`svcNoSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcNoSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni svcNoSvcCompReqsSatisfied' =>
        array ( 'name' => 'uni svcNoSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcNoSvcCompReqsSatisfied~;svcNoSvcCompReqsSatisfied |- I'
              , 'origin' => 'line 165, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is univalent'
              , 'message' => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is niet univalent'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcNoSvcCompReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcNoSvcCompReqsSatisfied\",\"svcNoSvcCompReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`svcNoSvcCompReqsSatisfied`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`svcNoSvcCompReqsSatisfied`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`Service` <> isect0.`svcNoSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcNoSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj svcNoSvcCompReqsSatisfied' =>
        array ( 'name' => 'inj svcNoSvcCompReqsSatisfied'
              , 'ruleAdl' => 'svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied~ |- I'
              , 'origin' => 'line 165, file "..\\\\CyberSA\\\\CSA_Ontology_ExecEngine.adl"'
              , 'meaning' => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is injectief'
              , 'message' => 'svcNoSvcCompReqsSatisfied[Service\\*Service] is niet injectief'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied) \\/ I)
              // <=> { De Morgan }
              //     svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcNoSvcCompReqsSatisfied;svcNoSvcCompReqsSatisfied\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`svcNoSvcCompReqsSatisfied` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcNoSvcCompReqsSatisfied\",\"svcNoSvcCompReqsSatisfied\"] */
                                 
                                 SELECT DISTINCT ECps0.`Service`, ECps1.`svcNoSvcCompReqsSatisfied`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`svcNoSvcCompReqsSatisfied`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`Service` <> isect0.`svcNoSvcCompReqsSatisfied` AND isect0.`Service` IS NOT NULL AND isect0.`svcNoSvcCompReqsSatisfied` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym connectComputerToNetworkRouter' =>
        array ( 'name' => 'sym connectComputerToNetworkRouter'
              , 'ruleAdl' => 'connectComputerToNetworkRouter = connectComputerToNetworkRouter~'
              , 'origin' => 'line 15, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'connectComputerToNetworkRouter[Computer] is symmetrisch.'
              , 'message' => 'connectComputerToNetworkRouter[Computer] is niet symmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -((-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter)/\\(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter))
              // <=> { De Morgan }
              //     -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter) \\/ -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter)
              // <=> { -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter)\\/-(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter) = -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter) }
              //     -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter)
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter/\\-connectComputerToNetworkRouter
              // <=> { connectComputerToNetworkRouter/\\-connectComputerToNetworkRouter = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy connectComputerToNetworkRouter' =>
        array ( 'name' => 'asy connectComputerToNetworkRouter'
              , 'ruleAdl' => 'connectComputerToNetworkRouter~/\\connectComputerToNetworkRouter |- I'
              , 'origin' => 'line 15, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'connectComputerToNetworkRouter[Computer] is antisymmetrisch.'
              , 'message' => 'connectComputerToNetworkRouter[Computer] is niet antisymmetrisch.'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(connectComputerToNetworkRouter/\\connectComputerToNetworkRouter) \\/ I)
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter/\\connectComputerToNetworkRouter/\\-I
              // <=> { connectComputerToNetworkRouter/\\connectComputerToNetworkRouter = connectComputerToNetworkRouter }
              //     connectComputerToNetworkRouter/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"connectComputerToNetworkRouter\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`connectComputerToNetworkRouter` AS tgt
                          FROM `Computer` AS isect0
                          WHERE isect0.`Computer` <> isect0.`connectComputerToNetworkRouter` AND isect0.`Computer` IS NOT NULL AND isect0.`connectComputerToNetworkRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni connectComputerToNetworkRouter' =>
        array ( 'name' => 'uni connectComputerToNetworkRouter'
              , 'ruleAdl' => 'connectComputerToNetworkRouter~;connectComputerToNetworkRouter |- I'
              , 'origin' => 'line 15, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'connectComputerToNetworkRouter[Computer\\*Computer] is univalent'
              , 'message' => 'connectComputerToNetworkRouter[Computer\\*Computer] is niet univalent'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(connectComputerToNetworkRouter;connectComputerToNetworkRouter) \\/ I)
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"connectComputerToNetworkRouter;connectComputerToNetworkRouter\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`connectComputerToNetworkRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"connectComputerToNetworkRouter\",\"connectComputerToNetworkRouter\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`connectComputerToNetworkRouter`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`connectComputerToNetworkRouter`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`connectComputerToNetworkRouter` AND isect0.`Computer` IS NOT NULL AND isect0.`connectComputerToNetworkRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj connectComputerToNetworkRouter' =>
        array ( 'name' => 'inj connectComputerToNetworkRouter'
              , 'ruleAdl' => 'connectComputerToNetworkRouter;connectComputerToNetworkRouter~ |- I'
              , 'origin' => 'line 15, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'connectComputerToNetworkRouter[Computer\\*Computer] is injectief'
              , 'message' => 'connectComputerToNetworkRouter[Computer\\*Computer] is niet injectief'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(connectComputerToNetworkRouter;connectComputerToNetworkRouter) \\/ I)
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"connectComputerToNetworkRouter;connectComputerToNetworkRouter\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`connectComputerToNetworkRouter` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"connectComputerToNetworkRouter\",\"connectComputerToNetworkRouter\"] */
                                 
                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`connectComputerToNetworkRouter`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`connectComputerToNetworkRouter`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`Computer` <> isect0.`connectComputerToNetworkRouter` AND isect0.`Computer` IS NOT NULL AND isect0.`connectComputerToNetworkRouter` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'sym startRunningServiceComponents' =>
        array ( 'name' => 'sym startRunningServiceComponents'
              , 'ruleAdl' => 'startRunningServiceComponents = startRunningServiceComponents~'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'startRunningServiceComponents[SvcComponent] is symmetrisch.'
              , 'message' => 'startRunningServiceComponents[SvcComponent] is niet symmetrisch.'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -((-startRunningServiceComponents \\/ startRunningServiceComponents)/\\(-startRunningServiceComponents \\/ startRunningServiceComponents))
              // <=> { De Morgan }
              //     -(-startRunningServiceComponents \\/ startRunningServiceComponents) \\/ -(-startRunningServiceComponents \\/ startRunningServiceComponents)
              // <=> { -(-startRunningServiceComponents \\/ startRunningServiceComponents)\\/-(-startRunningServiceComponents \\/ startRunningServiceComponents) = -(-startRunningServiceComponents \\/ startRunningServiceComponents) }
              //     -(-startRunningServiceComponents \\/ startRunningServiceComponents)
              // <=> { De Morgan }
              //     startRunningServiceComponents/\\-startRunningServiceComponents
              // <=> { startRunningServiceComponents/\\-startRunningServiceComponents = V- }
              //     -V
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'asy startRunningServiceComponents' =>
        array ( 'name' => 'asy startRunningServiceComponents'
              , 'ruleAdl' => 'startRunningServiceComponents~/\\startRunningServiceComponents |- I'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'startRunningServiceComponents[SvcComponent] is antisymmetrisch.'
              , 'message' => 'startRunningServiceComponents[SvcComponent] is niet antisymmetrisch.'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(startRunningServiceComponents/\\startRunningServiceComponents) \\/ I)
              // <=> { De Morgan }
              //     startRunningServiceComponents/\\startRunningServiceComponents/\\-I
              // <=> { startRunningServiceComponents/\\startRunningServiceComponents = startRunningServiceComponents }
              //     startRunningServiceComponents/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"startRunningServiceComponents\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`startRunningServiceComponents` AS tgt
                          FROM `SvcComponent` AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`startRunningServiceComponents` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`startRunningServiceComponents` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni startRunningServiceComponents' =>
        array ( 'name' => 'uni startRunningServiceComponents'
              , 'ruleAdl' => 'startRunningServiceComponents~;startRunningServiceComponents |- I'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is univalent'
              , 'message' => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is niet univalent'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(startRunningServiceComponents;startRunningServiceComponents) \\/ I)
              // <=> { De Morgan }
              //     startRunningServiceComponents;startRunningServiceComponents/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"startRunningServiceComponents;startRunningServiceComponents\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`startRunningServiceComponents` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"startRunningServiceComponents\",\"startRunningServiceComponents\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`startRunningServiceComponents`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`startRunningServiceComponents`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`startRunningServiceComponents` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`startRunningServiceComponents` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'inj startRunningServiceComponents' =>
        array ( 'name' => 'inj startRunningServiceComponents'
              , 'ruleAdl' => 'startRunningServiceComponents;startRunningServiceComponents~ |- I'
              , 'origin' => 'line 68, file "..\\\\CyberSA\\\\CSA_Ontology_Process.adl"'
              , 'meaning' => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is injectief'
              , 'message' => 'startRunningServiceComponents[SvcComponent\\*SvcComponent] is niet injectief'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(startRunningServiceComponents;startRunningServiceComponents) \\/ I)
              // <=> { De Morgan }
              //     startRunningServiceComponents;startRunningServiceComponents/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"startRunningServiceComponents;startRunningServiceComponents\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`startRunningServiceComponents` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"startRunningServiceComponents\",\"startRunningServiceComponents\"] */
                                 
                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`startRunningServiceComponents`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`startRunningServiceComponents`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SvcComponent` <> isect0.`startRunningServiceComponents` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`startRunningServiceComponents` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni planID' =>
        array ( 'name' => 'uni planID'
              , 'ruleAdl' => 'planID~;planID |- I'
              , 'origin' => 'line 5, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'planID[Plan\\*PlanID] is univalent'
              , 'message' => 'planID[Plan\\*PlanID] is niet univalent'
              , 'srcConcept' => 'PlanID'
              , 'tgtConcept' => 'PlanID'
              // original expression:
              //     -(-(planID~;planID) \\/ I)
              // <=> { De Morgan }
              //     planID~;planID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"planID~;planID\",\"-I\"] */
                          SELECT DISTINCT isect0.`planID` AS src, isect0.`planID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planID~\",\"planID\"] */
                                 
                                 SELECT DISTINCT ECps0.`planID`, ECps1.`planID` AS `planID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `planID`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                      ) AS ECps0,
                                      `Plan` AS ECps1
                                 WHERE ECps0.`Plan`=ECps1.`Plan`
                               ) AS isect0
                          WHERE isect0.`planID` <> isect0.`planID1` AND isect0.`planID` IS NOT NULL AND isect0.`planID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot planID' =>
        array ( 'name' => 'tot planID'
              , 'ruleAdl' => 'I |- planID;planID~'
              , 'origin' => 'line 5, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'planID[Plan\\*PlanID] is totaal'
              , 'message' => 'planID[Plan\\*PlanID] is niet totaal'
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-I \\/ planID;planID~)
              // <=> { De Morgan }
              //     I/\\-(planID;planID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(planID;planID~)\"] */
                          SELECT DISTINCT isect0.`actPlan` AS src, isect0.`actPlan` AS tgt
                          FROM `Activity` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"planID\",\"planID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                             FROM `Plan` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Plan`, `planID`
                                                    FROM `Plan`
                                                    WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`planID`=ECps1.`planID`
                                           ) AS cp
                                      WHERE isect0.`actPlan`=cp.`Plan` AND isect0.`actPlan`=cp.`Plan1`) AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni planStatus' =>
        array ( 'name' => 'uni planStatus'
              , 'ruleAdl' => 'planStatus~;planStatus |- I'
              , 'origin' => 'line 7, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'planStatus[Plan\\*Status] is univalent'
              , 'message' => 'planStatus[Plan\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(planStatus~;planStatus) \\/ I)
              // <=> { De Morgan }
              //     planStatus~;planStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"planStatus~;planStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`planStatus` AS src, isect0.`planStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planStatus~\",\"planStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`planStatus`, ECps1.`planStatus` AS `planStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `planStatus`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `Plan` AS ECps1
                                 WHERE ECps0.`Plan`=ECps1.`Plan`
                               ) AS isect0
                          WHERE isect0.`planStatus` <> isect0.`planStatus1` AND isect0.`planStatus` IS NOT NULL AND isect0.`planStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni planMnlStat' =>
        array ( 'name' => 'uni planMnlStat'
              , 'ruleAdl' => 'planMnlStat~;planMnlStat |- I'
              , 'origin' => 'line 9, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'planMnlStat[Plan\\*Status] is univalent'
              , 'message' => 'planMnlStat[Plan\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(planMnlStat~;planMnlStat) \\/ I)
              // <=> { De Morgan }
              //     planMnlStat~;planMnlStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"planMnlStat~;planMnlStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`planMnlStat` AS src, isect0.`planMnlStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planMnlStat~\",\"planMnlStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`planMnlStat`, ECps1.`planMnlStat` AS `planMnlStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `planMnlStat`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      `Plan` AS ECps1
                                 WHERE ECps0.`Plan`=ECps1.`Plan`
                               ) AS isect0
                          WHERE isect0.`planMnlStat` <> isect0.`planMnlStat1` AND isect0.`planMnlStat` IS NOT NULL AND isect0.`planMnlStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni atStatus' =>
        array ( 'name' => 'uni atStatus'
              , 'ruleAdl' => 'atStatus~;atStatus |- I'
              , 'origin' => 'line 16, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'atStatus[ActivityType\\*Status] is univalent'
              , 'message' => 'atStatus[ActivityType\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(atStatus~;atStatus) \\/ I)
              // <=> { De Morgan }
              //     atStatus~;atStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atStatus~;atStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`atStatus` AS src, isect0.`atStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atStatus~\",\"atStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`atStatus`, ECps1.`atStatus` AS `atStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ActivityType`, `atStatus`
                                        FROM `ActivityType`
                                        WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `ActivityType` AS ECps1
                                 WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                               ) AS isect0
                          WHERE isect0.`atStatus` <> isect0.`atStatus1` AND isect0.`atStatus` IS NOT NULL AND isect0.`atStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni svcID' =>
        array ( 'name' => 'uni svcID'
              , 'ruleAdl' => 'svcID~;svcID |- I'
              , 'origin' => 'line 25, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'svcID[Service\\*ServiceID] is univalent'
              , 'message' => 'svcID[Service\\*ServiceID] is niet univalent'
              , 'srcConcept' => 'ServiceID'
              , 'tgtConcept' => 'ServiceID'
              // original expression:
              //     -(-(svcID~;svcID) \\/ I)
              // <=> { De Morgan }
              //     svcID~;svcID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcID~;svcID\",\"-I\"] */
                          SELECT DISTINCT isect0.`svcID` AS src, isect0.`svcID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcID~\",\"svcID\"] */
                                 
                                 SELECT DISTINCT ECps0.`svcID`, ECps1.`svcID` AS `svcID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Service`, `svcID`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                      ) AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`svcID` <> isect0.`svcID1` AND isect0.`svcID` IS NOT NULL AND isect0.`svcID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot svcID' =>
        array ( 'name' => 'tot svcID'
              , 'ruleAdl' => 'I |- svcID;svcID~'
              , 'origin' => 'line 25, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'svcID[Service\\*ServiceID] is totaal'
              , 'message' => 'svcID[Service\\*ServiceID] is niet totaal'
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-I \\/ svcID;svcID~)
              // <=> { De Morgan }
              //     I/\\-(svcID;svcID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(svcID;svcID~)\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service` AS tgt
                          FROM `Service` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"svcID\",\"svcID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                             FROM `Service` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Service`, `svcID`
                                                    FROM `Service`
                                                    WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`svcID`=ECps1.`svcID`
                                           ) AS cp
                                      WHERE isect0.`Service`=cp.`Service` AND isect0.`Service`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni svcStatus' =>
        array ( 'name' => 'uni svcStatus'
              , 'ruleAdl' => 'svcStatus~;svcStatus |- I'
              , 'origin' => 'line 26, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'svcStatus[Service\\*Status] is univalent'
              , 'message' => 'svcStatus[Service\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(svcStatus~;svcStatus) \\/ I)
              // <=> { De Morgan }
              //     svcStatus~;svcStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcStatus~;svcStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`svcStatus` AS src, isect0.`svcStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcStatus~\",\"svcStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`svcStatus`, ECps1.`svcStatus` AS `svcStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Service`, `svcStatus`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`svcStatus` <> isect0.`svcStatus1` AND isect0.`svcStatus` IS NOT NULL AND isect0.`svcStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actType' =>
        array ( 'name' => 'uni actType'
              , 'ruleAdl' => 'actType~;actType |- I'
              , 'origin' => 'line 30, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actType[Activity\\*ActivityType] is univalent'
              , 'message' => 'actType[Activity\\*ActivityType] is niet univalent'
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(actType~;actType) \\/ I)
              // <=> { De Morgan }
              //     actType~;actType/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actType~;actType\",\"-I\"] */
                          SELECT DISTINCT isect0.`actType` AS src, isect0.`actType1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actType~\",\"actType\"] */
                                 
                                 SELECT DISTINCT ECps0.`actType`, ECps1.`actType` AS `actType1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actType`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actType` <> isect0.`actType1` AND isect0.`actType` IS NOT NULL AND isect0.`actType1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot actType' =>
        array ( 'name' => 'tot actType'
              , 'ruleAdl' => 'I |- actType;actType~'
              , 'origin' => 'line 30, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actType[Activity\\*ActivityType] is totaal'
              , 'message' => 'actType[Activity\\*ActivityType] is niet totaal'
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-I \\/ actType;actType~)
              // <=> { De Morgan }
              //     I/\\-(actType;actType~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(actType;actType~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity` AS tgt
                          FROM `Activity` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actType\",\"actType~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actType`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`actType`=ECps1.`actType`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actID' =>
        array ( 'name' => 'uni actID'
              , 'ruleAdl' => 'actID~;actID |- I'
              , 'origin' => 'line 32, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actID[Activity\\*ActivityID] is univalent'
              , 'message' => 'actID[Activity\\*ActivityID] is niet univalent'
              , 'srcConcept' => 'ActivityID'
              , 'tgtConcept' => 'ActivityID'
              // original expression:
              //     -(-(actID~;actID) \\/ I)
              // <=> { De Morgan }
              //     actID~;actID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actID~;actID\",\"-I\"] */
                          SELECT DISTINCT isect0.`actID` AS src, isect0.`actID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actID~\",\"actID\"] */
                                 
                                 SELECT DISTINCT ECps0.`actID`, ECps1.`actID` AS `actID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actID`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actID` <> isect0.`actID1` AND isect0.`actID` IS NOT NULL AND isect0.`actID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot actID' =>
        array ( 'name' => 'tot actID'
              , 'ruleAdl' => 'I |- actID;actID~'
              , 'origin' => 'line 32, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actID[Activity\\*ActivityID] is totaal'
              , 'message' => 'actID[Activity\\*ActivityID] is niet totaal'
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-I \\/ actID;actID~)
              // <=> { De Morgan }
              //     I/\\-(actID;actID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(actID;actID~)\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity` AS tgt
                          FROM `Activity` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"actID\",\"actID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                             FROM `Activity` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Activity`, `actID`
                                                    FROM `Activity`
                                                    WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`actID`=ECps1.`actID`
                                           ) AS cp
                                      WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Activity`=cp.`Activity1`) AND isect0.`Activity` IS NOT NULL AND isect0.`Activity` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actStatus' =>
        array ( 'name' => 'uni actStatus'
              , 'ruleAdl' => 'actStatus~;actStatus |- I'
              , 'origin' => 'line 34, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actStatus[Activity\\*Status] is univalent'
              , 'message' => 'actStatus[Activity\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(actStatus~;actStatus) \\/ I)
              // <=> { De Morgan }
              //     actStatus~;actStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actStatus~;actStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`actStatus` AS src, isect0.`actStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actStatus~\",\"actStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`actStatus`, ECps1.`actStatus` AS `actStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actStatus`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actStatus` <> isect0.`actStatus1` AND isect0.`actStatus` IS NOT NULL AND isect0.`actStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actMnlStat' =>
        array ( 'name' => 'uni actMnlStat'
              , 'ruleAdl' => 'actMnlStat~;actMnlStat |- I'
              , 'origin' => 'line 36, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actMnlStat[Activity\\*Status] is univalent'
              , 'message' => 'actMnlStat[Activity\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(actMnlStat~;actMnlStat) \\/ I)
              // <=> { De Morgan }
              //     actMnlStat~;actMnlStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actMnlStat~;actMnlStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`actMnlStat` AS src, isect0.`actMnlStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actMnlStat~\",\"actMnlStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`actMnlStat`, ECps1.`actMnlStat` AS `actMnlStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actMnlStat`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actMnlStat` <> isect0.`actMnlStat1` AND isect0.`actMnlStat` IS NOT NULL AND isect0.`actMnlStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actExecutingOU' =>
        array ( 'name' => 'uni actExecutingOU'
              , 'ruleAdl' => 'actExecutingOU~;actExecutingOU |- I'
              , 'origin' => 'line 39, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actExecutingOU[Activity\\*OrgUnit] is univalent'
              , 'message' => 'actExecutingOU[Activity\\*OrgUnit] is niet univalent'
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'OrgUnit'
              // original expression:
              //     -(-(actExecutingOU~;actExecutingOU) \\/ I)
              // <=> { De Morgan }
              //     actExecutingOU~;actExecutingOU/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actExecutingOU~;actExecutingOU\",\"-I\"] */
                          SELECT DISTINCT isect0.`actExecutingOU` AS src, isect0.`actExecutingOU1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actExecutingOU~\",\"actExecutingOU\"] */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU`, ECps1.`actExecutingOU` AS `actExecutingOU1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actExecutingOU`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actExecutingOU` <> isect0.`actExecutingOU1` AND isect0.`actExecutingOU` IS NOT NULL AND isect0.`actExecutingOU1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actPlan' =>
        array ( 'name' => 'uni actPlan'
              , 'ruleAdl' => 'actPlan~;actPlan |- I'
              , 'origin' => 'line 44, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actPlan[Activity\\*Plan] is univalent'
              , 'message' => 'actPlan[Activity\\*Plan] is niet univalent'
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-(actPlan~;actPlan) \\/ I)
              // <=> { De Morgan }
              //     actPlan~;actPlan/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actPlan~;actPlan\",\"-I\"] */
                          SELECT DISTINCT isect0.`actPlan` AS src, isect0.`actPlan1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actPlan~\",\"actPlan\"] */
                                 
                                 SELECT DISTINCT ECps0.`actPlan`, ECps1.`actPlan` AS `actPlan1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actPlan`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actPlan` <> isect0.`actPlan1` AND isect0.`actPlan` IS NOT NULL AND isect0.`actPlan1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actPlanStart' =>
        array ( 'name' => 'uni actPlanStart'
              , 'ruleAdl' => 'actPlanStart~;actPlanStart |- I'
              , 'origin' => 'line 49, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actPlanStart[Activity\\*Timestamp] is univalent'
              , 'message' => 'actPlanStart[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept' => 'Timestamp'
              , 'tgtConcept' => 'Timestamp'
              // original expression:
              //     -(-(actPlanStart~;actPlanStart) \\/ I)
              // <=> { De Morgan }
              //     actPlanStart~;actPlanStart/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actPlanStart~;actPlanStart\",\"-I\"] */
                          SELECT DISTINCT isect0.`actPlanStart` AS src, isect0.`actPlanStart1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actPlanStart~\",\"actPlanStart\"] */
                                 
                                 SELECT DISTINCT ECps0.`actPlanStart`, ECps1.`actPlanStart` AS `actPlanStart1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actPlanStart`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actPlanStart` <> isect0.`actPlanStart1` AND isect0.`actPlanStart` IS NOT NULL AND isect0.`actPlanStart1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actPlanEnd' =>
        array ( 'name' => 'uni actPlanEnd'
              , 'ruleAdl' => 'actPlanEnd~;actPlanEnd |- I'
              , 'origin' => 'line 51, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actPlanEnd[Activity\\*Timestamp] is univalent'
              , 'message' => 'actPlanEnd[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept' => 'Timestamp'
              , 'tgtConcept' => 'Timestamp'
              // original expression:
              //     -(-(actPlanEnd~;actPlanEnd) \\/ I)
              // <=> { De Morgan }
              //     actPlanEnd~;actPlanEnd/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actPlanEnd~;actPlanEnd\",\"-I\"] */
                          SELECT DISTINCT isect0.`actPlanEnd` AS src, isect0.`actPlanEnd1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actPlanEnd~\",\"actPlanEnd\"] */
                                 
                                 SELECT DISTINCT ECps0.`actPlanEnd`, ECps1.`actPlanEnd` AS `actPlanEnd1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actPlanEnd`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actPlanEnd` <> isect0.`actPlanEnd1` AND isect0.`actPlanEnd` IS NOT NULL AND isect0.`actPlanEnd1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actStartTime' =>
        array ( 'name' => 'uni actStartTime'
              , 'ruleAdl' => 'actStartTime~;actStartTime |- I'
              , 'origin' => 'line 53, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actStartTime[Activity\\*Timestamp] is univalent'
              , 'message' => 'actStartTime[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept' => 'Timestamp'
              , 'tgtConcept' => 'Timestamp'
              // original expression:
              //     -(-(actStartTime~;actStartTime) \\/ I)
              // <=> { De Morgan }
              //     actStartTime~;actStartTime/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actStartTime~;actStartTime\",\"-I\"] */
                          SELECT DISTINCT isect0.`actStartTime` AS src, isect0.`actStartTime1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actStartTime~\",\"actStartTime\"] */
                                 
                                 SELECT DISTINCT ECps0.`actStartTime`, ECps1.`actStartTime` AS `actStartTime1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actStartTime`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actStartTime` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actStartTime` <> isect0.`actStartTime1` AND isect0.`actStartTime` IS NOT NULL AND isect0.`actStartTime1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni actEndTime' =>
        array ( 'name' => 'uni actEndTime'
              , 'ruleAdl' => 'actEndTime~;actEndTime |- I'
              , 'origin' => 'line 55, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'actEndTime[Activity\\*Timestamp] is univalent'
              , 'message' => 'actEndTime[Activity\\*Timestamp] is niet univalent'
              , 'srcConcept' => 'Timestamp'
              , 'tgtConcept' => 'Timestamp'
              // original expression:
              //     -(-(actEndTime~;actEndTime) \\/ I)
              // <=> { De Morgan }
              //     actEndTime~;actEndTime/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actEndTime~;actEndTime\",\"-I\"] */
                          SELECT DISTINCT isect0.`actEndTime` AS src, isect0.`actEndTime1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actEndTime~\",\"actEndTime\"] */
                                 
                                 SELECT DISTINCT ECps0.`actEndTime`, ECps1.`actEndTime` AS `actEndTime1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actEndTime`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actEndTime` <> isect0.`actEndTime1` AND isect0.`actEndTime` IS NOT NULL AND isect0.`actEndTime1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni ouStatus' =>
        array ( 'name' => 'uni ouStatus'
              , 'ruleAdl' => 'ouStatus~;ouStatus |- I'
              , 'origin' => 'line 62, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'ouStatus[OrgUnit\\*Status] is univalent'
              , 'message' => 'ouStatus[OrgUnit\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(ouStatus~;ouStatus) \\/ I)
              // <=> { De Morgan }
              //     ouStatus~;ouStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ouStatus~;ouStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`ouStatus` AS src, isect0.`ouStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ouStatus~\",\"ouStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`ouStatus`, ECps1.`ouStatus` AS `ouStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit`, `ouStatus`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect0
                          WHERE isect0.`ouStatus` <> isect0.`ouStatus1` AND isect0.`ouStatus` IS NOT NULL AND isect0.`ouStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni ouMnlStat' =>
        array ( 'name' => 'uni ouMnlStat'
              , 'ruleAdl' => 'ouMnlStat~;ouMnlStat |- I'
              , 'origin' => 'line 64, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'ouMnlStat[OrgUnit\\*Status] is univalent'
              , 'message' => 'ouMnlStat[OrgUnit\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(ouMnlStat~;ouMnlStat) \\/ I)
              // <=> { De Morgan }
              //     ouMnlStat~;ouMnlStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ouMnlStat~;ouMnlStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`ouMnlStat` AS src, isect0.`ouMnlStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ouMnlStat~\",\"ouMnlStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`ouMnlStat`, ECps1.`ouMnlStat` AS `ouMnlStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `OrgUnit`, `ouMnlStat`
                                        FROM `OrgUnit`
                                        WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect0
                          WHERE isect0.`ouMnlStat` <> isect0.`ouMnlStat1` AND isect0.`ouMnlStat` IS NOT NULL AND isect0.`ouMnlStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scStatus' =>
        array ( 'name' => 'uni scStatus'
              , 'ruleAdl' => 'scStatus~;scStatus |- I'
              , 'origin' => 'line 73, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'scStatus[SvcComponent\\*Status] is univalent'
              , 'message' => 'scStatus[SvcComponent\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(scStatus~;scStatus) \\/ I)
              // <=> { De Morgan }
              //     scStatus~;scStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scStatus~;scStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`scStatus` AS src, isect0.`scStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scStatus~\",\"scStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`scStatus`, ECps1.`scStatus` AS `scStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scStatus`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`scStatus` <> isect0.`scStatus1` AND isect0.`scStatus` IS NOT NULL AND isect0.`scStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scMnlStat' =>
        array ( 'name' => 'uni scMnlStat'
              , 'ruleAdl' => 'scMnlStat~;scMnlStat |- I'
              , 'origin' => 'line 75, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'scMnlStat[SvcComponent\\*Status] is univalent'
              , 'message' => 'scMnlStat[SvcComponent\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(scMnlStat~;scMnlStat) \\/ I)
              // <=> { De Morgan }
              //     scMnlStat~;scMnlStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scMnlStat~;scMnlStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`scMnlStat` AS src, isect0.`scMnlStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scMnlStat~\",\"scMnlStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`scMnlStat`, ECps1.`scMnlStat` AS `scMnlStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scMnlStat`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`scMnlStat` <> isect0.`scMnlStat1` AND isect0.`scMnlStat` IS NOT NULL AND isect0.`scMnlStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compID' =>
        array ( 'name' => 'uni compID'
              , 'ruleAdl' => 'compID~;compID |- I'
              , 'origin' => 'line 85, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'compID[Computer\\*ComputerID] is univalent'
              , 'message' => 'compID[Computer\\*ComputerID] is niet univalent'
              , 'srcConcept' => 'ComputerID'
              , 'tgtConcept' => 'ComputerID'
              // original expression:
              //     -(-(compID~;compID) \\/ I)
              // <=> { De Morgan }
              //     compID~;compID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compID~;compID\",\"-I\"] */
                          SELECT DISTINCT isect0.`compID` AS src, isect0.`compID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compID~\",\"compID\"] */
                                 
                                 SELECT DISTINCT ECps0.`compID`, ECps1.`compID` AS `compID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compID`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compID` <> isect0.`compID1` AND isect0.`compID` IS NOT NULL AND isect0.`compID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot compID' =>
        array ( 'name' => 'tot compID'
              , 'ruleAdl' => 'I |- compID;compID~'
              , 'origin' => 'line 85, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'compID[Computer\\*ComputerID] is totaal'
              , 'message' => 'compID[Computer\\*ComputerID] is niet totaal'
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-I \\/ compID;compID~)
              // <=> { De Morgan }
              //     I/\\-(compID;compID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(compID;compID~)\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer` AS tgt
                          FROM `Computer` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"compID\",\"compID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                             FROM `Computer` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Computer`, `compID`
                                                    FROM `Computer`
                                                    WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`compID`=ECps1.`compID`
                                           ) AS cp
                                      WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Computer`=cp.`Computer1`) AND isect0.`Computer` IS NOT NULL AND isect0.`Computer` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compName' =>
        array ( 'name' => 'uni compName'
              , 'ruleAdl' => 'compName~;compName |- I'
              , 'origin' => 'line 86, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'compName[Computer\\*ComputerName] is univalent'
              , 'message' => 'compName[Computer\\*ComputerName] is niet univalent'
              , 'srcConcept' => 'ComputerName'
              , 'tgtConcept' => 'ComputerName'
              // original expression:
              //     -(-(compName~;compName) \\/ I)
              // <=> { De Morgan }
              //     compName~;compName/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compName~;compName\",\"-I\"] */
                          SELECT DISTINCT isect0.`compName` AS src, isect0.`compName1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compName~\",\"compName\"] */
                                 
                                 SELECT DISTINCT ECps0.`compName`, ECps1.`compName` AS `compName1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compName`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compName` <> isect0.`compName1` AND isect0.`compName` IS NOT NULL AND isect0.`compName1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compStatus' =>
        array ( 'name' => 'uni compStatus'
              , 'ruleAdl' => 'compStatus~;compStatus |- I'
              , 'origin' => 'line 87, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'compStatus[Computer\\*Status] is univalent'
              , 'message' => 'compStatus[Computer\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(compStatus~;compStatus) \\/ I)
              // <=> { De Morgan }
              //     compStatus~;compStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compStatus~;compStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`compStatus` AS src, isect0.`compStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compStatus~\",\"compStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`compStatus`, ECps1.`compStatus` AS `compStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compStatus`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compStatus` <> isect0.`compStatus1` AND isect0.`compStatus` IS NOT NULL AND isect0.`compStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compMnlStat' =>
        array ( 'name' => 'uni compMnlStat'
              , 'ruleAdl' => 'compMnlStat~;compMnlStat |- I'
              , 'origin' => 'line 89, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'compMnlStat[Computer\\*Status] is univalent'
              , 'message' => 'compMnlStat[Computer\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(compMnlStat~;compMnlStat) \\/ I)
              // <=> { De Morgan }
              //     compMnlStat~;compMnlStat/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compMnlStat~;compMnlStat\",\"-I\"] */
                          SELECT DISTINCT isect0.`compMnlStat` AS src, isect0.`compMnlStat1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compMnlStat~\",\"compMnlStat\"] */
                                 
                                 SELECT DISTINCT ECps0.`compMnlStat`, ECps1.`compMnlStat` AS `compMnlStat1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compMnlStat`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compMnlStat` <> isect0.`compMnlStat1` AND isect0.`compMnlStat` IS NOT NULL AND isect0.`compMnlStat1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni compOwner' =>
        array ( 'name' => 'uni compOwner'
              , 'ruleAdl' => 'compOwner~;compOwner |- I'
              , 'origin' => 'line 92, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'compOwner[Computer\\*OrgUnit] is univalent'
              , 'message' => 'compOwner[Computer\\*OrgUnit] is niet univalent'
              , 'srcConcept' => 'OrgUnit'
              , 'tgtConcept' => 'OrgUnit'
              // original expression:
              //     -(-(compOwner~;compOwner) \\/ I)
              // <=> { De Morgan }
              //     compOwner~;compOwner/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compOwner~;compOwner\",\"-I\"] */
                          SELECT DISTINCT isect0.`compOwner` AS src, isect0.`compOwner1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compOwner~\",\"compOwner\"] */
                                 
                                 SELECT DISTINCT ECps0.`compOwner`, ECps1.`compOwner` AS `compOwner1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compOwner`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compOwner` <> isect0.`compOwner1` AND isect0.`compOwner` IS NOT NULL AND isect0.`compOwner1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni nwID' =>
        array ( 'name' => 'uni nwID'
              , 'ruleAdl' => 'nwID~;nwID |- I'
              , 'origin' => 'line 25, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'nwID[Network\\*NetworkID] is univalent'
              , 'message' => 'nwID[Network\\*NetworkID] is niet univalent'
              , 'srcConcept' => 'NetworkID'
              , 'tgtConcept' => 'NetworkID'
              // original expression:
              //     -(-(nwID~;nwID) \\/ I)
              // <=> { De Morgan }
              //     nwID~;nwID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwID~;nwID\",\"-I\"] */
                          SELECT DISTINCT isect0.`nwID` AS src, isect0.`nwID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwID~\",\"nwID\"] */
                                 
                                 SELECT DISTINCT ECps0.`nwID`, ECps1.`nwID` AS `nwID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Network`, `nwID`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                      ) AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`Network`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`nwID` <> isect0.`nwID1` AND isect0.`nwID` IS NOT NULL AND isect0.`nwID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot nwID' =>
        array ( 'name' => 'tot nwID'
              , 'ruleAdl' => 'I |- nwID;nwID~'
              , 'origin' => 'line 25, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'nwID[Network\\*NetworkID] is totaal'
              , 'message' => 'nwID[Network\\*NetworkID] is niet totaal'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-I \\/ nwID;nwID~)
              // <=> { De Morgan }
              //     I/\\-(nwID;nwID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(nwID;nwID~)\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network` AS tgt
                          FROM `Network` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"nwID\",\"nwID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Network`, ECps1.`Network` AS `Network1`
                                             FROM `Network` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Network`, `nwID`
                                                    FROM `Network`
                                                    WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`nwID`=ECps1.`nwID`
                                           ) AS cp
                                      WHERE isect0.`Network`=cp.`Network` AND isect0.`Network`=cp.`Network1`) AND isect0.`Network` IS NOT NULL AND isect0.`Network` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni nwStatus' =>
        array ( 'name' => 'uni nwStatus'
              , 'ruleAdl' => 'nwStatus~;nwStatus |- I'
              , 'origin' => 'line 26, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'nwStatus[Network\\*Status] is univalent'
              , 'message' => 'nwStatus[Network\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(nwStatus~;nwStatus) \\/ I)
              // <=> { De Morgan }
              //     nwStatus~;nwStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwStatus~;nwStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`nwStatus` AS src, isect0.`nwStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwStatus~\",\"nwStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`nwStatus`, ECps1.`nwStatus` AS `nwStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Network`, `nwStatus`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`Network`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`nwStatus` <> isect0.`nwStatus1` AND isect0.`nwStatus` IS NOT NULL AND isect0.`nwStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni routerID' =>
        array ( 'name' => 'uni routerID'
              , 'ruleAdl' => 'routerID~;routerID |- I'
              , 'origin' => 'line 45, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'routerID[Router\\*RouterID] is univalent'
              , 'message' => 'routerID[Router\\*RouterID] is niet univalent'
              , 'srcConcept' => 'RouterID'
              , 'tgtConcept' => 'RouterID'
              // original expression:
              //     -(-(routerID~;routerID) \\/ I)
              // <=> { De Morgan }
              //     routerID~;routerID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerID~;routerID\",\"-I\"] */
                          SELECT DISTINCT isect0.`routerID` AS src, isect0.`routerID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerID~\",\"routerID\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerID`, ECps1.`routerID` AS `routerID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerID`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`routerID` <> isect0.`routerID1` AND isect0.`routerID` IS NOT NULL AND isect0.`routerID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot routerID' =>
        array ( 'name' => 'tot routerID'
              , 'ruleAdl' => 'I |- routerID;routerID~'
              , 'origin' => 'line 45, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'routerID[Router\\*RouterID] is totaal'
              , 'message' => 'routerID[Router\\*RouterID] is niet totaal'
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-I \\/ routerID;routerID~)
              // <=> { De Morgan }
              //     I/\\-(routerID;routerID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(routerID;routerID~)\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router` AS tgt
                          FROM `Router` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"routerID\",\"routerID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                             FROM `Router` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Router`, `routerID`
                                                    FROM `Router`
                                                    WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`routerID`=ECps1.`routerID`
                                           ) AS cp
                                      WHERE isect0.`Router`=cp.`Router` AND isect0.`Router`=cp.`Router1`) AND isect0.`Router` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni routerName' =>
        array ( 'name' => 'uni routerName'
              , 'ruleAdl' => 'routerName~;routerName |- I'
              , 'origin' => 'line 46, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'routerName[Router\\*RouterName] is univalent'
              , 'message' => 'routerName[Router\\*RouterName] is niet univalent'
              , 'srcConcept' => 'RouterName'
              , 'tgtConcept' => 'RouterName'
              // original expression:
              //     -(-(routerName~;routerName) \\/ I)
              // <=> { De Morgan }
              //     routerName~;routerName/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerName~;routerName\",\"-I\"] */
                          SELECT DISTINCT isect0.`routerName` AS src, isect0.`routerName1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerName~\",\"routerName\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerName`, ECps1.`routerName` AS `routerName1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerName`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`routerName` <> isect0.`routerName1` AND isect0.`routerName` IS NOT NULL AND isect0.`routerName1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni routerStatus' =>
        array ( 'name' => 'uni routerStatus'
              , 'ruleAdl' => 'routerStatus~;routerStatus |- I'
              , 'origin' => 'line 47, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'routerStatus[Router\\*Status] is univalent'
              , 'message' => 'routerStatus[Router\\*Status] is niet univalent'
              , 'srcConcept' => 'Status'
              , 'tgtConcept' => 'Status'
              // original expression:
              //     -(-(routerStatus~;routerStatus) \\/ I)
              // <=> { De Morgan }
              //     routerStatus~;routerStatus/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerStatus~;routerStatus\",\"-I\"] */
                          SELECT DISTINCT isect0.`routerStatus` AS src, isect0.`routerStatus1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerStatus~\",\"routerStatus\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerStatus`, ECps1.`routerStatus` AS `routerStatus1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerStatus`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`routerStatus` <> isect0.`routerStatus1` AND isect0.`routerStatus` IS NOT NULL AND isect0.`routerStatus1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni routerNW' =>
        array ( 'name' => 'uni routerNW'
              , 'ruleAdl' => 'routerNW~;routerNW |- I'
              , 'origin' => 'line 51, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'routerNW[Router\\*Network] is univalent'
              , 'message' => 'routerNW[Router\\*Network] is niet univalent'
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(routerNW~;routerNW) \\/ I)
              // <=> { De Morgan }
              //     routerNW~;routerNW/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerNW~;routerNW\",\"-I\"] */
                          SELECT DISTINCT isect0.`routerNW` AS src, isect0.`routerNW1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerNW~\",\"routerNW\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerNW`, ECps1.`routerNW` AS `routerNW1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerNW`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`routerNW` <> isect0.`routerNW1` AND isect0.`routerNW` IS NOT NULL AND isect0.`routerNW1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scID' =>
        array ( 'name' => 'uni scID'
              , 'ruleAdl' => 'scID~;scID |- I'
              , 'origin' => 'line 95, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'scID[SvcComponent\\*SvcComponentID] is univalent'
              , 'message' => 'scID[SvcComponent\\*SvcComponentID] is niet univalent'
              , 'srcConcept' => 'SvcComponentID'
              , 'tgtConcept' => 'SvcComponentID'
              // original expression:
              //     -(-(scID~;scID) \\/ I)
              // <=> { De Morgan }
              //     scID~;scID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scID~;scID\",\"-I\"] */
                          SELECT DISTINCT isect0.`scID` AS src, isect0.`scID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scID~\",\"scID\"] */
                                 
                                 SELECT DISTINCT ECps0.`scID`, ECps1.`scID` AS `scID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scID`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`scID` <> isect0.`scID1` AND isect0.`scID` IS NOT NULL AND isect0.`scID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'tot scID' =>
        array ( 'name' => 'tot scID'
              , 'ruleAdl' => 'I |- scID;scID~'
              , 'origin' => 'line 95, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'scID[SvcComponent\\*SvcComponentID] is totaal'
              , 'message' => 'scID[SvcComponent\\*SvcComponentID] is niet totaal'
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-I \\/ scID;scID~)
              // <=> { De Morgan }
              //     I/\\-(scID;scID~)
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(scID;scID~)\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent` AS tgt
                          FROM `SvcComponent` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"scID\",\"scID~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                             FROM `SvcComponent` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SvcComponent`, `scID`
                                                    FROM `SvcComponent`
                                                    WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`scID`=ECps1.`scID`
                                           ) AS cp
                                      WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`SvcComponent`=cp.`SvcComponent1`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'uni scName' =>
        array ( 'name' => 'uni scName'
              , 'ruleAdl' => 'scName~;scName |- I'
              , 'origin' => 'line 96, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'scName[SvcComponent\\*SvcComponentName] is univalent'
              , 'message' => 'scName[SvcComponent\\*SvcComponentName] is niet univalent'
              , 'srcConcept' => 'SvcComponentName'
              , 'tgtConcept' => 'SvcComponentName'
              // original expression:
              //     -(-(scName~;scName) \\/ I)
              // <=> { De Morgan }
              //     scName~;scName/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scName~;scName\",\"-I\"] */
                          SELECT DISTINCT isect0.`scName` AS src, isect0.`scName1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scName~\",\"scName\"] */
                                 
                                 SELECT DISTINCT ECps0.`scName`, ECps1.`scName` AS `scName1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scName`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`scName` <> isect0.`scName1` AND isect0.`scName` IS NOT NULL AND isect0.`scName1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Plans_Diamond' =>
        array ( 'name' => 'key_Plans_Diamond'
              , 'ruleAdl' => '(-planID!planID~/\\planID!-planID~) |- I'
              , 'origin' => 'line 4, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie Plans'
              , 'message' => ''
              , 'srcConcept' => 'Plan'
              , 'tgtConcept' => 'Plan'
              // original expression:
              //     -(-(-planID!planID~/\\planID!-planID~) \\/ I)
              // <=> { De Morgan }
              //     -planID!planID~/\\planID!-planID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-planID!planID~\",\"planID!-planID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Plan` AS src, isect0.`Plan1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-planID\",\"planID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"planID;-planID~\" ] */
                                 SELECT DISTINCT cfst.`Plan`, csnd.`Plan` AS `Plan1`
                                 FROM `Plan` AS cfst,
                                      `Plan` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"planID\",\"-planID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                          FROM `Plan` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"planID~\" ] */
                                                 SELECT DISTINCT cfst.`PlanID` AS `planID`, csnd.`Plan`
                                                 FROM `PlanID` AS cfst,
                                                      `Plan` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Plan`, `planID`
                                                          FROM `Plan`
                                                          WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`PlanID`=cp.`planID` AND csnd.`Plan`=cp.`Plan`)
                                               ) AS ECps1
                                          WHERE ECps0.`planID`=ECps1.`planID`
                                        ) AS cp
                                   WHERE cfst.`Plan`=cp.`Plan` AND csnd.`Plan`=cp.`Plan1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"planID\",\"-planID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-planID;planID~\" ] */
                                 SELECT DISTINCT cfst.`Plan`, csnd.`Plan` AS `Plan1`
                                 FROM `Plan` AS cfst,
                                      `Plan` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-planID\",\"planID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Plan`, ECps1.`Plan` AS `Plan1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"planID\" ] */
                                                 SELECT DISTINCT cfst.`Plan`, csnd.`PlanID` AS `planID`
                                                 FROM `Plan` AS cfst,
                                                      `PlanID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Plan` AS cp
                                                   WHERE cfst.`Plan`=cp.`Plan` AND csnd.`PlanID`=cp.`planID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Plan`, `planID`
                                                 FROM `Plan`
                                                 WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`planID`=ECps1.`planID`
                                        ) AS cp
                                   WHERE cfst.`Plan`=cp.`Plan` AND csnd.`Plan`=cp.`Plan1`)
                               ) AS isect1
                          WHERE (isect0.`Plan` = isect1.`Plan` AND isect0.`Plan1` = isect1.`Plan1`) AND isect0.`Plan` <> isect0.`Plan1` AND isect0.`Plan` IS NOT NULL AND isect0.`Plan1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Plans_Uni1' =>
        array ( 'name' => 'key_Plans_Uni1'
              , 'ruleAdl' => 'planID~;planID |- I'
              , 'origin' => 'line 4, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Plans'
              , 'message' => ''
              , 'srcConcept' => 'PlanID'
              , 'tgtConcept' => 'PlanID'
              // original expression:
              //     -(-(planID~;planID) \\/ I)
              // <=> { De Morgan }
              //     planID~;planID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"planID~;planID\",\"-I\"] */
                          SELECT DISTINCT isect0.`planID` AS src, isect0.`planID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"planID~\",\"planID\"] */
                                 
                                 SELECT DISTINCT ECps0.`planID`, ECps1.`planID` AS `planID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Plan`, `planID`
                                        FROM `Plan`
                                        WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL
                                      ) AS ECps0,
                                      `Plan` AS ECps1
                                 WHERE ECps0.`Plan`=ECps1.`Plan`
                               ) AS isect0
                          WHERE isect0.`planID` <> isect0.`planID1` AND isect0.`planID` IS NOT NULL AND isect0.`planID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Activities_Diamond' =>
        array ( 'name' => 'key_Activities_Diamond'
              , 'ruleAdl' => '(-actType!actType~/\\actType!-actType~)/\\(-actID!actID~/\\actID!-actID~) |- I'
              , 'origin' => 'line 29, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie Activities'
              , 'message' => ''
              , 'srcConcept' => 'Activity'
              , 'tgtConcept' => 'Activity'
              // original expression:
              //     -(-(-actType!actType~/\\actType!-actType~/\\-actID!actID~/\\actID!-actID~) \\/ I)
              // <=> { De Morgan }
              //     -actType!actType~/\\actType!-actType~/\\-actID!actID~/\\actID!-actID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-actType!actType~\",\"actType!-actType~\",\"-actID!actID~\",\"actID!-actID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Activity` AS src, isect0.`Activity1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-actType\",\"actType~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"actType;-actType~\" ] */
                                 SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                 FROM `Activity` AS cfst,
                                      `Activity` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"actType\",\"-actType~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                          FROM `Activity` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"actType~\" ] */
                                                 SELECT DISTINCT cfst.`ActivityType` AS `actType`, csnd.`Activity`
                                                 FROM `ActivityType` AS cfst,
                                                      `Activity` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Activity`, `actType`
                                                          FROM `Activity`
                                                          WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`ActivityType`=cp.`actType` AND csnd.`Activity`=cp.`Activity`)
                                               ) AS ECps1
                                          WHERE ECps0.`actType`=ECps1.`actType`
                                        ) AS cp
                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"actType\",\"-actType~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-actType;actType~\" ] */
                                 SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                 FROM `Activity` AS cfst,
                                      `Activity` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-actType\",\"actType~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"actType\" ] */
                                                 SELECT DISTINCT cfst.`Activity`, csnd.`ActivityType` AS `actType`
                                                 FROM `Activity` AS cfst,
                                                      `ActivityType` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Activity` AS cp
                                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`ActivityType`=cp.`actType`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Activity`, `actType`
                                                 FROM `Activity`
                                                 WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`actType`=ECps1.`actType`
                                        ) AS cp
                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                               ) AS isect1, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-actID\",\"actID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"actID;-actID~\" ] */
                                 SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                 FROM `Activity` AS cfst,
                                      `Activity` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"actID\",\"-actID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                          FROM `Activity` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"actID~\" ] */
                                                 SELECT DISTINCT cfst.`ActivityID` AS `actID`, csnd.`Activity`
                                                 FROM `ActivityID` AS cfst,
                                                      `Activity` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Activity`, `actID`
                                                          FROM `Activity`
                                                          WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`ActivityID`=cp.`actID` AND csnd.`Activity`=cp.`Activity`)
                                               ) AS ECps1
                                          WHERE ECps0.`actID`=ECps1.`actID`
                                        ) AS cp
                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                               ) AS isect2, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"actID\",\"-actID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-actID;actID~\" ] */
                                 SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                 FROM `Activity` AS cfst,
                                      `Activity` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-actID\",\"actID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"actID\" ] */
                                                 SELECT DISTINCT cfst.`Activity`, csnd.`ActivityID` AS `actID`
                                                 FROM `Activity` AS cfst,
                                                      `ActivityID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Activity` AS cp
                                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`ActivityID`=cp.`actID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Activity`, `actID`
                                                 FROM `Activity`
                                                 WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`actID`=ECps1.`actID`
                                        ) AS cp
                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                               ) AS isect3
                          WHERE (isect0.`Activity` = isect1.`Activity` AND isect0.`Activity1` = isect1.`Activity1`) AND (isect0.`Activity` = isect2.`Activity` AND isect0.`Activity1` = isect2.`Activity1`) AND (isect0.`Activity` = isect3.`Activity` AND isect0.`Activity1` = isect3.`Activity1`) AND isect0.`Activity` <> isect0.`Activity1` AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Activities_Uni1' =>
        array ( 'name' => 'key_Activities_Uni1'
              , 'ruleAdl' => 'actType~;actType |- I'
              , 'origin' => 'line 29, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Activities'
              , 'message' => ''
              , 'srcConcept' => 'ActivityType'
              , 'tgtConcept' => 'ActivityType'
              // original expression:
              //     -(-(actType~;actType) \\/ I)
              // <=> { De Morgan }
              //     actType~;actType/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actType~;actType\",\"-I\"] */
                          SELECT DISTINCT isect0.`actType` AS src, isect0.`actType1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actType~\",\"actType\"] */
                                 
                                 SELECT DISTINCT ECps0.`actType`, ECps1.`actType` AS `actType1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actType`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actType` <> isect0.`actType1` AND isect0.`actType` IS NOT NULL AND isect0.`actType1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Activities_Uni3' =>
        array ( 'name' => 'key_Activities_Uni3'
              , 'ruleAdl' => 'actID~;actID |- I'
              , 'origin' => 'line 29, file "CSA_Op Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Activities'
              , 'message' => ''
              , 'srcConcept' => 'ActivityID'
              , 'tgtConcept' => 'ActivityID'
              // original expression:
              //     -(-(actID~;actID) \\/ I)
              // <=> { De Morgan }
              //     actID~;actID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"actID~;actID\",\"-I\"] */
                          SELECT DISTINCT isect0.`actID` AS src, isect0.`actID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"actID~\",\"actID\"] */
                                 
                                 SELECT DISTINCT ECps0.`actID`, ECps1.`actID` AS `actID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Activity`, `actID`
                                        FROM `Activity`
                                        WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`actID` <> isect0.`actID1` AND isect0.`actID` IS NOT NULL AND isect0.`actID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Networks_Diamond' =>
        array ( 'name' => 'key_Networks_Diamond'
              , 'ruleAdl' => '(-nwID!nwID~/\\nwID!-nwID~) |- I'
              , 'origin' => 'line 24, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie Networks'
              , 'message' => ''
              , 'srcConcept' => 'Network'
              , 'tgtConcept' => 'Network'
              // original expression:
              //     -(-(-nwID!nwID~/\\nwID!-nwID~) \\/ I)
              // <=> { De Morgan }
              //     -nwID!nwID~/\\nwID!-nwID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-nwID!nwID~\",\"nwID!-nwID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Network` AS src, isect0.`Network1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-nwID\",\"nwID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"nwID;-nwID~\" ] */
                                 SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                 FROM `Network` AS cfst,
                                      `Network` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"nwID\",\"-nwID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Network`, ECps1.`Network` AS `Network1`
                                          FROM `Network` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"nwID~\" ] */
                                                 SELECT DISTINCT cfst.`NetworkID` AS `nwID`, csnd.`Network`
                                                 FROM `NetworkID` AS cfst,
                                                      `Network` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Network`, `nwID`
                                                          FROM `Network`
                                                          WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`NetworkID`=cp.`nwID` AND csnd.`Network`=cp.`Network`)
                                               ) AS ECps1
                                          WHERE ECps0.`nwID`=ECps1.`nwID`
                                        ) AS cp
                                   WHERE cfst.`Network`=cp.`Network` AND csnd.`Network`=cp.`Network1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"nwID\",\"-nwID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-nwID;nwID~\" ] */
                                 SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                 FROM `Network` AS cfst,
                                      `Network` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-nwID\",\"nwID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Network`, ECps1.`Network` AS `Network1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"nwID\" ] */
                                                 SELECT DISTINCT cfst.`Network`, csnd.`NetworkID` AS `nwID`
                                                 FROM `Network` AS cfst,
                                                      `NetworkID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Network` AS cp
                                                   WHERE cfst.`Network`=cp.`Network` AND csnd.`NetworkID`=cp.`nwID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Network`, `nwID`
                                                 FROM `Network`
                                                 WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`nwID`=ECps1.`nwID`
                                        ) AS cp
                                   WHERE cfst.`Network`=cp.`Network` AND csnd.`Network`=cp.`Network1`)
                               ) AS isect1
                          WHERE (isect0.`Network` = isect1.`Network` AND isect0.`Network1` = isect1.`Network1`) AND isect0.`Network` <> isect0.`Network1` AND isect0.`Network` IS NOT NULL AND isect0.`Network1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Networks_Uni1' =>
        array ( 'name' => 'key_Networks_Uni1'
              , 'ruleAdl' => 'nwID~;nwID |- I'
              , 'origin' => 'line 24, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Networks'
              , 'message' => ''
              , 'srcConcept' => 'NetworkID'
              , 'tgtConcept' => 'NetworkID'
              // original expression:
              //     -(-(nwID~;nwID) \\/ I)
              // <=> { De Morgan }
              //     nwID~;nwID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"nwID~;nwID\",\"-I\"] */
                          SELECT DISTINCT isect0.`nwID` AS src, isect0.`nwID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"nwID~\",\"nwID\"] */
                                 
                                 SELECT DISTINCT ECps0.`nwID`, ECps1.`nwID` AS `nwID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Network`, `nwID`
                                        FROM `Network`
                                        WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL
                                      ) AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`Network`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`nwID` <> isect0.`nwID1` AND isect0.`nwID` IS NOT NULL AND isect0.`nwID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Routers_Diamond' =>
        array ( 'name' => 'key_Routers_Diamond'
              , 'ruleAdl' => '(-routerID!routerID~/\\routerID!-routerID~) |- I'
              , 'origin' => 'line 44, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie Routers'
              , 'message' => ''
              , 'srcConcept' => 'Router'
              , 'tgtConcept' => 'Router'
              // original expression:
              //     -(-(-routerID!routerID~/\\routerID!-routerID~) \\/ I)
              // <=> { De Morgan }
              //     -routerID!routerID~/\\routerID!-routerID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-routerID!routerID~\",\"routerID!-routerID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Router` AS src, isect0.`Router1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-routerID\",\"routerID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"routerID;-routerID~\" ] */
                                 SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `Router1`
                                 FROM `Router` AS cfst,
                                      `Router` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"routerID\",\"-routerID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                          FROM `Router` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"routerID~\" ] */
                                                 SELECT DISTINCT cfst.`RouterID` AS `routerID`, csnd.`Router`
                                                 FROM `RouterID` AS cfst,
                                                      `Router` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Router`, `routerID`
                                                          FROM `Router`
                                                          WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`RouterID`=cp.`routerID` AND csnd.`Router`=cp.`Router`)
                                               ) AS ECps1
                                          WHERE ECps0.`routerID`=ECps1.`routerID`
                                        ) AS cp
                                   WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`Router1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"routerID\",\"-routerID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-routerID;routerID~\" ] */
                                 SELECT DISTINCT cfst.`Router`, csnd.`Router` AS `Router1`
                                 FROM `Router` AS cfst,
                                      `Router` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-routerID\",\"routerID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"routerID\" ] */
                                                 SELECT DISTINCT cfst.`Router`, csnd.`RouterID` AS `routerID`
                                                 FROM `Router` AS cfst,
                                                      `RouterID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Router` AS cp
                                                   WHERE cfst.`Router`=cp.`Router` AND csnd.`RouterID`=cp.`routerID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Router`, `routerID`
                                                 FROM `Router`
                                                 WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`routerID`=ECps1.`routerID`
                                        ) AS cp
                                   WHERE cfst.`Router`=cp.`Router` AND csnd.`Router`=cp.`Router1`)
                               ) AS isect1
                          WHERE (isect0.`Router` = isect1.`Router` AND isect0.`Router1` = isect1.`Router1`) AND isect0.`Router` <> isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Routers_Uni1' =>
        array ( 'name' => 'key_Routers_Uni1'
              , 'ruleAdl' => 'routerID~;routerID |- I'
              , 'origin' => 'line 44, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Routers'
              , 'message' => ''
              , 'srcConcept' => 'RouterID'
              , 'tgtConcept' => 'RouterID'
              // original expression:
              //     -(-(routerID~;routerID) \\/ I)
              // <=> { De Morgan }
              //     routerID~;routerID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"routerID~;routerID\",\"-I\"] */
                          SELECT DISTINCT isect0.`routerID` AS src, isect0.`routerID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"routerID~\",\"routerID\"] */
                                 
                                 SELECT DISTINCT ECps0.`routerID`, ECps1.`routerID` AS `routerID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Router`, `routerID`
                                        FROM `Router`
                                        WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL
                                      ) AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`routerID` <> isect0.`routerID1` AND isect0.`routerID` IS NOT NULL AND isect0.`routerID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Computers_Diamond' =>
        array ( 'name' => 'key_Computers_Diamond'
              , 'ruleAdl' => '(-compID!compID~/\\compID!-compID~) |- I'
              , 'origin' => 'line 63, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie Computers'
              , 'message' => ''
              , 'srcConcept' => 'Computer'
              , 'tgtConcept' => 'Computer'
              // original expression:
              //     -(-(-compID!compID~/\\compID!-compID~) \\/ I)
              // <=> { De Morgan }
              //     -compID!compID~/\\compID!-compID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-compID!compID~\",\"compID!-compID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Computer` AS src, isect0.`Computer1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-compID\",\"compID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"compID;-compID~\" ] */
                                 SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                 FROM `Computer` AS cfst,
                                      `Computer` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"compID\",\"-compID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                          FROM `Computer` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"compID~\" ] */
                                                 SELECT DISTINCT cfst.`ComputerID` AS `compID`, csnd.`Computer`
                                                 FROM `ComputerID` AS cfst,
                                                      `Computer` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Computer`, `compID`
                                                          FROM `Computer`
                                                          WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`ComputerID`=cp.`compID` AND csnd.`Computer`=cp.`Computer`)
                                               ) AS ECps1
                                          WHERE ECps0.`compID`=ECps1.`compID`
                                        ) AS cp
                                   WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"compID\",\"-compID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-compID;compID~\" ] */
                                 SELECT DISTINCT cfst.`Computer`, csnd.`Computer` AS `Computer1`
                                 FROM `Computer` AS cfst,
                                      `Computer` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-compID\",\"compID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"compID\" ] */
                                                 SELECT DISTINCT cfst.`Computer`, csnd.`ComputerID` AS `compID`
                                                 FROM `Computer` AS cfst,
                                                      `ComputerID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Computer` AS cp
                                                   WHERE cfst.`Computer`=cp.`Computer` AND csnd.`ComputerID`=cp.`compID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Computer`, `compID`
                                                 FROM `Computer`
                                                 WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`compID`=ECps1.`compID`
                                        ) AS cp
                                   WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Computer`=cp.`Computer1`)
                               ) AS isect1
                          WHERE (isect0.`Computer` = isect1.`Computer` AND isect0.`Computer1` = isect1.`Computer1`) AND isect0.`Computer` <> isect0.`Computer1` AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Computers_Uni1' =>
        array ( 'name' => 'key_Computers_Uni1'
              , 'ruleAdl' => 'compID~;compID |- I'
              , 'origin' => 'line 63, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Computers'
              , 'message' => ''
              , 'srcConcept' => 'ComputerID'
              , 'tgtConcept' => 'ComputerID'
              // original expression:
              //     -(-(compID~;compID) \\/ I)
              // <=> { De Morgan }
              //     compID~;compID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"compID~;compID\",\"-I\"] */
                          SELECT DISTINCT isect0.`compID` AS src, isect0.`compID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"compID~\",\"compID\"] */
                                 
                                 SELECT DISTINCT ECps0.`compID`, ECps1.`compID` AS `compID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Computer`, `compID`
                                        FROM `Computer`
                                        WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL
                                      ) AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`compID` <> isect0.`compID1` AND isect0.`compID` IS NOT NULL AND isect0.`compID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_SvcComponents_Diamond' =>
        array ( 'name' => 'key_SvcComponents_Diamond'
              , 'ruleAdl' => '(-scID!scID~/\\scID!-scID~) |- I'
              , 'origin' => 'line 94, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie SvcComponents'
              , 'message' => ''
              , 'srcConcept' => 'SvcComponent'
              , 'tgtConcept' => 'SvcComponent'
              // original expression:
              //     -(-(-scID!scID~/\\scID!-scID~) \\/ I)
              // <=> { De Morgan }
              //     -scID!scID~/\\scID!-scID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-scID!scID~\",\"scID!-scID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`SvcComponent1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-scID\",\"scID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"scID;-scID~\" ] */
                                 SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent` AS cfst,
                                      `SvcComponent` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"scID\",\"-scID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                          FROM `SvcComponent` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"scID~\" ] */
                                                 SELECT DISTINCT cfst.`SvcComponentID` AS `scID`, csnd.`SvcComponent`
                                                 FROM `SvcComponentID` AS cfst,
                                                      `SvcComponent` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `SvcComponent`, `scID`
                                                          FROM `SvcComponent`
                                                          WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`SvcComponentID`=cp.`scID` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                               ) AS ECps1
                                          WHERE ECps0.`scID`=ECps1.`scID`
                                        ) AS cp
                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"scID\",\"-scID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-scID;scID~\" ] */
                                 SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponent` AS `SvcComponent1`
                                 FROM `SvcComponent` AS cfst,
                                      `SvcComponent` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-scID\",\"scID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`SvcComponent` AS `SvcComponent1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"scID\" ] */
                                                 SELECT DISTINCT cfst.`SvcComponent`, csnd.`SvcComponentID` AS `scID`
                                                 FROM `SvcComponent` AS cfst,
                                                      `SvcComponentID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `SvcComponent` AS cp
                                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponentID`=cp.`scID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `SvcComponent`, `scID`
                                                 FROM `SvcComponent`
                                                 WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`scID`=ECps1.`scID`
                                        ) AS cp
                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`SvcComponent`=cp.`SvcComponent1`)
                               ) AS isect1
                          WHERE (isect0.`SvcComponent` = isect1.`SvcComponent` AND isect0.`SvcComponent1` = isect1.`SvcComponent1`) AND isect0.`SvcComponent` <> isect0.`SvcComponent1` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`SvcComponent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_SvcComponents_Uni1' =>
        array ( 'name' => 'key_SvcComponents_Uni1'
              , 'ruleAdl' => 'scID~;scID |- I'
              , 'origin' => 'line 94, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie SvcComponents'
              , 'message' => ''
              , 'srcConcept' => 'SvcComponentID'
              , 'tgtConcept' => 'SvcComponentID'
              // original expression:
              //     -(-(scID~;scID) \\/ I)
              // <=> { De Morgan }
              //     scID~;scID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"scID~;scID\",\"-I\"] */
                          SELECT DISTINCT isect0.`scID` AS src, isect0.`scID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"scID~\",\"scID\"] */
                                 
                                 SELECT DISTINCT ECps0.`scID`, ECps1.`scID` AS `scID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SvcComponent`, `scID`
                                        FROM `SvcComponent`
                                        WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL
                                      ) AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`scID` <> isect0.`scID1` AND isect0.`scID` IS NOT NULL AND isect0.`scID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Services_Diamond' =>
        array ( 'name' => 'key_Services_Diamond'
              , 'ruleAdl' => '(-svcID!svcID~/\\svcID!-svcID~) |- I'
              , 'origin' => 'line 115, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Diamantregel, volgend uit key-declaratie Services'
              , 'message' => ''
              , 'srcConcept' => 'Service'
              , 'tgtConcept' => 'Service'
              // original expression:
              //     -(-(-svcID!svcID~/\\svcID!-svcID~) \\/ I)
              // <=> { De Morgan }
              //     -svcID!svcID~/\\svcID!-svcID~/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"-svcID!svcID~\",\"svcID!-svcID~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Service` AS src, isect0.`Service1` AS tgt
                          FROM 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"-svcID\",\"svcID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"svcID;-svcID~\" ] */
                                 SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                 FROM `Service` AS cfst,
                                      `Service` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"svcID\",\"-svcID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                          FROM `Service` AS ECps0,
                                               
                                               ( /* case: ECpl e
                                                    ECpl [ \"svcID~\" ] */
                                                 SELECT DISTINCT cfst.`ServiceID` AS `svcID`, csnd.`Service`
                                                 FROM `ServiceID` AS cfst,
                                                      `Service` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM 
                                                        ( /* case: EFlp x. */
                                                          SELECT DISTINCT `Service`, `svcID`
                                                          FROM `Service`
                                                          WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                                        ) AS cp
                                                   WHERE cfst.`ServiceID`=cp.`svcID` AND csnd.`Service`=cp.`Service`)
                                               ) AS ECps1
                                          WHERE ECps0.`svcID`=ECps1.`svcID`
                                        ) AS cp
                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                               ) AS isect0, 
                               ( /* case: ERad es@(_:_:_)
                                    ERad [\"svcID\",\"-svcID~\"] */
                                 /* case: ECpl e
                                    ECpl [ \"-svcID;svcID~\" ] */
                                 SELECT DISTINCT cfst.`Service`, csnd.`Service` AS `Service1`
                                 FROM `Service` AS cfst,
                                      `Service` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (ECps es), with two or more elements in es.
                                             ECps [\"-svcID\",\"svcID~\"] */
                                          
                                          SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl [ \"svcID\" ] */
                                                 SELECT DISTINCT cfst.`Service`, csnd.`ServiceID` AS `svcID`
                                                 FROM `Service` AS cfst,
                                                      `ServiceID` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Service` AS cp
                                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`ServiceID`=cp.`svcID`)
                                               ) AS ECps0,
                                               
                                               ( /* case: EFlp x. */
                                                 SELECT DISTINCT `Service`, `svcID`
                                                 FROM `Service`
                                                 WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                               ) AS ECps1
                                          WHERE ECps0.`svcID`=ECps1.`svcID`
                                        ) AS cp
                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`Service`=cp.`Service1`)
                               ) AS isect1
                          WHERE (isect0.`Service` = isect1.`Service` AND isect0.`Service1` = isect1.`Service1`) AND isect0.`Service` <> isect0.`Service1` AND isect0.`Service` IS NOT NULL AND isect0.`Service1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'key_Services_Uni1' =>
        array ( 'name' => 'key_Services_Uni1'
              , 'ruleAdl' => 'svcID~;svcID |- I'
              , 'origin' => 'line 115, file "..\\\\CyberSA\\\\CSA_Ontology.adl"'
              , 'meaning' => 'Univalentie, volgend uit key-declaratie Services'
              , 'message' => ''
              , 'srcConcept' => 'ServiceID'
              , 'tgtConcept' => 'ServiceID'
              // original expression:
              //     -(-(svcID~;svcID) \\/ I)
              // <=> { De Morgan }
              //     svcID~;svcID/\\-I
              // which is the expression to transform to SQL, that computes violations.
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"svcID~;svcID\",\"-I\"] */
                          SELECT DISTINCT isect0.`svcID` AS src, isect0.`svcID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"svcID~\",\"svcID\"] */
                                 
                                 SELECT DISTINCT ECps0.`svcID`, ECps1.`svcID` AS `svcID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Service`, `svcID`
                                        FROM `Service`
                                        WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL
                                      ) AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`svcID` <> isect0.`svcID1` AND isect0.`svcID` IS NOT NULL AND isect0.`svcID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    );

$invariantRuleNames = array ('uni planCmpStat', 'sym atStatusIsGreen', 'asy atStatusIsGreen', 'uni atStatusIsGreen', 'inj atStatusIsGreen', 'uni actCmpStat', 'uni ouCmpStat', 'uni scCmpStat', 'uni compCmpStat', 'sym nwAllCompCommReqsSatisfied', 'asy nwAllCompCommReqsSatisfied', 'uni nwAllCompCommReqsSatisfied', 'inj nwAllCompCommReqsSatisfied', 'sym nwNoCompCommReqsSatisfied', 'asy nwNoCompCommReqsSatisfied', 'uni nwNoCompCommReqsSatisfied', 'inj nwNoCompCommReqsSatisfied', 'sym routerAllCommReqsSatisfied', 'asy routerAllCommReqsSatisfied', 'uni routerAllCommReqsSatisfied', 'inj routerAllCommReqsSatisfied', 'sym routerNoCommReqsSatisfied', 'asy routerNoCommReqsSatisfied', 'uni routerNoCommReqsSatisfied', 'inj routerNoCommReqsSatisfied', 'sym compRequiresComm', 'asy compRequiresComm', 'uni compRequiresComm', 'inj compRequiresComm', 'sym compAllReqCommSatisfied', 'asy compAllReqCommSatisfied', 'uni compAllReqCommSatisfied', 'inj compAllReqCommSatisfied', 'sym compNoReqCommSatisfied', 'asy compNoReqCommSatisfied', 'uni compNoReqCommSatisfied', 'inj compNoReqCommSatisfied', 'sym scAllReqCommSatisfied', 'asy scAllReqCommSatisfied', 'uni scAllReqCommSatisfied', 'inj scAllReqCommSatisfied', 'sym scNoReqCommSatisfied', 'asy scNoReqCommSatisfied', 'uni scNoReqCommSatisfied', 'inj scNoReqCommSatisfied', 'sym svcAllSvcCompReqsSatisfied', 'asy svcAllSvcCompReqsSatisfied', 'uni svcAllSvcCompReqsSatisfied', 'inj svcAllSvcCompReqsSatisfied', 'sym svcNoSvcCompReqsSatisfied', 'asy svcNoSvcCompReqsSatisfied', 'uni svcNoSvcCompReqsSatisfied', 'inj svcNoSvcCompReqsSatisfied', 'sym connectComputerToNetworkRouter', 'asy connectComputerToNetworkRouter', 'uni connectComputerToNetworkRouter', 'inj connectComputerToNetworkRouter', 'sym startRunningServiceComponents', 'asy startRunningServiceComponents', 'uni startRunningServiceComponents', 'inj startRunningServiceComponents', 'uni planID', 'tot planID', 'uni planStatus', 'uni planMnlStat', 'uni atStatus', 'uni svcID', 'tot svcID', 'uni svcStatus', 'uni actType', 'tot actType', 'uni actID', 'tot actID', 'uni actStatus', 'uni actMnlStat', 'uni actExecutingOU', 'uni actPlan', 'uni actPlanStart', 'uni actPlanEnd', 'uni actStartTime', 'uni actEndTime', 'uni ouStatus', 'uni ouMnlStat', 'uni scStatus', 'uni scMnlStat', 'uni compID', 'tot compID', 'uni compName', 'uni compStatus', 'uni compMnlStat', 'uni compOwner', 'uni nwID', 'tot nwID', 'uni nwStatus', 'uni routerID', 'tot routerID', 'uni routerName', 'uni routerStatus', 'uni routerNW', 'uni scID', 'tot scID', 'uni scName', 'key_Plans_Diamond', 'key_Plans_Uni1', 'key_Activities_Diamond', 'key_Activities_Uni1', 'key_Activities_Uni3', 'key_Networks_Diamond', 'key_Networks_Uni1', 'key_Routers_Diamond', 'key_Routers_Uni1', 'key_Computers_Diamond', 'key_Computers_Uni1', 'key_SvcComponents_Diamond', 'key_SvcComponents_Uni1', 'key_Services_Diamond', 'key_Services_Uni1', 'rrtStar Transitive closure integrity', 'Yes/No answer integrity', 'Activity executor must exist', 'Activity plan must exist', 'Router naming integrity', 'Computer naming integrity', 'Service - component integrity', 'SvcComponent naming integrity');

$allRoles =
  array
    ( array ( 'name' => 'Developer'
            , 'ruleNames' => array ('ActivityType OrgUnits', 'Service implementation', 'Capability relevance', 'SvcComponent assignment', 'Activity Integrity', 'Connect computer to network router', 'Create router paths', 'Routes to be discarded', 'Computers to be disconnected', 'Set up computer-computer communications', 'Start running service components', 'Connect computer to network router', 'Create router paths', 'Routes to be discarded', 'Computers to be disconnected', 'Set up computer-computer communications', 'Start running service components', 'Network status integrity check', 'Router status integrity check', 'Computer status integrity check', 'SvcComponent status integrity check', 'Service status integrity check')
            )
    , array ( 'name' => 'ExecEngine'
            , 'ruleNames' => array ('insouMayExecuteAT', 'delouMayExecuteAT', 'planCmpStatIsRed', 'planCmpStatIsYellow', 'planCmpStatIsGreen', 'InsPlanStatus', 'defaultPlanStatus', 'insatStatusIsGreen', 'delatStatusIsGreen', 'atStatusIsYellow', 'atStatusIsRed', 'actCmpStatIsRed', 'actCmpStatIsYellow', 'actCmpStatIsGreen', 'InsActivityStatus', 'defaultActivityStatus', 'InsOrgUnitStatus', 'defaultOrgUnitStatus', 'InsSvcComponentStatus', 'defaultSvcComponentStatus', 'InsComputerStatus', 'defaultComputerStatus', 'Create path within network', 'Remove routes from non-network routers', 'Remove computers from non-network routers', 'InsnwAllCompCommReqsSatisfied', 'DelnwAllCompCommReqsSatisfied', 'InsnwNoCompCommReqsSatisfied', 'DelnwNoCompCommReqsSatisfied', 'rrtCompTransitiveClosure', 'InsrouterNeedsPathTo', 'DelrouterNeedsPathTo', 'InsrouterAllCommReqsSatisfied', 'DelrouterAllCommReqsSatisfied', 'InsrouterNoCommReqsSatisfied', 'DelrouterNoCommReqsSatisfied', 'InscompReqCommWith', 'DelcompReqCommWith', 'InscompHasCommWith', 'DelcompHasCommWith', 'InscompRequiresComm', 'DelcompRequiresComm', 'InscompAllReqCommSatisfied', 'DelCompAllReqCommSatisfied', 'InscompNoReqCommSatisfied', 'DelCompNoReqCommSatisfied', 'InsscHasCommWith', 'DelscHasCommWith', 'InsscAllReqCommSatisfied', 'DelscAllReqCommSatisfied', 'InsscNoReqCommSatisfied', 'DelscNoReqCommSatisfied', 'InssvcAllSvcCompReqsSatisfied', 'DelsvcAllSvcCompReqsSatisfied', 'InssvcNoSvcCompReqsSatisfied', 'DelsvcNoSvcCompReqsSatisfied', 'Router network integrity', 'insconnectComputerToNetworkRouter', 'delconnectComputerToNetworkRouter', 'insroutesToBeDiscarded', 'delroutesToBeDiscarded', 'inscomputerToBeDisconnected', 'delcomputerToBeDisconnected', 'inssetupComputerComputerCommunications', 'delsetupComputerComputerCommunications', 'insstartRunningServiceComponents', 'delstartRunningServiceComponents', 'Network status \'Green\'', 'Network status \'Yellow\'', 'Network status \'Red\'', 'Network status \'Blue\'', 'Router status \'Green\'', 'Router status \'Yellow\'', 'Router status \'Red\'', 'Router status \'Blue\'', 'Computer status \'Green\'', 'Computer status \'Yellow\'', 'Computer status \'Red\'', 'Computer status \'Black\'', 'Computer status \'Blue\'', 'Computer status \'White\'', 'SvcComponent status \'Green\'', 'SvcComponent status \'Yellow\'', 'SvcComponent status \'Red\'', 'SvcComponent status \'Black\'', 'SvcComponent status \'Blue\'', 'SvcComponent status \'White\'', 'Service status \'Green\'', 'Service status \'Yellow\'', 'Service status \'Red\'')
            )
    );

$allKeys =
  array
    (   array ( 'label' => 'Plans'
              , 'concept' => 'Plan'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: planID
                            , 'expSQL' =>
                                'SELECT DISTINCT `Plan` AS src, `planID` AS tgt
                                 FROM `Plan`
                                 WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Activities'
              , 'concept' => 'Activity'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: actType
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `actType` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => ':')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: actID
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS src, `actID` AS tgt
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Networks'
              , 'concept' => 'Network'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: nwID
                            , 'expSQL' =>
                                'SELECT DISTINCT `Network` AS src, `nwID` AS tgt
                                 FROM `Network`
                                 WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Routers'
              , 'concept' => 'Router'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: routerID
                            , 'expSQL' =>
                                'SELECT DISTINCT `Router` AS src, `routerID` AS tgt
                                 FROM `Router`
                                 WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Computers'
              , 'concept' => 'Computer'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: compID
                            , 'expSQL' =>
                                'SELECT DISTINCT `Computer` AS src, `compID` AS tgt
                                 FROM `Computer`
                                 WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'SvcComponents'
              , 'concept' => 'SvcComponent'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: scID
                            , 'expSQL' =>
                                'SELECT DISTINCT `SvcComponent` AS src, `scID` AS tgt
                                 FROM `SvcComponent`
                                 WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Services'
              , 'concept' => 'Service'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: svcID
                            , 'expSQL' =>
                                'SELECT DISTINCT `Service` AS src, `svcID` AS tgt
                                 FROM `Service`
                                 WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL' )
                    )
            )
    );

$allInterfaceObjects =
  array
    ( // Top-level interface OVERVIEW for all roles:
      'OVERVIEW' => 
      array ( 'name' => 'OVERVIEW'
            // original expression: I[ONE]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Plans'
                          // original expression: V[ONE*Plan]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Plan'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Plan]\" ] */
                                                SELECT DISTINCT 1 AS src, `Plan`.`actPlan` AS tgt
                                                FROM `Activity` AS `Plan`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Plan'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Plan'
                                        , 'expressionSQL' => 'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                                              FROM `Activity`
                                                              WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: planStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planStatus` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Activity Types'
                          // original expression: V[ONE*ActivityType]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*ActivityType]\" ] */
                                                SELECT DISTINCT 1 AS src, `ActivityType`.`ActivityType` AS tgt
                                                FROM `ActivityType` AS `ActivityType`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ActivityType'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: atStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `atStatus` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Activities'
                          // original expression: V[ONE*Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Activity]\" ] */
                                                SELECT DISTINCT 1 AS src, `Activity`.`Activity` AS tgt
                                                FROM `Activity` AS `Activity`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Activity'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: actStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actStatus` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'OrgUnits'
                          // original expression: V[ONE*OrgUnit]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*OrgUnit]\" ] */
                                                SELECT DISTINCT 1 AS src, `OrgUnit`.`actExecutingOU` AS tgt
                                                FROM `Activity` AS `OrgUnit`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Org.Unit'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => 'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                                              FROM `Activity`
                                                              WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: ouStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ouStatus` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'SvcComponents'
                          // original expression: V[ONE*SvcComponent]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*SvcComponent]\" ] */
                                                SELECT DISTINCT 1 AS src, `SvcComponent`.`SvcComponent` AS tgt
                                                FROM `SvcComponent` AS `SvcComponent`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'SvcComponent'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: scStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scStatus` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Computers'
                          // original expression: V[ONE*Computer]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Computer]\" ] */
                                                SELECT DISTINCT 1 AS src, `Computer`.`Computer` AS tgt
                                                FROM `Computer` AS `Computer`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: compStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Services'
                          // original expression: V[ONE*Service]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Service]\" ] */
                                                SELECT DISTINCT 1 AS src, `Service`.`Service` AS tgt
                                                FROM `Service` AS `Service`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Service'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: svcStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `svcStatus` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Networks'
                          // original expression: V[ONE*Network]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Network]\" ] */
                                                SELECT DISTINCT 1 AS src, `Network`.`Network` AS tgt
                                                FROM `Network` AS `Network`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Network'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Network'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: nwStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `nwStatus` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Routers'
                          // original expression: V[ONE*Router]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Router]\" ] */
                                                SELECT DISTINCT 1 AS src, `Router`.`Router` AS tgt
                                                FROM `Router` AS `Router`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Router'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: routerStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capabilities'
                          // original expression: V[ONE*Capability]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Capability]\" ] */
                                                SELECT DISTINCT 1 AS src, `Capability`.`Capability` AS tgt
                                                FROM `Capability` AS `Capability`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Plan for all roles:
      'Plan' => 
      array ( 'name' => 'Plan'
            // original expression: I[Plan]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('PlanID', 'Status', 'ActivityType', 'Activity')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Plan'
            , 'tgtConcept' => 'Plan'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                  FROM `Activity`
                                  WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Plan'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Plan'
                          , 'expressionSQL' => 'SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                                FROM `Activity`
                                                WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // original expression: planID
                                        , 'relation' => 'planID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'PlanID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planID` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: planStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planStatus` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // original expression: planMnlStat
                                        , 'relation' => 'planMnlStat'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `planMnlStat` AS tgt
                                                              FROM `Plan`
                                                              WHERE `Plan` IS NOT NULL AND `planMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capabilities'
                          // original expression:
                          //     (actPlan~;actType \\/ planAT);atReqsCpb
                          // <=> { distribute \\/ over ; }
                          //     actPlan~;actType;atReqsCpb \\/ planAT;atReqsCpb
                          // which is the expression to transform to SQL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => '/* case: EUni es
                                                   EUni [\"actPlan~;actType;atReqsCpb\",\"planAT;atReqsCpb\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"actPlan~\",\"actType\",\"atReqsCpb\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`actPlan` AS src, ECps2.`Capability` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Activity`, `actPlan`
                                                           FROM `Activity`
                                                           WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL
                                                         ) AS ECps0,
                                                         `Activity` AS ECps1,
                                                         `atReqsCpb` AS ECps2
                                                    WHERE ECps0.`Activity`=ECps1.`Activity`
                                                      AND ECps1.`actType`=ECps2.`ActivityType`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"planAT\",\"atReqsCpb\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`Plan` AS src, ECps1.`Capability` AS tgt
                                                    FROM `planAT` AS ECps0,
                                                         `atReqsCpb` AS ECps1
                                                    WHERE ECps0.`ActivityType`=ECps1.`ActivityType`
                                                
                                                )'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Activity types'
                          // original expression: planAT
                          , 'relation' => 'planAT'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => 'SELECT DISTINCT `Plan` AS src, `ActivityType` AS tgt
                                                FROM `planAT`
                                                WHERE `Plan` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Activities'
                          // original expression: actPlan~
                          , 'relation' => 'actPlan'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Activity` AS tgt, `actPlan` AS src
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[Plan]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Plan'
                          , 'tgtConcept' => 'Plan'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `actPlan` AS src, `actPlan` AS tgt
                                                FROM `Activity`
                                                WHERE `actPlan` IS NOT NULL AND `actPlan` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ActivityTypes that require Services that have no implementation'
                                        // original expression:
                                        //     planAT;(I/\\atReqsSvc;(I/\\-(scImplements~;scImplements));atReqsSvc~)
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"planAT\",\"I/\\\\atReqsSvc;(I/\\\\-(scImplements~;scImplements));atReqsSvc~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Plan` AS src, ECps1.`ActivityType1` AS tgt
                                                              FROM `planAT` AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst@(_:_:_))
                                                                        EIsc [\"I\",\"atReqsSvc;(I/\\\\-(scImplements~;scImplements));atReqsSvc~\"] */
                                                                     SELECT DISTINCT isect0.`ActivityType`, isect0.`ActivityType1`
                                                                     FROM 
                                                                          ( /* case: (ECps es), with two or more elements in es.
                                                                               ECps [\"atReqsSvc\",\"I/\\\\-(scImplements~;scImplements)\",\"atReqsSvc~\"] */
                                                                            
                                                                            SELECT DISTINCT ECps0.`ActivityType`, ECps2.`ActivityType` AS `ActivityType1`
                                                                            FROM `atReqsSvc` AS ECps0,
                                                                                 
                                                                                 ( /* case: (EIsc lst@(_:_:_))
                                                                                      EIsc [\"I\",\"-(scImplements~;scImplements)\"] */
                                                                                   SELECT DISTINCT isect0.`Service`, isect0.`Service` AS `Service1`
                                                                                   FROM `Service` AS isect0
                                                                                   WHERE NOT EXISTS (SELECT * FROM 
                                                                                                    ( /* case: (ECps es), with two or more elements in es.
                                                                                                         ECps [\"scImplements~\",\"scImplements\"] */
                                                                                                      
                                                                                                      SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                                                                                      FROM 
                                                                                                           ( /* case: EFlp x. */
                                                                                                             SELECT DISTINCT `SvcComponent`, `Service`
                                                                                                             FROM `scImplements`
                                                                                                             WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                                           ) AS ECps0,
                                                                                                           `scImplements` AS ECps1
                                                                                                      WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                                                                    ) AS cp
                                                                                               WHERE isect0.`Service`=cp.`Service` AND isect0.`Service`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service` IS NOT NULL
                                                                                 ) AS ECps1,
                                                                                 
                                                                                 ( /* case: EFlp x. */
                                                                                   SELECT DISTINCT `ActivityType`, `Service`
                                                                                   FROM `atReqsSvc`
                                                                                   WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL
                                                                                 ) AS ECps2
                                                                            WHERE ECps0.`Service`=ECps1.`Service`
                                                                              AND ECps1.`Service1`=ECps2.`Service`
                                                                          ) AS isect0, `ActivityType` AS isect1
                                                                     WHERE isect0.`ActivityType` = isect0.`ActivityType1` AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType1` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`ActivityType`=ECps1.`ActivityType`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'ActivityTypes for which no OrgUnit is qualified'
                                        // original expression:
                                        //     planAT;(I/\\-(ouMayExecuteAT~;ouMayExecuteAT))
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Plan'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"planAT\",\"I/\\\\-(ouMayExecuteAT~;ouMayExecuteAT)\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Plan` AS src, ECps1.`ActivityType1` AS tgt
                                                              FROM `planAT` AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst@(_:_:_))
                                                                        EIsc [\"I\",\"-(ouMayExecuteAT~;ouMayExecuteAT)\"] */
                                                                     SELECT DISTINCT isect0.`ActivityType`, isect0.`ActivityType` AS `ActivityType1`
                                                                     FROM `ActivityType` AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                      ( /* case: (ECps es), with two or more elements in es.
                                                                                           ECps [\"ouMayExecuteAT~\",\"ouMayExecuteAT\"] */
                                                                                        
                                                                                        SELECT DISTINCT ECps0.`ActivityType`, ECps1.`ActivityType` AS `ActivityType1`
                                                                                        FROM 
                                                                                             ( /* case: EFlp x. */
                                                                                               SELECT DISTINCT `OrgUnit`, `ActivityType`
                                                                                               FROM `ouMayExecuteAT`
                                                                                               WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL
                                                                                             ) AS ECps0,
                                                                                             `ouMayExecuteAT` AS ECps1
                                                                                        WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                                                                                      ) AS cp
                                                                                 WHERE isect0.`ActivityType`=cp.`ActivityType` AND isect0.`ActivityType`=cp.`ActivityType1`) AND isect0.`ActivityType` IS NOT NULL AND isect0.`ActivityType` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`ActivityType`=ECps1.`ActivityType`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface ActivityType for all roles:
      'ActivityType' => 
      array ( 'name' => 'ActivityType'
            // original expression: I[ActivityType]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Capability', 'Service', 'Activity')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ActivityType'
            , 'tgtConcept' => 'ActivityType'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                  FROM `ActivityType`
                                  WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'ActivityType'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                FROM `ActivityType`
                                                WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: atStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `atStatus` AS tgt
                                                              FROM `ActivityType`
                                                              WHERE `ActivityType` IS NOT NULL AND `atStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Req\'d Capabilities'
                          // original expression: atReqsCpb
                          , 'relation' => 'atReqsCpb'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `Capability` AS tgt
                                                FROM `atReqsCpb`
                                                WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Req\'d InfoServices'
                          // original expression: atReqsSvc
                          , 'relation' => 'atReqsSvc'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `ActivityType` AS src, `Service` AS tgt
                                                FROM `atReqsSvc`
                                                WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Instances'
                          // original expression: actType~
                          , 'relation' => 'actType'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Activity` AS tgt, `actType` AS src
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[ActivityType]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ActivityType'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `ActivityType` AS src, `ActivityType` AS tgt
                                                FROM `ActivityType`
                                                WHERE `ActivityType` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Required Services that have no implementation'
                                        // original expression:
                                        //     atReqsSvc;(I/\\-(scImplements~;scImplements))
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"atReqsSvc\",\"I/\\\\-(scImplements~;scImplements)\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`ActivityType` AS src, ECps1.`Service1` AS tgt
                                                              FROM `atReqsSvc` AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst@(_:_:_))
                                                                        EIsc [\"I\",\"-(scImplements~;scImplements)\"] */
                                                                     SELECT DISTINCT isect0.`Service`, isect0.`Service` AS `Service1`
                                                                     FROM `Service` AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                      ( /* case: (ECps es), with two or more elements in es.
                                                                                           ECps [\"scImplements~\",\"scImplements\"] */
                                                                                        
                                                                                        SELECT DISTINCT ECps0.`Service`, ECps1.`Service` AS `Service1`
                                                                                        FROM 
                                                                                             ( /* case: EFlp x. */
                                                                                               SELECT DISTINCT `SvcComponent`, `Service`
                                                                                               FROM `scImplements`
                                                                                               WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                                                             ) AS ECps0,
                                                                                             `scImplements` AS ECps1
                                                                                        WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                                                      ) AS cp
                                                                                 WHERE isect0.`Service`=cp.`Service` AND isect0.`Service`=cp.`Service1`) AND isect0.`Service` IS NOT NULL AND isect0.`Service` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`Service`=ECps1.`Service`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'List of qualified OrgUnits'
                                        // original expression: -atReqsCpb!ouQualifiedFor~
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ActivityType'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* case: ERad es@(_:_:_)
                                                                 ERad [\"-atReqsCpb\",\"ouQualifiedFor~\"] */
                                                              /* case: ECpl e
                                                                 ECpl [ \"atReqsCpb;-ouQualifiedFor~\" ] */
                                                              SELECT DISTINCT cfst.`ActivityType` AS src, csnd.`OrgUnit` AS tgt
                                                              FROM `ActivityType` AS cfst,
                                                                   `OrgUnit` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM 
                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                          ECps [\"atReqsCpb\",\"-ouQualifiedFor~\"] */
                                                                       
                                                                       SELECT DISTINCT ECps0.`ActivityType`, ECps1.`OrgUnit`
                                                                       FROM `atReqsCpb` AS ECps0,
                                                                            
                                                                            ( /* case: ECpl e
                                                                                 ECpl [ \"ouQualifiedFor~\" ] */
                                                                              SELECT DISTINCT cfst.`Capability`, csnd.`OrgUnit`
                                                                              FROM `Capability` AS cfst,
                                                                                   `OrgUnit` AS csnd
                                                                              WHERE NOT EXISTS
                                                                               (SELECT * FROM 
                                                                                     ( /* case: EFlp x. */
                                                                                       SELECT DISTINCT `OrgUnit`, `Capability`
                                                                                       FROM `ouQualifiedFor`
                                                                                       WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL
                                                                                     ) AS cp
                                                                                WHERE cfst.`Capability`=cp.`Capability` AND csnd.`OrgUnit`=cp.`OrgUnit`)
                                                                            ) AS ECps1
                                                                       WHERE ECps0.`Capability`=ECps1.`Capability`
                                                                     ) AS cp
                                                                WHERE cfst.`ActivityType`=cp.`ActivityType` AND csnd.`OrgUnit`=cp.`OrgUnit`)'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Activity for all roles:
      'Activity' => 
      array ( 'name' => 'Activity'
            // original expression: I[Activity]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('ActivityType', 'ActivityID', 'Status', 'OrgUnit', 'Timestamp', 'Timestamp', 'Timestamp', 'Timestamp', 'SvcComponent')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Activity'
            , 'tgtConcept' => 'Activity'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                  FROM `Activity`
                                  WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Activity'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Type'
                                        // original expression: actType
                                        , 'relation' => 'actType'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'ActivityType'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actType` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actType` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'ID'
                                        // original expression: actID
                                        , 'relation' => 'actID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'ActivityID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actID` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: actStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actStatus` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // original expression: actMnlStat
                                        , 'relation' => 'actMnlStat'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actMnlStat` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Plan'
                                        // original expression: actPlan
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Plan'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actPlan` AS tgt
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actPlan` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Required Services'
                                        // original expression: actType;atReqsSvc
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"actType\",\"atReqsSvc\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Activity` AS src, ECps1.`Service` AS tgt
                                                              FROM `Activity` AS ECps0,
                                                                   `atReqsSvc` AS ECps1
                                                              WHERE ECps0.`actType`=ECps1.`ActivityType`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Executed by'
                          // original expression: actExecutingOU
                          , 'relation' => 'actExecutingOU'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actExecutingOU` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Planned start time'
                          // original expression: actPlanStart
                          , 'relation' => 'actPlanStart'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actPlanStart` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Planned end time'
                          // original expression: actPlanEnd
                          , 'relation' => 'actPlanEnd'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actPlanEnd` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Actual start time'
                          // original expression: actStartTime
                          , 'relation' => 'actStartTime'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actStartTime` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actStartTime` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Actual end time'
                          // original expression: actEndTime
                          , 'relation' => 'actEndTime'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Timestamp'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `actEndTime` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Used SvcComponents'
                          // original expression: actUseSC
                          , 'relation' => 'actUseSC'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS src, `SvcComponent` AS tgt
                                                FROM `actUseSC`
                                                WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `Activity` AS src, `Activity` AS tgt
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'A SvcComponent is needed for'
                                        // original expression:
                                        //     actType;atReqsSvc/\\-(actUseSC;scImplements)
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"actType;atReqsSvc\",\"-(actUseSC;scImplements)\"] */
                                                              SELECT DISTINCT isect0.`Activity` AS src, isect0.`Service` AS tgt
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        ECps [\"actType\",\"atReqsSvc\"] */
                                                                     
                                                                     SELECT DISTINCT ECps0.`Activity`, ECps1.`Service`
                                                                     FROM `Activity` AS ECps0,
                                                                          `atReqsSvc` AS ECps1
                                                                     WHERE ECps0.`actType`=ECps1.`ActivityType`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    ECps [\"actUseSC\",\"scImplements\"] */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`Activity`, ECps1.`Service`
                                                                                 FROM `actUseSC` AS ECps0,
                                                                                      `scImplements` AS ECps1
                                                                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                                               ) AS cp
                                                                          WHERE isect0.`Activity`=cp.`Activity` AND isect0.`Service`=cp.`Service`) AND isect0.`Activity` IS NOT NULL AND isect0.`Service` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'SvcComponents to be deployed'
                                        // original expression:
                                        //     actUseSC/\\actExecutingOU;-(compOwner~;scDeployedOn~)
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"actUseSC\",\"actExecutingOU;-(compOwner~;scDeployedOn~)\"] */
                                                              SELECT DISTINCT isect0.`Activity` AS src, isect0.`SvcComponent` AS tgt
                                                              FROM `actUseSC` AS isect0, 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        ECps [\"actExecutingOU\",\"-(compOwner~;scDeployedOn~)\"] */
                                                                     
                                                                     SELECT DISTINCT ECps0.`Activity`, ECps1.`SvcComponent`
                                                                     FROM `Activity` AS ECps0,
                                                                          
                                                                          ( /* case: ECpl e
                                                                               ECpl [ \"compOwner~;scDeployedOn~\" ] */
                                                                            SELECT DISTINCT cfst.`OrgUnit` AS `compOwner`, csnd.`SvcComponent`
                                                                            FROM `OrgUnit` AS cfst,
                                                                                 `SvcComponent` AS csnd
                                                                            WHERE NOT EXISTS
                                                                             (SELECT * FROM 
                                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                                        ECps [\"compOwner~\",\"scDeployedOn~\"] */
                                                                                     
                                                                                     SELECT DISTINCT ECps0.`compOwner`, ECps1.`SvcComponent`
                                                                                     FROM 
                                                                                          ( /* case: EFlp x. */
                                                                                            SELECT DISTINCT `Computer`, `compOwner`
                                                                                            FROM `Computer`
                                                                                            WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                                                                          ) AS ECps0,
                                                                                          
                                                                                          ( /* case: EFlp x. */
                                                                                            SELECT DISTINCT `SvcComponent`, `Computer`
                                                                                            FROM `scDeployedOn`
                                                                                            WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                                          ) AS ECps1
                                                                                     WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                   ) AS cp
                                                                              WHERE cfst.`OrgUnit`=cp.`compOwner` AND csnd.`SvcComponent`=cp.`SvcComponent`)
                                                                          ) AS ECps1
                                                                     WHERE ECps0.`actExecutingOU`=ECps1.`compOwner`
                                                                   ) AS isect1
                                                              WHERE (isect0.`Activity` = isect1.`Activity` AND isect0.`SvcComponent` = isect1.`SvcComponent`) AND isect0.`Activity` IS NOT NULL AND isect0.`SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Capability for all roles:
      'Capability' => 
      array ( 'name' => 'Capability'
            // original expression: I[Capability]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Capability'
            , 'tgtConcept' => 'Capability'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Capability` AS src, `Capability` AS tgt
                                  FROM `Capability`
                                  WHERE `Capability` IS NOT NULL AND `Capability` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Capability'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Capability'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => 'SELECT DISTINCT `Capability` AS src, `Capability` AS tgt
                                                FROM `Capability`
                                                WHERE `Capability` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Qualified OrgUnits'
                          // original expression: ouQualifiedFor~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Capability'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `OrgUnit` AS tgt, `Capability` AS src
                                                FROM `ouQualifiedFor`
                                                WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Required by (Act.Type)'
                          // original expression: atReqsCpb~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Capability'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `ActivityType` AS tgt, `Capability` AS src
                                                FROM `atReqsCpb`
                                                WHERE `ActivityType` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface OrgUnit for all roles:
      'OrgUnit' => 
      array ( 'name' => 'OrgUnit'
            // original expression: I[OrgUnit]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Status', 'Capability', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'OrgUnit'
            , 'tgtConcept' => 'OrgUnit'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                  FROM `Activity`
                                  WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'OrgUnit'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => 'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                                FROM `Activity`
                                                WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => 'SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                                              FROM `Activity`
                                                              WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: ouStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ouStatus` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // original expression: ouMnlStat
                                        , 'relation' => 'ouMnlStat'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ouMnlStat` AS tgt
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capabilities'
                          // original expression: ouQualifiedFor
                          , 'relation' => 'ouQualifiedFor'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Capability'
                          , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `Capability` AS tgt
                                                FROM `ouQualifiedFor`
                                                WHERE `OrgUnit` IS NOT NULL AND `Capability` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Assignable ActivityTypes'
                          // original expression: ouMayExecuteAT
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS src, `ActivityType` AS tgt
                                                FROM `ouMayExecuteAT`
                                                WHERE `OrgUnit` IS NOT NULL AND `ActivityType` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Assigned Activities'
                          // original expression: actExecutingOU~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Activity` AS tgt, `actExecutingOU` AS src
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Owner of (Computer)'
                          // original expression: compOwner~
                          , 'relation' => 'compOwner'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Computer` AS tgt, `compOwner` AS src
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[OrgUnit]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `actExecutingOU` AS src, `actExecutingOU` AS tgt
                                                FROM `Activity`
                                                WHERE `actExecutingOU` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'SvcComponents to be deployed'
                                        // original expression:
                                        //     actExecutingOU~;actUseSC/\\-(compOwner~;scDeployedOn~)
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"actExecutingOU~;actUseSC\",\"-(compOwner~;scDeployedOn~)\"] */
                                                              SELECT DISTINCT isect0.`actExecutingOU` AS src, isect0.`SvcComponent` AS tgt
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        ECps [\"actExecutingOU~\",\"actUseSC\"] */
                                                                     
                                                                     SELECT DISTINCT ECps0.`actExecutingOU`, ECps1.`SvcComponent`
                                                                     FROM 
                                                                          ( /* case: EFlp x. */
                                                                            SELECT DISTINCT `Activity`, `actExecutingOU`
                                                                            FROM `Activity`
                                                                            WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                          ) AS ECps0,
                                                                          `actUseSC` AS ECps1
                                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    ECps [\"compOwner~\",\"scDeployedOn~\"] */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`compOwner`, ECps1.`SvcComponent`
                                                                                 FROM 
                                                                                      ( /* case: EFlp x. */
                                                                                        SELECT DISTINCT `Computer`, `compOwner`
                                                                                        FROM `Computer`
                                                                                        WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL
                                                                                      ) AS ECps0,
                                                                                      
                                                                                      ( /* case: EFlp x. */
                                                                                        SELECT DISTINCT `SvcComponent`, `Computer`
                                                                                        FROM `scDeployedOn`
                                                                                        WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL
                                                                                      ) AS ECps1
                                                                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                               ) AS cp
                                                                          WHERE isect0.`actExecutingOU`=cp.`compOwner` AND isect0.`SvcComponent`=cp.`SvcComponent`) AND isect0.`actExecutingOU` IS NOT NULL AND isect0.`SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Activities to be planned'
                                        // original expression:
                                        //     actExecutingOU~;(I/\\-(actPlanStart;actPlanStart~/\\actPlanEnd;actPlanEnd~))
                                        // <=> { De Morgan }
                                        //     actExecutingOU~;(I/\\(-(actPlanStart;actPlanStart~) \\/ -(actPlanEnd;actPlanEnd~)))
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"actExecutingOU~\",\"I/\\\\(-(actPlanStart;actPlanStart~) \\\\/ -(actPlanEnd;actPlanEnd~))\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`actExecutingOU` AS src, ECps1.`Activity1` AS tgt
                                                              FROM 
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `Activity`, `actExecutingOU`
                                                                     FROM `Activity`
                                                                     WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst@(_:_:_))
                                                                        EIsc [\"I\",\"-(actPlanStart;actPlanStart~) \\\\/ -(actPlanEnd;actPlanEnd~)\"] */
                                                                     SELECT DISTINCT isect0.`Activity`, isect0.`Activity1`
                                                                     FROM 
                                                                          ( /* case: EUni es
                                                                               EUni [\"-(actPlanStart;actPlanStart~)\",\"-(actPlanEnd;actPlanEnd~)\"] */
                                                                            (/* case: ECpl e
                                                                                   ECpl [ \"actPlanStart;actPlanStart~\" ] */
                                                                                SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                                                                FROM `Activity` AS cfst,
                                                                                     `Activity` AS csnd
                                                                                WHERE NOT EXISTS
                                                                                 (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            ECps [\"actPlanStart\",\"actPlanStart~\"] */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                                                                         FROM `Activity` AS ECps0,
                                                                                              
                                                                                              ( /* case: EFlp x. */
                                                                                                SELECT DISTINCT `Activity`, `actPlanStart`
                                                                                                FROM `Activity`
                                                                                                WHERE `Activity` IS NOT NULL AND `actPlanStart` IS NOT NULL
                                                                                              ) AS ECps1
                                                                                         WHERE ECps0.`actPlanStart`=ECps1.`actPlanStart`
                                                                                       ) AS cp
                                                                                  WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                                                                            ) UNION (/* case: ECpl e
                                                                                   ECpl [ \"actPlanEnd;actPlanEnd~\" ] */
                                                                                SELECT DISTINCT cfst.`Activity`, csnd.`Activity` AS `Activity1`
                                                                                FROM `Activity` AS cfst,
                                                                                     `Activity` AS csnd
                                                                                WHERE NOT EXISTS
                                                                                 (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            ECps [\"actPlanEnd\",\"actPlanEnd~\"] */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Activity`, ECps1.`Activity` AS `Activity1`
                                                                                         FROM `Activity` AS ECps0,
                                                                                              
                                                                                              ( /* case: EFlp x. */
                                                                                                SELECT DISTINCT `Activity`, `actPlanEnd`
                                                                                                FROM `Activity`
                                                                                                WHERE `Activity` IS NOT NULL AND `actPlanEnd` IS NOT NULL
                                                                                              ) AS ECps1
                                                                                         WHERE ECps0.`actPlanEnd`=ECps1.`actPlanEnd`
                                                                                       ) AS cp
                                                                                  WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Activity`=cp.`Activity1`)
                                                                            
                                                                            )
                                                                          ) AS isect0, `Activity` AS isect1
                                                                     WHERE isect0.`Activity` = isect0.`Activity1` AND isect0.`Activity` IS NOT NULL AND isect0.`Activity1` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`Activity`=ECps1.`Activity`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Service for role Developer:
      'Service' => 
      array ( 'name' => 'Service'
            // original expression: I[Service]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('ServiceID', 'Status', 'ActivityType', 'SvcComponent')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Service'
            , 'tgtConcept' => 'Service'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                  FROM `Service`
                                  WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Service'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `Service` AS tgt
                                                FROM `Service`
                                                WHERE `Service` IS NOT NULL AND `Service` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // original expression: svcID
                                        , 'relation' => 'svcID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'ServiceID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `svcID` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // original expression: svcStatus
                                        , 'relation' => 'svcStatus'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS src, `svcStatus` AS tgt
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Required by (ActivityType)'
                          // original expression: atReqsSvc~
                          , 'relation' => 'atReqsSvc'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'ActivityType'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `ActivityType` AS tgt, `Service` AS src
                                                FROM `atReqsSvc`
                                                WHERE `ActivityType` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Implemented by (SvcComponent)'
                          // original expression: scImplements~
                          , 'relation' => 'scImplements'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `SvcComponent` AS tgt, `Service` AS src
                                                FROM `scImplements`
                                                WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Deployed on (Computer)'
                          // original expression: scImplements~;scDeployedOn
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"scImplements~\",\"scDeployedOn\"] */
                                                
                                                SELECT DISTINCT ECps0.`Service` AS src, ECps1.`Computer` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `SvcComponent`, `Service`
                                                       FROM `scImplements`
                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                     ) AS ECps0,
                                                     `scDeployedOn` AS ECps1
                                                WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Networks used (Network)'
                          // original expression: scImplements~;scDeployedOn;compRouter;routerNW
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"scImplements~\",\"scDeployedOn\",\"compRouter\",\"routerNW\"] */
                                                
                                                SELECT DISTINCT ECps0.`Service` AS src, ECps3.`routerNW` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `SvcComponent`, `Service`
                                                       FROM `scImplements`
                                                       WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL
                                                     ) AS ECps0,
                                                     `scDeployedOn` AS ECps1,
                                                     `compRouter` AS ECps2,
                                                     `Router` AS ECps3
                                                WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                  AND ECps1.`Computer`=ECps2.`Computer`
                                                  AND ECps2.`Router`=ECps3.`Router`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface SvcComponent for role Developer:
      'SvcComponent' => 
      array ( 'name' => 'SvcComponent'
            // original expression: I[SvcComponent]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('SvcComponentID', 'SvcComponentName', 'Status', 'Status', 'Computer', 'SvcComponent', 'SvcComponent', 'Service')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'SvcComponent'
            , 'tgtConcept' => 'SvcComponent'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                  FROM `SvcComponent`
                                  WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'SvcComponent'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                FROM `SvcComponent`
                                                WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Serial'
                                        // original expression: scID
                                        , 'relation' => 'scID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponentID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scID` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Name'
                                        // original expression: scName
                                        , 'relation' => 'scName'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponentName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scName` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scName` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // original expression: scStatus
                                        , 'relation' => 'scStatus'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scStatus` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // original expression: scMnlStat
                                        , 'relation' => 'scMnlStat'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scMnlStat` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Instantiated (runs) on (Computer)'
                          // original expression: scDeployedOn
                          , 'relation' => 'scDeployedOn'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `Computer` AS tgt
                                                FROM `scDeployedOn`
                                                WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Requires sending messages to (SvcComponent)'
                          // original expression: scReqCommWith
                          , 'relation' => 'scReqCommWith'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `sSvcComponent` AS src, `tSvcComponent` AS tgt
                                                FROM `scReqCommWith`
                                                WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Can actually send messages to (SvcComponent)'
                          // original expression: scHasCommWith
                          , 'relation' => 'scHasCommWith'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => 'SELECT DISTINCT `sSvcComponent` AS src, `tSvcComponent` AS tgt
                                                FROM `scHasCommWith`
                                                WHERE `sSvcComponent` IS NOT NULL AND `tSvcComponent` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Implements (Service)'
                          // original expression: scImplements
                          , 'relation' => 'scImplements'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `Service` AS tgt
                                                FROM `scImplements`
                                                WHERE `SvcComponent` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[SvcComponent]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                FROM `SvcComponent`
                                                WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Must be deployed on computer owned by'
                                        // original expression:
                                        //     actUseSC~;actExecutingOU/\\-(scDeployedOn;compOwner)
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"actUseSC~;actExecutingOU\",\"-(scDeployedOn;compOwner)\"] */
                                                              SELECT DISTINCT isect0.`SvcComponent` AS src, isect0.`actExecutingOU` AS tgt
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        ECps [\"actUseSC~\",\"actExecutingOU\"] */
                                                                     
                                                                     SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`actExecutingOU`
                                                                     FROM 
                                                                          ( /* case: EFlp x. */
                                                                            SELECT DISTINCT `Activity`, `SvcComponent`
                                                                            FROM `actUseSC`
                                                                            WHERE `Activity` IS NOT NULL AND `SvcComponent` IS NOT NULL
                                                                          ) AS ECps0,
                                                                          `Activity` AS ECps1
                                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    ECps [\"scDeployedOn\",\"compOwner\"] */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`compOwner`
                                                                                 FROM `scDeployedOn` AS ECps0,
                                                                                      `Computer` AS ECps1
                                                                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                               ) AS cp
                                                                          WHERE isect0.`SvcComponent`=cp.`SvcComponent` AND isect0.`actExecutingOU`=cp.`compOwner`) AND isect0.`SvcComponent` IS NOT NULL AND isect0.`actExecutingOU` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Computer for role Developer:
      'Computer' => 
      array ( 'name' => 'Computer'
            // original expression: I[Computer]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('ComputerID', 'ComputerName', 'Status', 'OrgUnit', 'SvcComponent', 'Router', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Computer'
            , 'tgtConcept' => 'Computer'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                  FROM `Computer`
                                  WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'ID'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer ID'
                                        // original expression: compID
                                        , 'relation' => 'compID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'ComputerID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compID` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Computer Name'
                                        // original expression: compName
                                        , 'relation' => 'compName'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'ComputerName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compName` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compName` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // original expression: compStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // original expression: compMnlStat
                                        , 'relation' => 'compMnlStat'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compMnlStat` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Owner'
                          // original expression: compOwner
                          , 'relation' => 'compOwner'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compOwner` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Runs an instance of (service component)'
                          // original expression: scDeployedOn~
                          , 'relation' => 'scDeployedOn'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `SvcComponent` AS tgt, `Computer` AS src
                                                FROM `scDeployedOn`
                                                WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected to (Router)'
                          // original expression: compRouter
                          , 'relation' => 'compRouter'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Router` AS tgt
                                                FROM `compRouter`
                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Requires sending messages to (Computer)'
                          // original expression: compReqCommWith
                          , 'relation' => 'compReqCommWith'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `sComputer` AS src, `tComputer` AS tgt
                                                FROM `compReqCommWith`
                                                WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[Computer]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Organize connectivity with (Computer)'
                                        // original expression: compReqCommWith/\\-compHasCommWith
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"compReqCommWith\",\"-compHasCommWith\"] */
                                                              SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                                                              FROM `compReqCommWith` AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                                          WHERE isect0.`sComputer`=cp.`sComputer` AND isect0.`tComputer`=cp.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Router for role Developer:
      'Router' => 
      array ( 'name' => 'Router'
            // original expression: I[Router]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('RouterID', 'RouterName', 'Network', 'Router', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Router'
            , 'tgtConcept' => 'Router'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                  FROM `Router`
                                  WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Router'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Serial'
                                        // original expression: routerID
                                        , 'relation' => 'routerID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'RouterID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerID` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Name'
                                        // original expression: routerName
                                        , 'relation' => 'routerName'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'RouterName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerName` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerName` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // original expression: routerStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Is part of'
                          // original expression: routerNW
                          , 'relation' => 'routerNW'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerNW` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Routes (directly) to (Router)'
                          // original expression: routerRoutesTo
                          , 'relation' => 'routerRoutesTo'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                FROM `routerRoutesTo`
                                                WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Routes (directly) to (Network)'
                          // original expression: rrtDirect;routerNW/\\routerNW;-I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                   EIsc [\"rrtDirect;routerNW\",\"routerNW;-I\"] */
                                                SELECT DISTINCT isect0.`sRouter` AS src, isect0.`routerNW` AS tgt
                                                FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"rrtDirect\",\"routerNW\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`sRouter`, ECps1.`routerNW`
                                                       FROM `rrtDirect` AS ECps0,
                                                            `Router` AS ECps1
                                                       WHERE ECps0.`tRouter`=ECps1.`Router`
                                                     ) AS isect0, 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"routerNW\",\"-I\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`Router`, ECps1.`Network1` AS `Network`
                                                       FROM `Router` AS ECps0,
                                                            
                                                            ( /* case: ECpl e
                                                                 ECpl [ \"I\" ] */
                                                              SELECT DISTINCT cfst.`Network`, csnd.`Network` AS `Network1`
                                                              FROM `Network` AS cfst,
                                                                   `Network` AS csnd
                                                              WHERE NOT EXISTS
                                                               (SELECT * FROM `Network` AS cp
                                                                WHERE cfst.`Network`=cp.`Network` AND csnd.`Network`=cp.`Network`)
                                                            ) AS ECps1
                                                       WHERE ECps0.`routerNW`=ECps1.`Network`
                                                     ) AS isect1
                                                WHERE (isect0.`sRouter` = isect1.`Router` AND isect0.`routerNW` = isect1.`Network`) AND isect0.`sRouter` IS NOT NULL AND isect0.`routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected to (Computer)'
                          // original expression: compRouter~
                          , 'relation' => 'compRouter'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Computer` AS tgt, `Router` AS src
                                                FROM `compRouter`
                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // original expression: I[Router]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"I\" ) _ */
                                                SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Organize connectivity with (Router)'
                                        // original expression: routerNeedsPathTo
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Network for role Developer:
      'Network' => 
      array ( 'name' => 'Network'
            // original expression: I[Network]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('NetworkID', 'Router')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Network'
            , 'tgtConcept' => 'Network'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                  FROM `Network`
                                  WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Network'
                          // original expression: I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `Network` AS tgt
                                                FROM `Network`
                                                WHERE `Network` IS NOT NULL AND `Network` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // original expression: nwID
                                        , 'relation' => 'nwID'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'NetworkID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `nwID` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwID` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // original expression: nwStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS src, `nwStatus` AS tgt
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Routers'
                          // original expression: routerNW~
                          , 'relation' => 'routerNW'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Router` AS tgt, `routerNW` AS src
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected Networks'
                          // original expression: routerNW~;rrtDirect;routerNW/\\-I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                   EIsc [\"routerNW~;rrtDirect;routerNW\",\"-I\"] */
                                                SELECT DISTINCT isect0.`routerNW` AS src, isect0.`routerNW1` AS tgt
                                                FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"routerNW~\",\"rrtDirect\",\"routerNW\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`routerNW`, ECps2.`routerNW` AS `routerNW1`
                                                       FROM 
                                                            ( /* case: EFlp x. */
                                                              SELECT DISTINCT `Router`, `routerNW`
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                            ) AS ECps0,
                                                            `rrtDirect` AS ECps1,
                                                            `Router` AS ECps2
                                                       WHERE ECps0.`Router`=ECps1.`sRouter`
                                                         AND ECps1.`tRouter`=ECps2.`Router`
                                                     ) AS isect0
                                                WHERE isect0.`routerNW` <> isect0.`routerNW1` AND isect0.`routerNW` IS NOT NULL AND isect0.`routerNW1` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected Computers'
                          // original expression: routerNW~;compRouter~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"routerNW~\",\"compRouter~\"] */
                                                
                                                SELECT DISTINCT ECps0.`routerNW` AS src, ECps1.`Computer` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `Router`, `routerNW`
                                                       FROM `Router`
                                                       WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `Computer`, `Router`
                                                       FROM `compRouter`
                                                       WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`Router`=ECps1.`Router`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Obligations [Dev] for role Developer:
      'Obligations [Dev]' => 
      array ( 'name' => 'Obligations [Dev]'
            // original expression: I[ONE]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Connect computer to network router'
                          // original expression: V[ONE*Computer];connectComputerToNetworkRouter
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Computer]\",\"connectComputerToNetworkRouter\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`connectComputerToNetworkRouter` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Computer]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Computer`.`Computer`
                                                       FROM `Computer` AS `Computer`
                                                     ) AS ECps0,
                                                     `Computer` AS ECps1
                                                WHERE ECps0.`Computer`=ECps1.`Computer`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: compStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Create router paths'
                          // original expression:
                          //     V[ONE*Router];(I/\\routerNeedsPathTo;routerNeedsPathTo~)
                          // which is the expression to transform to SQL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Router]\",\"I/\\\\routerNeedsPathTo;routerNeedsPathTo~\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Router1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Router]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Router`.`Router`
                                                       FROM `Router` AS `Router`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I\",\"routerNeedsPathTo;routerNeedsPathTo~\"] */
                                                       SELECT DISTINCT isect0.`sRouter` AS `Router`, isect0.`sRouter1` AS `Router1`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"routerNeedsPathTo\",\"routerNeedsPathTo~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`sRouter`, ECps1.`sRouter` AS `sRouter1`
                                                              FROM `routerNeedsPathTo` AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `sRouter`, `tRouter`
                                                                     FROM `routerNeedsPathTo`
                                                                     WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`tRouter`=ECps1.`tRouter`
                                                            ) AS isect0, `Router` AS isect1
                                                       WHERE isect0.`sRouter` = isect0.`sRouter1` AND isect0.`sRouter` IS NOT NULL AND isect0.`sRouter1` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`Router`=ECps1.`Router`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Router'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Serial'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: routerStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'needs path to'
                                        // original expression: routerNeedsPathTo
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Serial'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: routerStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Routes to be discarded'
                          // original expression:
                          //     V[ONE*Router];(I/\\routesToBeDiscarded;routesToBeDiscarded~)
                          // which is the expression to transform to SQL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Router]\",\"I/\\\\routesToBeDiscarded;routesToBeDiscarded~\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Router1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Router]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Router`.`Router`
                                                       FROM `Router` AS `Router`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I\",\"routesToBeDiscarded;routesToBeDiscarded~\"] */
                                                       SELECT DISTINCT isect0.`sRouter` AS `Router`, isect0.`sRouter1` AS `Router1`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"routesToBeDiscarded\",\"routesToBeDiscarded~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`sRouter`, ECps1.`sRouter` AS `sRouter1`
                                                              FROM `routesToBeDiscarded` AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `sRouter`, `tRouter`
                                                                     FROM `routesToBeDiscarded`
                                                                     WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`tRouter`=ECps1.`tRouter`
                                                            ) AS isect0, `Router` AS isect1
                                                       WHERE isect0.`sRouter` = isect0.`sRouter1` AND isect0.`sRouter` IS NOT NULL AND isect0.`sRouter1` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`Router`=ECps1.`Router`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Discard route from'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Router'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: routerStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'to'
                                        // original expression: routerNeedsPathTo
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `sRouter` AS src, `tRouter` AS tgt
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `sRouter` IS NOT NULL AND `tRouter` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Router'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: routerStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Computers to be disconnected'
                          // original expression:
                          //     V[ONE*Computer];(I/\\computerToBeDisconnected;computerToBeDisconnected~)
                          // which is the expression to transform to SQL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Computer]\",\"I/\\\\computerToBeDisconnected;computerToBeDisconnected~\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Computer1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Computer]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Computer`.`Computer`
                                                       FROM `Computer` AS `Computer`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I\",\"computerToBeDisconnected;computerToBeDisconnected~\"] */
                                                       SELECT DISTINCT isect0.`Computer`, isect0.`Computer1`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"computerToBeDisconnected\",\"computerToBeDisconnected~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Computer`, ECps1.`Computer` AS `Computer1`
                                                              FROM `computerToBeDisconnected` AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `Computer`, `Router`
                                                                     FROM `computerToBeDisconnected`
                                                                     WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`Router`=ECps1.`Router`
                                                            ) AS isect0, `Computer` AS isect1
                                                       WHERE isect0.`Computer` = isect0.`Computer1` AND isect0.`Computer` IS NOT NULL AND isect0.`Computer1` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`Computer`=ECps1.`Computer`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Disconnect'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Computer'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Computer'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: compStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'from'
                                        // original expression:
                                        //     compRouter/\\-(compRouter;(I/\\routerNW;routerNW~))
                                        // which is the expression to transform to SQL
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"compRouter\",\"-(compRouter;(I/\\\\routerNW;routerNW~))\"] */
                                                              SELECT DISTINCT isect0.`Computer` AS src, isect0.`Router` AS tgt
                                                              FROM `compRouter` AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    ECps [\"compRouter\",\"I/\\\\routerNW;routerNW~\"] */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`Computer`, ECps1.`Router1` AS `Router`
                                                                                 FROM `compRouter` AS ECps0,
                                                                                      
                                                                                      ( /* case: (EIsc lst@(_:_:_))
                                                                                           EIsc [\"I\",\"routerNW;routerNW~\"] */
                                                                                        SELECT DISTINCT isect0.`Router`, isect0.`Router1`
                                                                                        FROM 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  ECps [\"routerNW\",\"routerNW~\"] */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`Router`, ECps1.`Router` AS `Router1`
                                                                                               FROM `Router` AS ECps0,
                                                                                                    
                                                                                                    ( /* case: EFlp x. */
                                                                                                      SELECT DISTINCT `Router`, `routerNW`
                                                                                                      FROM `Router`
                                                                                                      WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL
                                                                                                    ) AS ECps1
                                                                                               WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                                                             ) AS isect0, `Router` AS isect1
                                                                                        WHERE isect0.`Router` = isect0.`Router1` AND isect0.`Router` IS NOT NULL AND isect0.`Router1` IS NOT NULL
                                                                                      ) AS ECps1
                                                                                 WHERE ECps0.`Router`=ECps1.`Router`
                                                                               ) AS cp
                                                                          WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Router`=cp.`Router`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Router'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Router'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `Router` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `Router` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: routerStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Router'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Router` AS src, `routerStatus` AS tgt
                                                                            FROM `Router`
                                                                            WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Set up computer-computer communications'
                          // original expression:
                          //     V[ONE*Computer];(I/\\setupComputerComputerCommunications;setupComputerComputerCommunications~)
                          // which is the expression to transform to SQL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Computer]\",\"I/\\\\setupComputerComputerCommunications;setupComputerComputerCommunications~\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Computer1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Computer]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Computer`.`Computer`
                                                       FROM `Computer` AS `Computer`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I\",\"setupComputerComputerCommunications;setupComputerComputerCommunications~\"] */
                                                       SELECT DISTINCT isect0.`sComputer` AS `Computer`, isect0.`sComputer1` AS `Computer1`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"setupComputerComputerCommunications\",\"setupComputerComputerCommunications~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`sComputer`, ECps1.`sComputer` AS `sComputer1`
                                                              FROM `setupComputerComputerCommunications` AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `sComputer`, `tComputer`
                                                                     FROM `setupComputerComputerCommunications`
                                                                     WHERE `sComputer` IS NOT NULL AND `tComputer` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`tComputer`=ECps1.`tComputer`
                                                            ) AS isect0, `Computer` AS isect1
                                                       WHERE isect0.`sComputer` = isect0.`sComputer1` AND isect0.`sComputer` IS NOT NULL AND isect0.`sComputer1` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`Computer`=ECps1.`Computer`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Computer'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Computer'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: compStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'requires communication with'
                                        // original expression: compReqCommWith/\\-compHasCommWith
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* case: (EIsc lst@(_:_:_))
                                                                 EIsc [\"compReqCommWith\",\"-compHasCommWith\"] */
                                                              SELECT DISTINCT isect0.`sComputer` AS src, isect0.`tComputer` AS tgt
                                                              FROM `compReqCommWith` AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                                          WHERE isect0.`sComputer`=cp.`sComputer` AND isect0.`tComputer`=cp.`tComputer`) AND isect0.`sComputer` IS NOT NULL AND isect0.`tComputer` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'Computer'
                                                      // original expression: I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Computer'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `Computer` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `Computer` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'Status'
                                                      // original expression: compStatus
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Computer'
                                                      , 'tgtConcept' => 'Status'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS src, `compStatus` AS tgt
                                                                            FROM `Computer`
                                                                            WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Start running service components'
                          // original expression:
                          //     V[ONE*SvcComponent];(I/\\startRunningServiceComponents;startRunningServiceComponents)
                          // which is the expression to transform to SQL
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*SvcComponent]\",\"I/\\\\startRunningServiceComponents;startRunningServiceComponents\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`SvcComponent1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*SvcComponent]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `SvcComponent`.`SvcComponent`
                                                       FROM `SvcComponent` AS `SvcComponent`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I\",\"startRunningServiceComponents;startRunningServiceComponents\"] */
                                                       SELECT DISTINCT isect0.`SvcComponent`, isect0.`startRunningServiceComponents` AS `SvcComponent1`
                                                       FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"startRunningServiceComponents\",\"startRunningServiceComponents\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`SvcComponent`, ECps1.`startRunningServiceComponents`
                                                              FROM `SvcComponent` AS ECps0,
                                                                   `SvcComponent` AS ECps1
                                                              WHERE ECps0.`startRunningServiceComponents`=ECps1.`SvcComponent`
                                                            ) AS isect0, `SvcComponent` AS isect1
                                                       WHERE isect0.`SvcComponent` = isect0.`startRunningServiceComponents` AND isect0.`SvcComponent` IS NOT NULL AND isect0.`startRunningServiceComponents` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Service component'
                                        // original expression: I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `SvcComponent` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // original expression: scStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS src, `scStatus` AS tgt
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    );
?>
