CONTEXT Atlas IN ENGLISH LATEX
PURPOSE CONTEXT Atlas
{+
Either the abstract syntax tree of the parse tree exists or there are errors causing its absence.
-}

CONCEPT Blob "a string without a relevant size limitation (at least more than one 1GB)" TYPE "Blob"
CONCEPT String "a string expected to be less than 256 characters"
CONCEPT Conid "identifier starting with an uppercase"
CONCEPT Varid "identifier starting with a lowercase"
CONCEPT ADLid "identifier of type pVarid <|> pConid <|> pString"

PATTERN Context
PURPOSE PATTERN Context
{+
\begin{verbatim}
data A_Context
   = ACtx{ ctxnm     :: String        -- ^ The name of this context
         , ctxlang   :: Lang          -- ^ The default language used in this context.
         , ctxmarkup :: PandocFormat  -- ^ The default markup format for free text in this context (currently: LaTeX, ...)
         , ctxthms   :: [String]      -- ^ Names of patterns/processes to be printed in the functional specification. (For partial documents.)
         , ctxpo     :: GenR          -- ^ A tuple representing the partial order of concepts (see makePartialOrder)
         , ctxpats   :: [Pattern]     -- ^ The patterns defined in this context
         , ctxprocs  :: [Process]     -- ^ The processes defined in this context
         , ctxrs     :: [Rule]        -- ^ All user defined rules in this context, but outside patterns and outside processes
         , ctxds     :: [Declaration] -- ^ The declarations defined in this context, outside the scope of patterns
         , ctxcds    :: [ConceptDef]  -- ^ The concept definitions defined in this context, including those from patterns and processes
         , ctxks     :: [KeyDef]      -- ^ The key definitions defined in this context, outside the scope of patterns
         , ctxgs     :: [A_Gen]       -- ^ The key definitions defined in this context, outside the scope of patterns
         , ctxifcs   :: [Interface]   -- ^ The interfaces defined in this context, outside the scope of patterns
         , ctxps     :: [Purpose]     -- ^ The purposes of objects defined in this context, outside the scope of patterns
         , ctxsql    :: [ObjectDef]   -- ^ user defined sqlplugs, taken from the Ampersand script
         , ctxphp    :: [ObjectDef]   -- ^ user defined phpplugs, taken from the Ampersand script
         , ctxenv    :: (Expression,[(Declaration,String)]) -- ^ an expression on the context with unbound relations, to be bound in this environment
         , ctxexperimental :: Bool      -- flag that specifies whether Ampersand was executed with --exp (not techniqually part of the context, but prevents giant refactorings of type checker)
         } 
\end{verbatim}
-}

CONCEPT Context "context"
KEY Context: Context(ctxnm)

ctxnm  ::Context->Conid [INJ]
MEANING "The name of a context"
ctxpats::Context*Pattern
MEANING "The patterns defined in a context"
ctxcs  ::Context*Concept
MEANING "The concept definitions in a context, including those from patterns and processes"
ENDPATTERN

PATTERN Pattern
PURPOSE PATTERN Pattern
{+
\begin{verbatim}
data Pattern
   = A_Pat { ptnm  :: String        -- ^ Name of this pattern
           , ptpos :: Origin        -- ^ the position in the file in which this pattern was declared.
           , ptend :: Origin        -- ^ the end position in the file, elements with a position between pos and end are elements of this pattern.
           , ptrls :: [Rule]        -- ^ The user defined rules in this pattern
           , ptgns :: [A_Gen]       -- ^ The generalizations defined in this pattern
           , ptdcs :: [Declaration] -- ^ The declarations declared in this pattern
           , ptkds :: [KeyDef]      -- ^ The key definitions defined in this pattern
           , ptxps :: [Purpose]     -- ^ The purposes of elements defined in this pattern
           } 
\end{verbatim}
-}

CONCEPT Pattern "pattern"
KEY Pattern: Pattern(ptnm)

ptnm  :: Pattern->Conid [INJ]
MEANING "The name of a pattern"
ptrls :: Pattern*Rule
MEANING "The user-defined rules in a pattern"
ptgns :: Pattern*Gen
MEANING "The generalizations defined in a pattern"
ptdcs :: Pattern*Declaration
MEANING "The declarations declared in a pattern"
ptxps :: Pattern*Blob
MEANING "The purposes of a pattern"
ENDPATTERN

PATTERN Gen
PURPOSE PATTERN Gen
{+
\begin{verbatim}
data A_Gen = Gen { genfp  :: Origin         -- ^ the position of the GEN-rule
                 , gengen :: A_Concept      -- ^ generic concept
                 , genspc :: A_Concept      -- ^ specific concept
                 , genpat :: String         -- ^ pattern of declaration
                 }
\end{verbatim}
-}
CONCEPT Gen "generalization declaration"
KEY Gen: Gen( TXT "SPEC ", genspc;cptnm , TXT " ISA " , gengen;cptnm )
RULE "key gen": gengen;gengen~ /\ genspc;genspc~ |- I

gengen :: Gen->Concept
MEANING "generic concept"
genspc :: Gen->Concept
MEANING "specific concept"
ENDPATTERN

PATTERN Concept
PURPOSE PATTERN Concept
{+
\begin{verbatim}
data A_Concept
   = C   { cptnm :: String         -- ^The name of this Concept
         , cptgE :: GenR           -- ^This is the generalization relation between concepts.
                                   --  It is included in every concept, for the purpose of comparing concepts in the Ord class.
                                   --  As a result, you may write  c<=d  in your Haskell code for any two A_Concepts c and d that are in the same context.
         , cptos :: [String]       -- ^Atoms
         , cpttp :: String         -- ^The type of this Concept
         , cptdf :: [ConceptDef]   -- ^Concept definitions of this concept.
         }  -- ^C nm gE cs represents the set of instances cs by name nm.
   | ONE  -- ^The universal Singleton: 'I'['Anything'] = 'V'['Anything'*'Anything']
\end{verbatim}
-}
--REMARK -> ONE is niet bekend bij studenten (geen INTERFACEs)
CONCEPT Concept "concept"
KEY Concept: Concept(cptnm)

cptnm :: Concept->Conid [INJ]
MEANING "The name of a concept"
cptos :: Concept*AtomID [INJ]
MEANING "The atoms of a concept"
cptdf :: Concept*Blob
MEANING "The definitions of a concept"
cptpurpose:: Concept*Blob
MEANING "The purposes of a concept"
RULE "usedatom": src~;decsgn~;decpopu;pairvalue;left \/ trg~;decsgn~;decpopu;pairvalue;right |- cptos
MESSAGE "Een atoom dat u uit de populatie van het concept probeert te verwijderen heeft nog relaties."

CONCEPT AtomID "An atom as an instance of a concept"
CONCEPT Atom "trim <$> pString" TYPE "Blob"
KEY AtomID: AtomID( atomvalue , TXT " :: ", cptos~;cptnm)

atomvalue::AtomID->Atom
MEANING "The value of an atom"
ENDPATTERN

PATTERN Sign
PURPOSE PATTERN Sign
{+
\begin{verbatim}
   data Sign = Sign A_Concept A_Concept
   type Paire = (String,String)
\end{verbatim}
-}
CONCEPT Sign "sign"
KEY Sign: Sign( src;cptnm , TXT " * " , trg;cptnm )

src::Sign->Concept
MEANING "The source of a sign"
trg::Sign->Concept
MEANING "The target of a sign"

CONCEPT PairID "A pair as an instance of elements with a sign e.g. the population of a relation or the violations of a rule"
KEY PairID: PairID( pairvalue;left;atomvalue , TXT " * " , pairvalue;right;atomvalue )
CONCEPT Pair   "(Atom,Atom)"
KEY Pair: Pair( left;atomvalue , TXT " * " , right;atomvalue )
RULE "key pair": left;left~ /\ right;right~ |- I

pairvalue::PairID->Pair
MEANING "the value of a pair"
left::Pair->AtomID
MEANING "the left atom of a pair"
right::Pair->AtomID
MEANING "the right atom of a pair"
ENDPATTERN

PATTERN Declaration
PURPOSE PATTERN Declaration
{+
\begin{verbatim}
data Declaration = 
  Sgn { decnm   :: String     -- ^ the name of the declaration
      , decsgn  :: Sign       -- ^ the source concept of the declaration
       --multiplicities returns decprps_calc so if you only need the user defined properties do not use multiplicities but decprps
      , decprps :: [Prop]     -- ^ the user defined multiplicity properties (Uni, Tot, Sur, Inj) and algebraic properties (Sym, Asy, Trn, Rfx)
      , decprps_calc :: [Prop]-- ^ the calculated and user defined multiplicity properties (Uni, Tot, Sur, Inj) and algebraic properties (Sym, Asy, Trn, Rfx, Irf). Note that calculated properties are made by adl2fspec, so in the A-structure decprps and decprps_calc yield exactly the same answer.
      , decprL  :: String     -- ^ three strings, which form the pragma. E.g. if pragma consists of the three strings: "Person ", " is married to person ", and " in Vegas."
      , decprM  :: String     -- ^    then a tuple ("Peter","Jane") in the list of links means that Person Peter is married to person Jane in Vegas.
      , decprR  :: String
      , decMean :: AMeaning   -- ^ the meaning of a declaration, for each language supported by Ampersand.
      , decpopu :: Pairs      -- ^ the list of tuples, of which the relation consists.
      , decfpos :: Origin     -- ^ the position in the Ampersand source file where this declaration is declared. Not all decalartions come from the ampersand souce file. 
      , deciss  :: Bool       -- ^ if true, this is a signal relation; otherwise it is an ordinary relation.
      , decusr  :: Bool       -- ^ if true, this relation is declared in the Ampersand script; otherwise it was generated by Ampersand.
      , decpat  :: String     -- ^ the pattern where this declaration has been declared.
      , decplug :: Bool       -- ^ if true, this relation may not be stored in or retrieved from the standard database (it should be gotten from a Plug of some sort instead)
      } | 
 Isn 
      { detyp   :: A_Concept       -- ^ The type
      } |
 Iscompl 
      { detyp   :: A_Concept
      } |
 Vs 
      { decsgn  :: Sign
      }
\end{verbatim}
-}
CONCEPT Declaration "declaration"
KEY Declaration: Declaration( decnm , TXT " :: ", decsgn;src;cptnm ,TXT " * ", decsgn;trg;cptnm )
RULE "key decl": decnm;decnm~ /\ decsgn;src;(decsgn;src)~ /\ decsgn;trg;(decsgn;trg)~ |- I

decnm   ::Declaration->Varid
MEANING "the unqualified name of a declaration"
decsgn ::Declaration->Sign
MEANING "The type of a declaration"
decprps::Declaration*PropertyRule [INJ]
MEANING "The properties declared on a declaration"

CONCEPT PropertyRule "a rule limited to one declaration, declared on that declaration through special syntax for properties"
KEY PropertyRule: PropertyRule(rrnm[PropertyRule*ADLid])
SPEC PropertyRule ISA Rule
CONCEPT Property "..->.. or UNI<|>TOT<|>INJ<|>SUR<|>RFX<|>IRF<|>SYM<|>ASY<|>TRN<|>PROP"
RULE "property enum": I[Property] |- '->' \/ 'UNI' \/ 'TOT' \/ 'INJ' \/ 'SUR' \/ 'RFX' \/ 'IRF' \/ 'SYM' \/ 'ASY' \/ 'TRN' \/ 'PROP'
declaredthrough::PropertyRule*Property [TOT]
MEANING "A property rule is declared through at least one property on a declaration"

decprL  ::Declaration*String[UNI]
decprM  ::Declaration*String[UNI]
decprR  ::Declaration*String[UNI]
decmean ::Declaration * Blob
MEANING "the meaning of a declaration"
decpurpose::Declaration * Blob
MEANING "The purposes of a declaration"
decpopu ::Declaration*PairID

PURPOSE RULE "typed domain"{+ When more generic atoms enter the domain, they should be retyped to the more specific source. -}
RULE "typed domain": decpopu;pairvalue;left;cptos~  |- decsgn;src \/ decsgn;src;(genspc~;gengen \/ genspc~;gengen;genspc~;gengen \/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~ --TODO -> closure
MEANING "The type of the elements in the domain of a declaration is the source of that relation."
MESSAGE "Het linkeratoom van een paar dat u aan de populatie wil toevoegen is niet van het juiste type (zie source). TIP: type de naam van het gewenste type in 'links', zodat u een beperktere keuzelijst krijgt. Als u een atoom van een generieker type wil gebruiken, dan zal u dat atoom specifieker moeten typeren. Een atoom kunt u typeren als een concept door het toe te voegen aan de populatie van dat concept."
PURPOSE RULE "typed codomain"{+ When more generic atoms enter the codomain, they should be retyped to the more specific target. -}
RULE "typed codomain": decpopu;pairvalue;right;cptos~ |- decsgn;trg \/ decsgn;trg;(genspc~;gengen \/ genspc~;gengen;genspc~;gengen \/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~ --TODO -> closure
MEANING "The type of the elements in the codomain of a declaration is the target of that relation or a more specific concept of that target."
MESSAGE "Het rechteratoom van een paar dat u aan de populatie wil toevoegen is niet van het juiste type (zie target). TIP: type de naam van het gewenste type in 'rechts', zodat u een beperktere keuzelijst krijgt. Als u een atoom van een generieker type wil gebruiken, dan zal u dat atoom specifieker moeten typeren. Een atoom kunt u typeren als een concept door het toe te voegen aan de populatie van dat concept."
ENDPATTERN

PATTERN Expression
PURPOSE PATTERN Expression
{+
\begin{verbatim}
data Expression
      = EEqu (Expression,Expression)       -- ^ equivalence             =
      | EImp (Expression,Expression)       -- ^ implication             |-
      | EIsc [Expression]                  -- ^ intersection            /\
      | EUni [Expression]                  -- ^ union                   \/
      | EDif (Expression,Expression)       -- ^ difference              -
      | ELrs (Expression,Expression)       -- ^ left residual           /
      | ERrs (Expression,Expression)       -- ^ right residual          \
      | ECps [Expression]                  -- ^ composition             ;
      | ERad [Expression]                  -- ^ relative addition       !
      | EPrd [Expression]                  -- ^ cartesian product       *  -- The argument is a list of Expressions rather than a tuple (l,r), only because * is associative.
      | EKl0 Expression                    -- ^ Rfx.Trn closure         *  (Kleene star)
      | EKl1 Expression                    -- ^ Transitive closure      +  (Kleene plus)
      | EFlp Expression                    -- ^ conversion (flip, wok)  ~
      | ECpl Expression                    -- ^ Complement
      | EBrk Expression                    -- ^ bracketed expression ( ... )
      | ETyp Expression Sign               -- ^ type cast expression ... [c] (defined tuple instead of list because ETyp only exists for actual casts)
      | ERel Relation                      -- ^ simple relation
data Relation = 
  Rel { relnm   :: String           -- ^ the name of the relation. This is the same name as the name of reldcl.
                                    --    VRAAG: Waarom zou je dit attribuut opnemen? De naam van het morphisme is immers altijd gelijk aan de naam van de Declaration reldcl ....
                                    --    ANTWOORD: Tijdens het parsen, tot het moment dat de declaration aan het morphism is gekoppeld, moet de naam van het morphism bekend zijn. Nadat het morphisme gebonden is aan een declaration moet de naam van het morphisme gelijk zijn aan de naam van zijn reldcl.
      , relpos  :: Origin           -- ^ the position in the Ampersand source file. Let rel_pos be Nowhere if not applicable e.g. relations in generated rules
      , relsgn  :: Sign             -- ^ the allocated signature. May differ from the signature in the reldcl.
      , reldcl  :: Declaration      -- ^ the declaration bound to this relation.
      } |
 I    { rel1typ :: A_Concept        -- ^ the allocated type.
      } |
 V    { reltyp  :: Sign             -- ^ the allocated type.
      } |
 --   An Mp1 is a subset of I. Shouldn't we replace it by an I?
 Mp1  { relval  :: String          -- ^ the value of the singleton morphism
      , rel1typ :: A_Concept               -- ^ the allocated type.
      }
\end{verbatim}
-}

CONCEPT ExpressionID "An expression with a context-dependent meaning e.g. the meaning of a rule, a signal, a relation, ..."
CONCEPT Expression "relation algebraic expression (Ampersand ASCII syntax)"
KEY ExpressionID : ExpressionID(exprvalue)

exprvalue :: ExpressionID->Expression
rels  :: ExpressionID*Relation
MEANING "the user-declared relation terms in an expression"

CONCEPT Relation "user-declared relation term"
KEY Relation: Relation( relnm , TXT "[" , relsgn;src;cptnm , TXT "*" , relsgn;trg;cptnm , TXT "]")

relnm :: Relation -> Varid
relsgn:: Relation -> Sign
reldcl:: Relation -> Declaration
MEANING "A relation refers to a declaration."
RULE "rel name is decl name": relnm = reldcl;decnm
MEANING "the unqualified names of a relation and its declaration are the same."
ENDPATTERN

PATTERN Rule
PURPOSE PATTERN Rule
{+
\begin{verbatim}
data Rule =
     Ru { rrnm      :: String                  -- ^ Name of this rule
        , rrexp     :: Expression              -- ^ The rule expression
        , rrfps     :: Origin                  -- ^ Position in the Ampersand file
        , rrmean    :: AMeaning                -- ^ Ampersand generated explanations (MEANINGs) (for all known languages)
        , rrmsg     :: [A_Markup]              -- ^ User-specified violation messages, possibly more than one, for multiple languages.
        , rrviol    :: Maybe PairView          -- ^ Custom presentation for violations, currently only in a single language
        , rrtyp     :: Sign                    -- ^ Allocated type
        , rrdcl     :: Maybe (Prop,Declaration)  -- ^ The property, if this rule originates from a property on a Declaration
        , r_env     :: String                  -- ^ Name of pattern in which it was defined.
        , r_usr     :: Bool                    -- ^ True if this rule was specified explicitly as a rule in the Ampersand script; False if it follows implicitly from the Ampersand script and generated by a computer
        , r_sgl     :: Bool                    -- ^ True if this is a signal; False if it is an ALWAYS rule
        , srrel     :: Declaration             -- ^ the signal relation
        }
\end{verbatim}
-}
CONCEPT Rule "rule"
KEY Rule: Rule(rrnm)

rrnm  :: Rule -> ADLid [INJ]
MEANING "The name of a rule"
rrexp :: Rule -> ExpressionID
MEANING "the rule expression"
rrmean:: Rule * Blob
rrpurpose:: Rule * Blob
ENDPATTERN
ENDCONTEXT


