CONTEXT RAP


PURPOSE CONTEXT "RAP" IN ENGLISH LATEX{+The Repository for Ampersand Projects (RAP) is an information system to
support rule-based design with Ampersand. RAP is intended for education
of rule-based design in general with Ampersand as a medium. Ampersand is
a methodology to model information systems and business processes as
rule specifications. An Ampersand project is an instance of a process by
the Ampersand methodology including input and output artifacts. There is
a domain specific language for Ampersand to write Ampersand rule
specifications. The Ampersand language is a formal language based on
relation algebra. 

The RAP web application is generated with the
Ampersand compiler from the Ampersand rule specification of RAP. The
same compiler is used to load a rule specification into RAP, export a
rule specification from RAP and generate output from a rule
specification in RAP. Aside from bugs, the compiler may fail because of
syntax- or type errors. Therefore, for each load, RAP holds either the
fspec of a specification or the syntax- or type errors causing its
absence. 

The fspec of a rule specification consists of a context
with a population, conceptual diagrams of the context and rule
violations of the population. The Atlas is the part of RAP to explore
the fspec of a specification. The current Atlas application only allows
editing of the population by a user. RAP keeps track of changes compared
to the intial load. 

The normal user of RAP is a student. A student
can load one rule specification into the Atlas at a single time. RAP
includes interfaces for a student, among which the interfaces of the
Atlas and interfaces for rule specification file management. Metrics for
a single specification are available through the student interfaces e.g.
number of rules in a specification. The admin user has interfaces for
metrics of a single specification, subsequent versions, and traces of
versions.-}
PURPOSE CONTEXT "RAP" IN ENGLISH LATEX{+The basic data structure of a valid Ampersand rule specification is the
abstract syntax tree. All kinds of information can be derived from the
abstract syntax tree e.g. rule violations or conceptual diagram. The
fspec is a data structure that yields information based on the abstract
syntax tree. The fspec is a container of prepared data to feed the
output functions of the Ampersand compiler. The rule specification for
the fspec includes the abstract syntax tree and is complemented with the
following patterns: Image, Conceptual, RuleEnforcement, and Misc.-}
PURPOSE CONTEXT "RAP" IN ENGLISH LATEX{+RAP is an information system in which users can store rules, relations
and populations. For the purpose of investigating the behaviour of a set
of rules, the atlas lets its users edit populations. The PATTERNs in
this script, which are named Context, Pattern, Gen, Concept, Sign,
Declaration, Expression, and Rule, define relations that represent the
corresponding Haskell data structures. These data structures are quoted
in the PURPOSE of each pattern, for the benefit of the Haskell
programmer who works with the source code of the Ampersand compiler.

Either the abstract syntax tree of the parse tree exists or there are
errors causing its absence.-}
PURPOSE CONTEXT "RAP" IN ENGLISH LATEX{+The rule specification for the abstract syntax tree is divided into the
following patterns: Context, Pattern, Gen, Concept, Sign, Declaration,
Expression and Rule. The root of the abstract syntax tree is called a
context. The context is the container in which the designer declares
binary relations and defines rules. Binary relations are declared with a
type consisting of a source and a target concept. Rules are defined as
relation algebraic assertions on the declared relations. The designer is
responsible for the content of the following attributes:

\begin{itemize}
\item
  attribute of context, pattern, rule, relation and concept;
\item
  attribute of rule and relation;
\item
  attribute of concept;
\item
  attribute of concept;
\item
  attribute of relation;
\item
  attribute of relation.
\end{itemize}
The Ampersand compiler that loads an abstract syntax tree into RAP has
inferred the content of the following attributes:

\begin{itemize}
\item
  attribute of rule assertions and every relation term in a rule
  assertion;
\item
  attribute of concept
\end{itemize}
The Ampersand compiler has been developed and agreed upon before this
specification. Thus, any subset of the concepts, relations and rules
that is implemented in the compiler is agreed upon. Therefore the
concepts, relations, and rules in the specification for the abstract
syntax tree are derived from the implementation of the Haskell compiler.
The reason why concepts, relations and rules are implemented in the
compiler is not precisely documented. The implementation of the compiler
is precisely documented i.e. the Haskell source code. Therefore we
motivate the patterns for the abstract syntax tree by relevant source
code, which is a practical motivation. In theory, the specification is
defined first on core motivations and the Ampersand compiler implements
the specification. Either way, the Ampersand compiler implements an
accepted specification.-}
PURPOSE PATTERN "Context" IN ENGLISH LATEX{+\begin{verbatim}
data A_Context
   = ACtx{ ctxnm     :: String        
         , ctxlang   :: Lang          
         , ctxmarkup :: PandocFormat  
         , ctxthms   :: [String]      
         , ctxpo     :: GenR          
         , ctxpats   :: [Pattern]     
         , ctxprocs  :: [Process]     
         , ctxrs     :: [Rule]        
         , ctxds     :: [Declaration] 
         , ctxcds    :: [ConceptDef]  
         , ctxks     :: [KeyDef]      
         , ctxgs     :: [A_Gen]       
         , ctxifcs   :: [Interface]   
         , ctxps     :: [Purpose]     
         , ctxsql    :: [ObjectDef]   
         , ctxphp    :: [ObjectDef]   
         , ctxenv    :: (Expression,[(Declaration,String)]) 
         , ctxexperimental :: Bool      
         } 

instance Identified A_Context where
  name  = ctxnm
\end{verbatim}
-}
PURPOSE PATTERN "Pattern" IN ENGLISH LATEX{+\begin{verbatim}
data Pattern
   = A_Pat { ptnm  :: String        
           , ptpos :: Origin        
           , ptend :: Origin        
           , ptrls :: [Rule]        
           , ptgns :: [A_Gen]       
           , ptdcs :: [Declaration] 
           , ptkds :: [KeyDef]      
           , ptxps :: [Purpose]     
           }
 
instance Identified Pattern where
 name = ptnm
\end{verbatim}
-}
PURPOSE PATTERN "Gen" IN ENGLISH LATEX{+\begin{verbatim}
data A_Gen = Gen { genfp  :: Origin         
                 , gengen :: A_Concept      
                 , genspc :: A_Concept      
                 , genpat :: String         
                 }

instance Eq A_Gen where
  g == g' = gengen g == gengen g' && genspc g == genspc g'
\end{verbatim}
-}
PURPOSE PATTERN "Concept" IN ENGLISH LATEX{+\begin{verbatim}
data A_Concept
   = C   { cptnm :: String         
         , cptgE :: GenR           
                                   
                                   
         , cptos :: [String]       
         , cpttp :: String         
         , cptdf :: [ConceptDef]   
         }  
   | ONE  

instance Identified A_Concept where
  name (C {cptnm = nm}) = nm
  name ONE = "ONE"
\end{verbatim}
The injectivity of cptos is not implemented in the Ampersand library.
Therefore the injectivity of cptos must be implemented in the load
function of the Ampersand compiler. The load function guarantees
injectivity of cptos by constructing identifiers of an atom within the
namespace of a concept. Each atom identifier has an atom value, which is
called the atom.

\begin{verbatim}
atomidid :: String -> A_Concept -> ConceptIdentifier
atomidid x c  = CID $ show$hashString (x ++ "[" ++ getid(cptid c) ++ "]") 
\end{verbatim}
The referential integrity and entity integrity of concept rules are
implemented in the construction function
DatabaseDesign.Ampersand.ADL1.P2A\_Converters.pCpt2aCpt:svn568 of the
Ampersand library. The referential integrity is guaranteed, because a
concept exists while there is a reference to it. The entity integrity of
a concept is implemented through the application of the Haskell
Data.List.nub function.

\begin{verbatim}
pCpt2aCpt :: (Language l, ConceptStructure l, Identified l) => l -> P_Concept -> A_Concept
pCpt2aCpt contxt pc
    = case pc of
        PCpt{} -> c 
        P_Singleton -> ONE
      where 
      c = C {cptnm = p_cptnm pc
            ,cptgE = genE contxt
            ,cptos = nub$[srcPaire p | d<-declarations contxt,decusr d,p<-contents d, source d <= c]
                       ++[trgPaire p | d<-declarations contxt,decusr d,p<-contents d, target d <= c]
                       ++[v | r<-rules contxt,Mp1 v c'<-mors r,c'<=c]
            ,cpttp = head ([cdtyp cd | cd<-conceptDefs contxt,cdcpt cd==p_cptnm pc]++[""])
            ,cptdf = [cd | cd<-conceptDefs contxt,cdcpt cd==p_cptnm pc]
            }
\end{verbatim}
-}
PURPOSE PATTERN "Sign" IN ENGLISH LATEX{+\begin{verbatim}
   data Sign = Sign A_Concept A_Concept
   type Paire = (String,String)
\end{verbatim}
-}
PURPOSE PATTERN "Declaration" IN ENGLISH LATEX{+\begin{verbatim}
data Declaration = 
  Sgn { decnm   :: String     
      , decsgn  :: Sign       
       
      , decprps :: [Prop]     
      , decprps_calc :: [Prop]
      , decprL  :: String     
      , decprM  :: String     
      , decprR  :: String
      , decMean :: AMeaning   
      , decpopu :: Pairs      
      , decfpos :: Origin     
      , deciss  :: Bool       
      , decusr  :: Bool       
      , decpat  :: String     
      , decplug :: Bool       
      } | 
 Isn 
      { detyp   :: A_Concept       
      } |
 Iscompl 
      { detyp   :: A_Concept
      } |
 Vs 
      { decsgn  :: Sign
      }

instance Eq Declaration where
  d@Sgn{}     == d'@Sgn{}     = decnm d==decnm d' && decsgn d==decsgn d'
  d@Isn{}     == d'@Isn{}     = detyp d==detyp d'
  d@Iscompl{} == d'@Iscompl{} = detyp d==detyp d'
  d@Vs{}      == d'@Vs{}      = decsgn d==decsgn d'
  _           == _            = False
\end{verbatim}
The function DatabaseDesign.Ampersand.ADL1.Rule.rulefromProp:svn569 is
applied to each property $prp$ on a declaration $d$ to derive the
property rules of that declaration.

\begin{verbatim}
   rulefromProp :: Prop -> Declaration -> Rule
   rulefromProp prp d@(Sgn{})
      = Ru { rrnm  = show prp++" "++name d++"::"++s++"*"++t
           , rrexp = case prp of
                        Uni-> EImp (ECps [EFlp r,r] ,       i$sign$ECps [EFlp r,r] )
                        Tot-> EImp (i$sign$ECps [r,EFlp r], ECps [r,EFlp r]        )
                        Inj-> EImp (ECps [r,EFlp r],        i$sign$ECps [r,EFlp r] )
                        Sur-> EImp (i$sign$ECps [EFlp r,r], ECps [EFlp r,r]        )
                        Sym-> EEqu (r,                   EFlp r               )
                        Asy-> EImp (EIsc [EFlp r,r],        i$sign$EIsc [EFlp r,r] )
                        Trn-> EImp (ECps [r,r],            r                   )
                        Rfx-> EImp (i$sign r ,           r                   )
                        Irf-> EIsc [i$sign r, EDif (ERel (V (sign r)), r) ]
           , rrfps = origin d
           , rrmean = AMeaning $ explain True prp 
           , rrmsg = explain False prp
           , rrviol = Nothing
           , rrtyp = case prp of
                        Uni-> sign$ECps [EFlp r,r]
                        Tot-> sign$ECps [r,EFlp r]
                        Inj-> sign$ECps [r,EFlp r]
                        Sur-> sign$ECps [EFlp r,r]
                        Sym-> h$sign r
                        Asy-> h$sign r
                        Trn-> h$sign r
                        Rfx-> h$sign r
                        Irf-> h$sign r
           , rrdcl = Just (prp,d)         
           , r_env = decpat d             
           , r_usr = False                
           , r_sgl = False
           , srrel = d{decnm=show prp++name d}
           }
          where
           s = name (source d)
           t = name (target d)
           i sgn   | isEndo sgn = ERel (I (source sgn)) 
                   | otherwise = fatal 239 "Bad multiplicity rule, the source and target of an identity must be identical."
           h sgn   | isEndo sgn = sgn
                   | otherwise = fatal 241 "Bad rule, the source and target of the relation must be identical."
           r:: Expression
           r = ERel (makeRelation d) 
           
           explain isPositive prop = [ A_Markup English ReST (string2Blocks ReST (
                                 case prop of
                                   Sym-> state isPositive English (name d++"["++s++"]") "symmetric"    
                                   Asy-> state isPositive English (name d++"["++s++"]") "antisymmetric"
                                   Trn-> state isPositive English (name d++"["++s++"]") "transitive"
                                   Rfx-> state isPositive English (name d++"["++s++"]") "reflexive"
                                   Irf-> state isPositive English (name d++"["++s++"]") "irreflexive"
                                   Uni-> state isPositive English (name d++"["++s++"*"++t++"]") "univalent"
                                   Sur-> state isPositive English (name d++"["++s++"*"++t++"]") "surjective"
                                   Inj-> state isPositive English (name d++"["++s++"*"++t++"]") "injective"
                                   Tot-> state isPositive English (name d++"["++s++"*"++t++"]") "total"
                                   ))
                          ,   A_Markup Dutch ReST (string2Blocks ReST (
                                 case prop of
                                   Sym-> state isPositive Dutch (name d++"["++s++"]") "symmetrisch."    
                                   Asy-> state isPositive Dutch (name d++"["++s++"]") "antisymmetrisch."
                                   Trn-> state isPositive Dutch (name d++"["++s++"]") "transitief."
                                   Rfx-> state isPositive Dutch (name d++"["++s++"]") "reflexief."
                                   Irf-> state isPositive Dutch (name d++"["++s++"]") "irreflexief."
                                   Uni-> state isPositive Dutch (name d++"["++s++"*"++t++"]") "univalent"
                                   Sur-> state isPositive Dutch (name d++"["++s++"*"++t++"]") "surjectief"
                                   Inj-> state isPositive Dutch (name d++"["++s++"*"++t++"]") "injectief"
                                   Tot-> state isPositive Dutch (name d++"["++s++"*"++t++"]") "totaal"
                                   ))
                         ]
                         
           state True  _       left right = left ++ " is " ++ right
           state False English left right = left ++ " is not " ++ right
           state False Dutch   left right = left ++ " is niet " ++ right
           
   rulefromProp _ _ = fatal 252 "Properties can only be set on user-defined declarations."
\end{verbatim}
The entity integrity of a relation is implemented through the
application of the Haskell Data.List.nub function in
DatabaseDesign.Ampersand.ADL1.P2A\_Converters.pDecl2aDecl:svn568.

An atom in the domain or codomain of a relation is typed correctly
within the Ampersand compiler, because the atom is added to a concept
that is at least as specific as the source respectively target of that
relation.

\begin{verbatim}
pCpt2aCpt :: (Language l, ConceptStructure l, Identified l) => l -> P_Concept -> A_Concept
pCpt2aCpt contxt pc
    = case pc of
        PCpt{} -> c 
        P_Singleton -> ONE
      where 
      c = C {cptnm = p_cptnm pc
            ,cptgE = genE contxt
            ,cptos = nub$[srcPaire p | d<-declarations contxt,decusr d,p<-contents d, source d <= c]
                       ++[trgPaire p | d<-declarations contxt,decusr d,p<-contents d, target d <= c]
                       ++[v | r<-rules contxt,Mp1 v c'<-mors r,c'<=c]
            ,cpttp = head ([cdtyp cd | cd<-conceptDefs contxt,cdcpt cd==p_cptnm pc]++[""])
            ,cptdf = [cd | cd<-conceptDefs contxt,cdcpt cd==p_cptnm pc]
            }
\end{verbatim}
-}
PURPOSE PATTERN "Expression" IN ENGLISH LATEX{+\begin{verbatim}
data Expression
      = EEqu (Expression,Expression)       
      | EImp (Expression,Expression)       
      | EIsc [Expression]                  
      | EUni [Expression]                  
      | EDif (Expression,Expression)       
      | ELrs (Expression,Expression)       
      | ERrs (Expression,Expression)       
      | ECps [Expression]                  
      | ERad [Expression]                  
      | EPrd [Expression]                  
      | EKl0 Expression                    
      | EKl1 Expression                    
      | EFlp Expression                    
      | ECpl Expression                    
      | EBrk Expression                    
      | ETyp Expression Sign               
      | ERel Relation                      
data Relation = 
  Rel { relnm   :: String           
                                    
                                    
      , relpos  :: Origin           
      , relsgn  :: Sign             
      , reldcl  :: Declaration      
      } |
 I    { rel1typ :: A_Concept        
      } |
 V    { reltyp  :: Sign             
      } |
 
 Mp1  { relval  :: String          
      , rel1typ :: A_Concept               
      }
\end{verbatim}
DatabaseDesign.Ampersand.ADL1.P2A\_Converters.pRel2aRel picks a
declaration with the same name as the relation term.

\begin{verbatim}
[d | d<-declarations contxt, name d==name prel]
\end{verbatim}
-}
PURPOSE PATTERN "Rule" IN ENGLISH LATEX{+\begin{verbatim}
data Rule =
     Ru { rrnm      :: String                  
        , rrexp     :: Expression              
        , rrfps     :: Origin                  
        , rrmean    :: AMeaning                
        , rrmsg     :: [A_Markup]              
        , rrviol    :: Maybe PairView          
        , rrtyp     :: Sign                    
        , rrdcl     :: Maybe (Prop,Declaration)  
        , r_env     :: String                  
        , r_usr     :: Bool                    
        , r_sgl     :: Bool                    
        , srrel     :: Declaration             
        }
\end{verbatim}
-}
PURPOSE RELATION firstloadedwith[AdlFile*AdlVersion] IN DUTCH REST{+    A rule specification file loaded into RAP at a certain time has been
    written for the compiler version running at that time. Differences
    of the first compiler version and other compiler versions can be
    determined. Therefore the extend of compliance of the file with
    another version can be determined. The existence of metrics for a
    file depends on the compiler version used to load that file for the
    first time.-}
PURPOSE CONCEPT PairID IN DUTCH REST{+    A pairID identifies a pair of atomic terms as an instance of an
    element with a sign.
        Thus, two identical pairs as instances of different elements
        have different identifiers. The concept emph{Pair} has been
        omitted, while it is not needed yet and it prevents an issue due
        to a missing nice-to-have feature of the prototype generator of
        the Ampersand compiler v2.2.0.2065-568. A user of RAP can edit
        the population of a relation by selecting atomic terms - not
        pairs -, automatically creating new pairID's. Assume that
        concept emph{Pair} is specified and used in relations
        emph{pairvalue::PairID*Pair, left,right::Pair*AtomID}. The
        missing feature is that RAP cannot determine whether to select,
        create or update a pair given a left and right atomic term.
-}



ENDCONTEXT
