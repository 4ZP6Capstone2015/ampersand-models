<?php
// module Generics.php generated by Generate.hs
// Prototype v2.2.0.2084:2090M, build time: 4-May-12 11:20.05 (lib: Ampersand v2.2.0.568:569M, build time: 4-May-12 8:45.33)


$versionInfo = 'Prototype v2.2.0.2084:2090M, build time: 4-May-12 11:20.05 (lib: Ampersand v2.2.0.568:569M, build time: 4-May-12 8:45.33)';

$dbName = 'atlas';

$isDev = false;

$autoRefreshInterval = '0';

$allSpecializations =
  array
    ( 'AdlFile' => array ('NewAdlFile', 'SaveAdlFile')
    , 'PairID' => array ('Violation')
    , 'File' => array ('AdlFile', 'NewAdlFile', 'SavePopFile', 'SaveAdlFile')
    , 'Rule' => array ('PropertyRule')
    );

$relationTableInfo =
  array
    ( 'ctxnm' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Conid', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'Conid')
    , 'countrules' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Int', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'countrules')
    , 'countdecls' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Int', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'countdecls')
    , 'countcpts' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Int', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'countcpts')
    , 'ctxpats' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Pattern', 'table' => 'nssharedctxpats', 'srcCol' => 'Context', 'tgtCol' => 'Pattern')
    , 'ctxcs' => array ('srcConcept' => 'Context', 'tgtConcept' => 'Concept', 'table' => 'nssharedctxcs', 'srcCol' => 'Context', 'tgtCol' => 'Concept')
    , 'ptgns' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Gen', 'table' => 'nssharedptgns', 'srcCol' => 'Pattern', 'tgtCol' => 'Gen')
    , 'ptdcs' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Declaration', 'table' => 'nssharedptdcs', 'srcCol' => 'Pattern', 'tgtCol' => 'Declaration')
    , 'declaredthrough' => array ('srcConcept' => 'PropertyRule', 'tgtConcept' => 'Property', 'table' => 'nsshareddeclaredthrough', 'srcCol' => 'PropertyRule', 'tgtCol' => 'Property')
    , 'decprps' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PropertyRule', 'table' => 'nssharedADLid', 'srcCol' => 'decprps', 'tgtCol' => 'PropertyRule')
    , 'ptrls' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Rule', 'table' => 'nssharedptrls', 'srcCol' => 'Pattern', 'tgtCol' => 'Rule')
    , 'savecontext' => array ('srcConcept' => 'Context', 'tgtConcept' => 'SaveAdlFile', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'savecontext')
    , 'includes' => array ('srcConcept' => 'Context', 'tgtConcept' => 'File', 'table' => 'nssharedincludes', 'srcCol' => 'Context', 'tgtCol' => 'File')
    , 'sourcefile' => array ('srcConcept' => 'Context', 'tgtConcept' => 'AdlFile', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'sourcefile')
    , 'applyto' => array ('srcConcept' => 'G', 'tgtConcept' => 'AdlFile', 'table' => 'nssharedG', 'srcCol' => 'G', 'tgtCol' => 'applyto')
    , 'newfile' => array ('srcConcept' => 'User', 'tgtConcept' => 'NewAdlFile', 'table' => 'nssharedUser', 'srcCol' => 'User', 'tgtCol' => 'newfile')
    , 'uploaded' => array ('srcConcept' => 'User', 'tgtConcept' => 'File', 'table' => 'nsshareduploaded', 'srcCol' => 'User', 'tgtCol' => 'File')
    , 'filetime' => array ('srcConcept' => 'File', 'tgtConcept' => 'CalendarTime', 'table' => 'nssharedFile', 'srcCol' => 'File', 'tgtCol' => 'filetime')
    , 'savepopulation' => array ('srcConcept' => 'Context', 'tgtConcept' => 'SavePopFile', 'table' => 'nssharedConid', 'srcCol' => 'ctxnm', 'tgtCol' => 'savepopulation')
    , 'filename' => array ('srcConcept' => 'File', 'tgtConcept' => 'FileName', 'table' => 'nssharedFile', 'srcCol' => 'File', 'tgtCol' => 'filename')
    , 'userrole' => array ('srcConcept' => 'User', 'tgtConcept' => 'Role', 'table' => 'nssharedUser', 'srcCol' => 'User', 'tgtCol' => 'userrole')
    , 'rapdescr' => array ('srcConcept' => 'MetaInformation', 'tgtConcept' => 'Blob', 'table' => 'nssharedrapdescr', 'srcCol' => 'MetaInformation', 'tgtCol' => 'Blob')
    , 'engineimage' => array ('srcConcept' => 'MetaInformation', 'tgtConcept' => 'Image', 'table' => 'nssharedengineimage', 'srcCol' => 'MetaInformation', 'tgtCol' => 'Image')
    , 'engineexpl' => array ('srcConcept' => 'MetaInformation', 'tgtConcept' => 'Blob', 'table' => 'nssharedengineexpl', 'srcCol' => 'MetaInformation', 'tgtCol' => 'Blob')
    , 'genimage' => array ('srcConcept' => 'MetaInformation', 'tgtConcept' => 'Image', 'table' => 'nssharedgenimage', 'srcCol' => 'MetaInformation', 'tgtCol' => 'Image')
    , 'genexpl' => array ('srcConcept' => 'MetaInformation', 'tgtConcept' => 'Blob', 'table' => 'nssharedgenexpl', 'srcCol' => 'MetaInformation', 'tgtCol' => 'Blob')
    , 'ptxps' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Blob', 'table' => 'nssharedptxps', 'srcCol' => 'Pattern', 'tgtCol' => 'Blob')
    , 'ptnm' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Conid', 'table' => 'nssharedConid', 'srcCol' => 'ptnm', 'tgtCol' => 'Conid')
    , 'ptpic' => array ('srcConcept' => 'Pattern', 'tgtConcept' => 'Image', 'table' => 'nssharedConid', 'srcCol' => 'ptnm', 'tgtCol' => 'ptpic')
    , 'genspc' => array ('srcConcept' => 'Gen', 'tgtConcept' => 'Concept', 'table' => 'nssharedGen', 'srcCol' => 'Gen', 'tgtCol' => 'genspc')
    , 'gengen' => array ('srcConcept' => 'Gen', 'tgtConcept' => 'Concept', 'table' => 'nssharedGen', 'srcCol' => 'Gen', 'tgtCol' => 'gengen')
    , 'cptpurpose' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Blob', 'table' => 'nssharedcptpurpose', 'srcCol' => 'Concept', 'tgtCol' => 'Blob')
    , 'cptdf' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Blob', 'table' => 'nssharedcptdf', 'srcCol' => 'Concept', 'tgtCol' => 'Blob')
    , 'cptnm' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Conid', 'table' => 'nssharedConid', 'srcCol' => 'cptnm', 'tgtCol' => 'Conid')
    , 'cptos' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'AtomID', 'table' => 'nssharedcptos', 'srcCol' => 'Concept', 'tgtCol' => 'AtomID')
    , 'atomvalue' => array ('srcConcept' => 'AtomID', 'tgtConcept' => 'Atom', 'table' => 'nssharedAtomID', 'srcCol' => 'AtomID', 'tgtCol' => 'atomvalue')
    , 'trg' => array ('srcConcept' => 'Sign', 'tgtConcept' => 'Concept', 'table' => 'nssharedSign', 'srcCol' => 'Sign', 'tgtCol' => 'trg')
    , 'src' => array ('srcConcept' => 'Sign', 'tgtConcept' => 'Concept', 'table' => 'nssharedSign', 'srcCol' => 'Sign', 'tgtCol' => 'src')
    , 'decsgn' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Sign', 'table' => 'nssharedDeclaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decsgn')
    , 'rels' => array ('srcConcept' => 'ExpressionID', 'tgtConcept' => 'Relation', 'table' => 'nssharedrels', 'srcCol' => 'ExpressionID', 'tgtCol' => 'Relation')
    , 'rrexp' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'ExpressionID', 'table' => 'nssharedADLid', 'srcCol' => 'rrnm', 'tgtCol' => 'rrexp')
    , 'relsgn' => array ('srcConcept' => 'Relation', 'tgtConcept' => 'Sign', 'table' => 'nssharedRelation', 'srcCol' => 'Relation', 'tgtCol' => 'relsgn')
    , 'cptpic' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Image', 'table' => 'nssharedConid', 'srcCol' => 'cptnm', 'tgtCol' => 'cptpic')
    , 'decpurpose' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Blob', 'table' => 'nsshareddecpurpose', 'srcCol' => 'Declaration', 'tgtCol' => 'Blob')
    , 'decmean' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Blob', 'table' => 'nsshareddecmean', 'srcCol' => 'Declaration', 'tgtCol' => 'Blob')
    , 'decexample' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PragmaSentence', 'table' => 'nsshareddecexample', 'srcCol' => 'Declaration', 'tgtCol' => 'PragmaSentence')
    , 'decnm' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'Varid', 'table' => 'nssharedDeclaration', 'srcCol' => 'Declaration', 'tgtCol' => 'decnm')
    , 'decpopu' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PairID', 'table' => 'nsshareddecpopu', 'srcCol' => 'Declaration', 'tgtCol' => 'PairID')
    , 'left' => array ('srcConcept' => 'PairID', 'tgtConcept' => 'AtomID', 'table' => 'nssharedPairID', 'srcCol' => 'PairID', 'tgtCol' => 'left')
    , 'right' => array ('srcConcept' => 'PairID', 'tgtConcept' => 'AtomID', 'table' => 'nssharedPairID', 'srcCol' => 'PairID', 'tgtCol' => 'right')
    , 'reldcl' => array ('srcConcept' => 'Relation', 'tgtConcept' => 'Declaration', 'table' => 'nssharedRelation', 'srcCol' => 'Relation', 'tgtCol' => 'reldcl')
    , 'rrpurpose' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Blob', 'table' => 'nssharedrrpurpose', 'srcCol' => 'Rule', 'tgtCol' => 'Blob')
    , 'rrmean' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Blob', 'table' => 'nssharedrrmean', 'srcCol' => 'Rule', 'tgtCol' => 'Blob')
    , 'rrnm' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'ADLid', 'table' => 'nssharedADLid', 'srcCol' => 'rrnm', 'tgtCol' => 'ADLid')
    , 'rrpic' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Image', 'table' => 'nssharedADLid', 'srcCol' => 'rrnm', 'tgtCol' => 'rrpic')
    , 'typeerror' => array ('srcConcept' => 'File', 'tgtConcept' => 'TypeError', 'table' => 'nssharedtypeerror2', 'srcCol' => 'File', 'tgtCol' => 'TypeError')
    , 'parseerror' => array ('srcConcept' => 'File', 'tgtConcept' => 'ParseError', 'table' => 'nssharedFile', 'srcCol' => 'File', 'tgtCol' => 'parseerror')
    , 'filepath' => array ('srcConcept' => 'File', 'tgtConcept' => 'FilePath', 'table' => 'nssharedFile', 'srcCol' => 'File', 'tgtCol' => 'filepath')
    , 'firstloadedwith' => array ('srcConcept' => 'AdlFile', 'tgtConcept' => 'AdlVersion', 'table' => 'nssharedFile', 'srcCol' => 'AdlFile', 'tgtCol' => 'firstloadedwith')
    , 'pe_action' => array ('srcConcept' => 'ParseError', 'tgtConcept' => 'String', 'table' => 'nssharedParseError', 'srcCol' => 'ParseError', 'tgtCol' => 'pe_action')
    , 'pe_position' => array ('srcConcept' => 'ParseError', 'tgtConcept' => 'String', 'table' => 'nssharedParseError', 'srcCol' => 'ParseError', 'tgtCol' => 'pe_position')
    , 'pe_expecting' => array ('srcConcept' => 'ParseError', 'tgtConcept' => 'String', 'table' => 'nssharedParseError', 'srcCol' => 'ParseError', 'tgtCol' => 'pe_expecting')
    , 'te_message' => array ('srcConcept' => 'TypeError', 'tgtConcept' => 'ErrorMessage', 'table' => 'nssharedTypeError1', 'srcCol' => 'TypeError', 'tgtCol' => 'te_message')
    , 'order' => array ('srcConcept' => 'Concept', 'tgtConcept' => 'Order', 'table' => 'nssharedConid', 'srcCol' => 'cptnm', 'tgtCol' => 'order')
    , 'relnm' => array ('srcConcept' => 'Relation', 'tgtConcept' => 'Varid', 'table' => 'nssharedRelation', 'srcCol' => 'Relation', 'tgtCol' => 'relnm')
    , 'rrviols' => array ('srcConcept' => 'Rule', 'tgtConcept' => 'Violation', 'table' => 'nssharedrrviols', 'srcCol' => 'Rule', 'tgtCol' => 'Violation')
    , 'iniright' => array ('srcConcept' => 'PairID', 'tgtConcept' => 'Atom', 'table' => 'nssharediniright', 'srcCol' => 'PairID', 'tgtCol' => 'Atom')
    , 'inipopu' => array ('srcConcept' => 'Declaration', 'tgtConcept' => 'PairID', 'table' => 'nssharedinipopu', 'srcCol' => 'Declaration', 'tgtCol' => 'PairID')
    , 'inileft' => array ('srcConcept' => 'PairID', 'tgtConcept' => 'Atom', 'table' => 'nssharedinileft', 'srcCol' => 'PairID', 'tgtCol' => 'Atom')
    );

$conceptTableInfo =
  array
    ( 'AdlFile' => array 
          ( array ( 'table' => 'nssharedFile'
                  , 'cols' => array ('AdlFile', 'File')
                  )
          )
    , 'AdlVersion' => array 
          ( array ( 'table' => 'nssharedAdlVersion'
                  , 'cols' => array ('AdlVersion')
                  )
          )
    , 'Concept' => array 
          ( array ( 'table' => 'nssharedConid'
                  , 'cols' => array ('cptnm')
                  )
          )
    , 'AtomID' => array 
          ( array ( 'table' => 'nssharedAtomID'
                  , 'cols' => array ('AtomID')
                  )
          )
    , 'Declaration' => array 
          ( array ( 'table' => 'nssharedDeclaration'
                  , 'cols' => array ('Declaration')
                  )
          )
    , 'PairID' => array 
          ( array ( 'table' => 'nssharedPairID'
                  , 'cols' => array ('PairID')
                  )
          )
    , 'Atom' => array 
          ( array ( 'table' => 'nssharedAtom'
                  , 'cols' => array ('Atom')
                  )
          )
    , 'File' => array 
          ( array ( 'table' => 'nssharedFile'
                  , 'cols' => array ('File')
                  )
          )
    , 'ParseError' => array 
          ( array ( 'table' => 'nssharedParseError'
                  , 'cols' => array ('ParseError')
                  )
          )
    , 'String' => array 
          ( array ( 'table' => 'nssharedString'
                  , 'cols' => array ('String')
                  )
          )
    , 'TypeError' => array 
          ( array ( 'table' => 'nssharedTypeError1'
                  , 'cols' => array ('TypeError')
                  )
          )
    , 'ErrorMessage' => array 
          ( array ( 'table' => 'nssharedErrorMessage'
                  , 'cols' => array ('ErrorMessage')
                  )
          )
    , 'FileName' => array 
          ( array ( 'table' => 'nssharedFileName'
                  , 'cols' => array ('FileName')
                  )
          )
    , 'FilePath' => array 
          ( array ( 'table' => 'nssharedFilePath'
                  , 'cols' => array ('FilePath')
                  )
          )
    , 'CalendarTime' => array 
          ( array ( 'table' => 'nssharedCalendarTime'
                  , 'cols' => array ('CalendarTime')
                  )
          )
    , 'User' => array 
          ( array ( 'table' => 'nssharedUser'
                  , 'cols' => array ('User')
                  )
          )
    , 'Role' => array 
          ( array ( 'table' => 'nssharedRole'
                  , 'cols' => array ('Role')
                  )
          )
    , 'Context' => array 
          ( array ( 'table' => 'nssharedConid'
                  , 'cols' => array ('ctxnm')
                  )
          )
    , 'G' => array 
          ( array ( 'table' => 'nssharedG'
                  , 'cols' => array ('G')
                  )
          )
    , 'Int' => array 
          ( array ( 'table' => 'nssharedInt'
                  , 'cols' => array ('Int')
                  )
          )
    , 'NewAdlFile' => array 
          ( array ( 'table' => 'nssharedFile'
                  , 'cols' => array ('NewAdlFile', 'AdlFile', 'File')
                  )
          )
    , 'SavePopFile' => array 
          ( array ( 'table' => 'nssharedFile'
                  , 'cols' => array ('SavePopFile', 'File')
                  )
          )
    , 'SaveAdlFile' => array 
          ( array ( 'table' => 'nssharedFile'
                  , 'cols' => array ('SaveAdlFile', 'AdlFile', 'File')
                  )
          )
    , 'MetaInformation' => array 
          ( array ( 'table' => 'nssharedMetaInformation'
                  , 'cols' => array ('MetaInformation')
                  )
          )
    , 'Blob' => array 
          ( array ( 'table' => 'nssharedBlob'
                  , 'cols' => array ('Blob')
                  )
          )
    , 'Image' => array 
          ( array ( 'table' => 'nssharedImage'
                  , 'cols' => array ('Image')
                  )
          )
    , 'URL' => array 
          ( array ( 'table' => 'nssharedURL'
                  , 'cols' => array ('URL')
                  )
          )
    , 'Pattern' => array 
          ( array ( 'table' => 'nssharedConid'
                  , 'cols' => array ('ptnm')
                  )
          )
    , 'Rule' => array 
          ( array ( 'table' => 'nssharedADLid'
                  , 'cols' => array ('rrnm')
                  )
          )
    , 'Violation' => array 
          ( array ( 'table' => 'nssharedPairID'
                  , 'cols' => array ('Violation', 'PairID')
                  )
          )
    , 'PragmaSentence' => array 
          ( array ( 'table' => 'nssharedPragmaSentence'
                  , 'cols' => array ('PragmaSentence')
                  )
          )
    , 'Conid' => array 
          ( array ( 'table' => 'nssharedConid'
                  , 'cols' => array ('Conid')
                  )
          )
    , 'Gen' => array 
          ( array ( 'table' => 'nssharedGen'
                  , 'cols' => array ('Gen')
                  )
          )
    , 'Order' => array 
          ( array ( 'table' => 'nssharedString'
                  , 'cols' => array ('ordername')
                  )
          )
    , 'Sign' => array 
          ( array ( 'table' => 'nssharedSign'
                  , 'cols' => array ('Sign')
                  )
          )
    , 'Varid' => array 
          ( array ( 'table' => 'nssharedVarid'
                  , 'cols' => array ('Varid')
                  )
          )
    , 'PropertyRule' => array 
          ( array ( 'table' => 'nssharedADLid'
                  , 'cols' => array ('PropertyRule', 'rrnm')
                  )
          )
    , 'Property' => array 
          ( array ( 'table' => 'nssharedProperty'
                  , 'cols' => array ('Property')
                  )
          )
    , 'ExpressionID' => array 
          ( array ( 'table' => 'nssharedExpressionID'
                  , 'cols' => array ('ExpressionID')
                  )
          )
    , 'Expression' => array 
          ( array ( 'table' => 'nssharedExpression'
                  , 'cols' => array ('Expression')
                  )
          )
    , 'Relation' => array 
          ( array ( 'table' => 'nssharedRelation'
                  , 'cols' => array ('Relation')
                  )
          )
    , 'ADLid' => array 
          ( array ( 'table' => 'nssharedADLid'
                  , 'cols' => array ('ADLid')
                  )
          )
    );

$tableColumnInfo =
  array
    ( 'nssharedConid' =>
        array
          ( 'Conid' => array ( 'concept' => 'Conid', 'unique' => true, 'null' => false)
          , 'ctxnm' => array ( 'concept' => 'Context', 'unique' => true, 'null' => true)
          , 'ptnm' => array ( 'concept' => 'Pattern', 'unique' => true, 'null' => true)
          , 'cptnm' => array ( 'concept' => 'Concept', 'unique' => true, 'null' => true)
          , 'sourcefile' => array ( 'concept' => 'AdlFile', 'unique' => false, 'null' => true)
          , 'savepopulation' => array ( 'concept' => 'SavePopFile', 'unique' => false, 'null' => true)
          , 'savecontext' => array ( 'concept' => 'SaveAdlFile', 'unique' => false, 'null' => true)
          , 'countrules' => array ( 'concept' => 'Int', 'unique' => false, 'null' => true)
          , 'countdecls' => array ( 'concept' => 'Int', 'unique' => false, 'null' => true)
          , 'countcpts' => array ( 'concept' => 'Int', 'unique' => false, 'null' => true)
          , 'ptpic' => array ( 'concept' => 'Image', 'unique' => false, 'null' => true)
          , 'cptpic' => array ( 'concept' => 'Image', 'unique' => false, 'null' => true)
          , 'order' => array ( 'concept' => 'Order', 'unique' => false, 'null' => true)
          )
    , 'nssharedFile' =>
        array
          ( 'File' => array ( 'concept' => 'File', 'unique' => true, 'null' => false)
          , 'AdlFile' => array ( 'concept' => 'AdlFile', 'unique' => true, 'null' => true)
          , 'SavePopFile' => array ( 'concept' => 'SavePopFile', 'unique' => true, 'null' => true)
          , 'NewAdlFile' => array ( 'concept' => 'NewAdlFile', 'unique' => true, 'null' => true)
          , 'SaveAdlFile' => array ( 'concept' => 'SaveAdlFile', 'unique' => true, 'null' => true)
          , 'firstloadedwith' => array ( 'concept' => 'AdlVersion', 'unique' => false, 'null' => true)
          , 'parseerror' => array ( 'concept' => 'ParseError', 'unique' => false, 'null' => true)
          , 'filename' => array ( 'concept' => 'FileName', 'unique' => false, 'null' => false)
          , 'filepath' => array ( 'concept' => 'FilePath', 'unique' => false, 'null' => true)
          , 'filetime' => array ( 'concept' => 'CalendarTime', 'unique' => false, 'null' => true)
          )
    , 'nssharedADLid' =>
        array
          ( 'ADLid' => array ( 'concept' => 'ADLid', 'unique' => true, 'null' => false)
          , 'rrnm' => array ( 'concept' => 'Rule', 'unique' => true, 'null' => true)
          , 'PropertyRule' => array ( 'concept' => 'PropertyRule', 'unique' => true, 'null' => true)
          , 'rrpic' => array ( 'concept' => 'Image', 'unique' => false, 'null' => true)
          , 'rrexp' => array ( 'concept' => 'ExpressionID', 'unique' => false, 'null' => true)
          , 'decprps' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => true)
          )
    , 'nssharedTypeError1' =>
        array
          ( 'TypeError' => array ( 'concept' => 'TypeError', 'unique' => true, 'null' => false)
          , 'te_message' => array ( 'concept' => 'ErrorMessage', 'unique' => false, 'null' => true)
          , 'te_parent' => array ( 'concept' => 'TypeError', 'unique' => false, 'null' => true)
          , 'te_position' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          , 'te_origtype' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          , 'te_origname' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          )
    , 'nssharedtypeerror2' =>
        array
          ( 'File' => array ( 'concept' => 'File', 'unique' => false, 'null' => false)
          , 'TypeError' => array ( 'concept' => 'TypeError', 'unique' => false, 'null' => false)
          )
    , 'nssharedDeclaration' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => true, 'null' => false)
          , 'decnm' => array ( 'concept' => 'Varid', 'unique' => false, 'null' => false)
          , 'decsgn' => array ( 'concept' => 'Sign', 'unique' => false, 'null' => false)
          , 'decprL' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          , 'decprM' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          , 'decprR' => array ( 'concept' => 'String', 'unique' => false, 'null' => true)
          )
    , 'nssharedRelation' =>
        array
          ( 'Relation' => array ( 'concept' => 'Relation', 'unique' => true, 'null' => false)
          , 'relnm' => array ( 'concept' => 'Varid', 'unique' => false, 'null' => false)
          , 'relsgn' => array ( 'concept' => 'Sign', 'unique' => false, 'null' => false)
          , 'reldcl' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          )
    , 'nssharedG' =>
        array
          ( 'G' => array ( 'concept' => 'G', 'unique' => true, 'null' => false)
          , 'applyto' => array ( 'concept' => 'AdlFile', 'unique' => false, 'null' => false)
          , 'functionname' => array ( 'concept' => 'String', 'unique' => false, 'null' => false)
          , 'operation' => array ( 'concept' => 'Int', 'unique' => false, 'null' => false)
          )
    , 'nssharedParseError' =>
        array
          ( 'ParseError' => array ( 'concept' => 'ParseError', 'unique' => true, 'null' => false)
          , 'pe_action' => array ( 'concept' => 'String', 'unique' => false, 'null' => false)
          , 'pe_position' => array ( 'concept' => 'String', 'unique' => false, 'null' => false)
          , 'pe_expecting' => array ( 'concept' => 'String', 'unique' => false, 'null' => false)
          )
    , 'nssharedPairID' =>
        array
          ( 'PairID' => array ( 'concept' => 'PairID', 'unique' => true, 'null' => false)
          , 'Violation' => array ( 'concept' => 'Violation', 'unique' => true, 'null' => true)
          , 'left' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          , 'right' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          )
    , 'nssharedSign' =>
        array
          ( 'Sign' => array ( 'concept' => 'Sign', 'unique' => true, 'null' => false)
          , 'src' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'trg' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          )
    , 'nssharedGen' =>
        array
          ( 'Gen' => array ( 'concept' => 'Gen', 'unique' => true, 'null' => false)
          , 'gengen' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'genspc' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          )
    , 'nssharedUser' =>
        array
          ( 'User' => array ( 'concept' => 'User', 'unique' => true, 'null' => false)
          , 'userrole' => array ( 'concept' => 'Role', 'unique' => false, 'null' => true)
          , 'newfile' => array ( 'concept' => 'NewAdlFile', 'unique' => false, 'null' => false)
          )
    , 'nssharedExpressionID' =>
        array
          ( 'ExpressionID' => array ( 'concept' => 'ExpressionID', 'unique' => true, 'null' => false)
          , 'exprvalue' => array ( 'concept' => 'Expression', 'unique' => false, 'null' => false)
          )
    , 'nssharedString' =>
        array
          ( 'String' => array ( 'concept' => 'String', 'unique' => true, 'null' => false)
          , 'ordername' => array ( 'concept' => 'Order', 'unique' => true, 'null' => true)
          )
    , 'nssharedAtomID' =>
        array
          ( 'AtomID' => array ( 'concept' => 'AtomID', 'unique' => true, 'null' => false)
          , 'atomvalue' => array ( 'concept' => 'Atom', 'unique' => false, 'null' => false)
          )
    , 'nssharedExpression' =>
        array
          ( 'Expression' => array ( 'concept' => 'Expression', 'unique' => true, 'null' => false)
          )
    , 'nssharedProperty' =>
        array
          ( 'Property' => array ( 'concept' => 'Property', 'unique' => true, 'null' => false)
          )
    , 'nssharedVarid' =>
        array
          ( 'Varid' => array ( 'concept' => 'Varid', 'unique' => true, 'null' => false)
          )
    , 'nssharedPragmaSentence' =>
        array
          ( 'PragmaSentence' => array ( 'concept' => 'PragmaSentence', 'unique' => true, 'null' => false)
          )
    , 'nssharedURL' =>
        array
          ( 'URL' => array ( 'concept' => 'URL', 'unique' => true, 'null' => false)
          )
    , 'nssharedImage' =>
        array
          ( 'Image' => array ( 'concept' => 'Image', 'unique' => true, 'null' => false)
          )
    , 'nssharedBlob' =>
        array
          ( 'Blob' => array ( 'concept' => 'Blob', 'unique' => true, 'null' => false)
          )
    , 'nssharedMetaInformation' =>
        array
          ( 'MetaInformation' => array ( 'concept' => 'MetaInformation', 'unique' => true, 'null' => false)
          )
    , 'nssharedInt' =>
        array
          ( 'Int' => array ( 'concept' => 'Int', 'unique' => true, 'null' => false)
          )
    , 'nssharedRole' =>
        array
          ( 'Role' => array ( 'concept' => 'Role', 'unique' => true, 'null' => false)
          )
    , 'nssharedCalendarTime' =>
        array
          ( 'CalendarTime' => array ( 'concept' => 'CalendarTime', 'unique' => true, 'null' => false)
          )
    , 'nssharedFilePath' =>
        array
          ( 'FilePath' => array ( 'concept' => 'FilePath', 'unique' => true, 'null' => false)
          )
    , 'nssharedFileName' =>
        array
          ( 'FileName' => array ( 'concept' => 'FileName', 'unique' => true, 'null' => false)
          )
    , 'nssharedErrorMessage' =>
        array
          ( 'ErrorMessage' => array ( 'concept' => 'ErrorMessage', 'unique' => true, 'null' => false)
          )
    , 'nssharedAtom' =>
        array
          ( 'Atom' => array ( 'concept' => 'Atom', 'unique' => true, 'null' => false)
          )
    , 'nssharedAdlVersion' =>
        array
          ( 'AdlVersion' => array ( 'concept' => 'AdlVersion', 'unique' => true, 'null' => false)
          )
    , 'nssharedinios' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'AtomID' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          )
    , 'nssharedinipopu' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'PairID' => array ( 'concept' => 'PairID', 'unique' => false, 'null' => false)
          )
    , 'nssharedinileft' =>
        array
          ( 'PairID' => array ( 'concept' => 'PairID', 'unique' => false, 'null' => false)
          , 'Atom' => array ( 'concept' => 'Atom', 'unique' => false, 'null' => false)
          )
    , 'nssharediniright' =>
        array
          ( 'PairID' => array ( 'concept' => 'PairID', 'unique' => false, 'null' => false)
          , 'Atom' => array ( 'concept' => 'Atom', 'unique' => false, 'null' => false)
          )
    , 'nsshareduploaded' =>
        array
          ( 'User' => array ( 'concept' => 'User', 'unique' => false, 'null' => false)
          , 'File' => array ( 'concept' => 'File', 'unique' => false, 'null' => false)
          )
    , 'nssharedincludes' =>
        array
          ( 'Context' => array ( 'concept' => 'Context', 'unique' => false, 'null' => false)
          , 'File' => array ( 'concept' => 'File', 'unique' => false, 'null' => false)
          )
    , 'nssharedrapdescr' =>
        array
          ( 'MetaInformation' => array ( 'concept' => 'MetaInformation', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nssharedengineimage' =>
        array
          ( 'MetaInformation' => array ( 'concept' => 'MetaInformation', 'unique' => false, 'null' => false)
          , 'Image' => array ( 'concept' => 'Image', 'unique' => false, 'null' => false)
          )
    , 'nssharedengineexpl' =>
        array
          ( 'MetaInformation' => array ( 'concept' => 'MetaInformation', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nssharedgenimage' =>
        array
          ( 'MetaInformation' => array ( 'concept' => 'MetaInformation', 'unique' => false, 'null' => false)
          , 'Image' => array ( 'concept' => 'Image', 'unique' => false, 'null' => false)
          )
    , 'nssharedgenexpl' =>
        array
          ( 'MetaInformation' => array ( 'concept' => 'MetaInformation', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nssharedimageurl' =>
        array
          ( 'Image' => array ( 'concept' => 'Image', 'unique' => false, 'null' => false)
          , 'URL' => array ( 'concept' => 'URL', 'unique' => false, 'null' => false)
          )
    , 'nssharedrrviols' =>
        array
          ( 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          , 'Violation' => array ( 'concept' => 'Violation', 'unique' => false, 'null' => false)
          )
    , 'nsshareddecexample' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'PragmaSentence' => array ( 'concept' => 'PragmaSentence', 'unique' => false, 'null' => false)
          )
    , 'nssharedctxpats' =>
        array
          ( 'Context' => array ( 'concept' => 'Context', 'unique' => false, 'null' => false)
          , 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          )
    , 'nssharedctxcs' =>
        array
          ( 'Context' => array ( 'concept' => 'Context', 'unique' => false, 'null' => false)
          , 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          )
    , 'nssharedptrls' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          )
    , 'nssharedptgns' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Gen' => array ( 'concept' => 'Gen', 'unique' => false, 'null' => false)
          )
    , 'nssharedptdcs' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          )
    , 'nssharedptxps' =>
        array
          ( 'Pattern' => array ( 'concept' => 'Pattern', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nssharedcptos' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'AtomID' => array ( 'concept' => 'AtomID', 'unique' => false, 'null' => false)
          )
    , 'nssharedcptdf' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nssharedcptpurpose' =>
        array
          ( 'Concept' => array ( 'concept' => 'Concept', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nsshareddeclaredthrough' =>
        array
          ( 'PropertyRule' => array ( 'concept' => 'PropertyRule', 'unique' => false, 'null' => true)
          , 'Property' => array ( 'concept' => 'Property', 'unique' => false, 'null' => false)
          )
    , 'nsshareddecmean' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nsshareddecpurpose' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nsshareddecpopu' =>
        array
          ( 'Declaration' => array ( 'concept' => 'Declaration', 'unique' => false, 'null' => false)
          , 'PairID' => array ( 'concept' => 'PairID', 'unique' => false, 'null' => false)
          )
    , 'nssharedrels' =>
        array
          ( 'ExpressionID' => array ( 'concept' => 'ExpressionID', 'unique' => false, 'null' => false)
          , 'Relation' => array ( 'concept' => 'Relation', 'unique' => false, 'null' => false)
          )
    , 'nssharedrrmean' =>
        array
          ( 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    , 'nssharedrrpurpose' =>
        array
          ( 'Rule' => array ( 'concept' => 'Rule', 'unique' => false, 'null' => false)
          , 'Blob' => array ( 'concept' => 'Blob', 'unique' => false, 'null' => false)
          )
    );

$allRulesSql =
  array
    ( 'unique file location' =>
        array ( 'name' => 'unique file location'
              , 'ruleAdl' => 'filename;filename~/\\filepath;filepath~ |- I'
              , 'origin' => 'line 139, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => 'The location of files is not unique for all files.'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalized complement (== violationsSQL): filename;filename~/\\filepath;filepath~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filename;filename~\",\"filepath;filepath~\",\"-I\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filename\",\"filename~\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM `nssharedFile` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filename`
                                        FROM `nssharedFile`
                                        WHERE `File` IS NOT NULL AND `filename` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`filename`=ECps1.`filename`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filepath\",\"filepath~\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM `nssharedFile` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filepath`
                                        FROM `nssharedFile`
                                        WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`filepath`=ECps1.`filepath`
                               ) AS isect1
                          WHERE (isect0.`File` = isect1.`File` AND isect0.`File1` = isect1.`File1`) AND isect0.`File` <> isect0.`File1` AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'The location of file ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'File'
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `File` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `File` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' and ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'File'
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `File` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `File` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is not unique c.q. both ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'FilePath'
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'FileName'
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL'
                            )
                    )
              )
    , 'user roles' =>
        array ( 'name' => 'user roles'
              , 'ruleAdl' => '\'Student\' \\/ \'StudentDesigner\' \\/ \'Designer\' |- I[Role]'
              , 'origin' => 'line 150, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Role'
              , 'tgtConcept' => 'Role'
              // Normalized complement (== violationsSQL): (\'Student\' \\/ \'StudentDesigner\' \\/ \'Designer\')/\\-I[Role]
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"\'Student\' \\\\/ \'StudentDesigner\' \\\\/ \'Designer\'\",\"-I[Role]\"] */
                          SELECT DISTINCT isect0.`MpRole` AS src, isect0.`MpRole1` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"\'Student\'\",\"\'StudentDesigner\'\",\"\'Designer\'\"] */
                                 (SELECT \'Student\' AS `MpRole`, \'Student\' AS `MpRole1`
                                 ) UNION (SELECT \'StudentDesigner\' AS `MpRole`, \'StudentDesigner\' AS `MpRole1`
                                 ) UNION (SELECT \'Designer\' AS `MpRole`, \'Designer\' AS `MpRole1`
                                 
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: ETyp x _
                                                ETyp ( \"I\" ) _ */
                                             SELECT DISTINCT `Role`, `Role` AS `Role1`
                                             FROM `nssharedRole`
                                             WHERE `Role` IS NOT NULL AND `Role` IS NOT NULL
                                           ) AS cp
                                      WHERE isect0.`MpRole`=cp.`Role` AND isect0.`MpRole1`=cp.`Role1`) AND isect0.`MpRole` IS NOT NULL AND isect0.`MpRole1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'eq gen' =>
        array ( 'name' => 'eq gen'
              , 'ruleAdl' => 'gengen;gengen~/\\genspc;genspc~ |- I'
              , 'origin' => 'line 48, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Gen'
              , 'tgtConcept' => 'Gen'
              // Normalized complement (== violationsSQL): gengen;gengen~/\\genspc;genspc~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"gengen;gengen~\",\"genspc;genspc~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Gen` AS src, isect0.`Gen1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"gengen\",\"gengen~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                 FROM `nssharedGen` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `gengen`
                                        FROM `nssharedGen`
                                        WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`gengen`=ECps1.`gengen`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"genspc\",\"genspc~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                 FROM `nssharedGen` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `genspc`
                                        FROM `nssharedGen`
                                        WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`genspc`=ECps1.`genspc`
                               ) AS isect1
                          WHERE (isect0.`Gen` = isect1.`Gen` AND isect0.`Gen1` = isect1.`Gen1`) AND isect0.`Gen` <> isect0.`Gen1` AND isect0.`Gen` IS NOT NULL AND isect0.`Gen1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'order' =>
        array ( 'name' => 'order'
              , 'ruleAdl' => 'order~;genspc~;gengen;order |- I'
              , 'origin' => 'line 78, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Order'
              , 'tgtConcept' => 'Order'
              // Normalized complement (== violationsSQL): order~;genspc~;gengen;order/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"order~;genspc~;gengen;order\",\"-I\"] */
                          SELECT DISTINCT isect0.`order` AS src, isect0.`order1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"order~\",\"genspc~\",\"gengen\",\"order\"] */
                                 
                                 SELECT DISTINCT ECps0.`order`, ECps3.`order` AS `order1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `order`
                                        FROM `nssharedConid`
                                        WHERE `cptnm` IS NOT NULL AND `order` IS NOT NULL
                                      ) AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `genspc`
                                        FROM `nssharedGen`
                                        WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                      ) AS ECps1,
                                      `nssharedGen` AS ECps2,
                                      `nssharedConid` AS ECps3
                                 WHERE ECps0.`cptnm`=ECps1.`genspc`
                                   AND ECps1.`Gen`=ECps2.`Gen`
                                   AND ECps2.`gengen`=ECps3.`cptnm`
                               ) AS isect0
                          WHERE isect0.`order` <> isect0.`order1` AND isect0.`order` IS NOT NULL AND isect0.`order1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'referential integrity' =>
        array ( 'name' => 'referential integrity'
              , 'ruleAdl' => 'src~;decsgn~;decpopu;left \\/ trg~;decsgn~;decpopu;right |- order;order~;cptos'
              , 'origin' => 'line 85, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => '<div class=\'violmsg\' rule=\'usedatom\' onclick=\'showviolationdetails(usedatom)\'><b>Either</b> You try to use an atom in a tuple of the wrong concept <b>or</b> you try to remove atoms from the population of a concept, which are still used in the population of one or more relations. Either way, this is a <b>violation of the integrity of a relation</b>. However in the first case the integrity is violated because of a type violation: <i>the atom does not exist in the population of the required concept</i>. For more information, see book <i>Rule Based Design</i>, page 52, <i>referential integrity</i>. In the first case, see the violation of the type of the relation. In the second case, you need to remove the relationships of an atom first before you may remove it; your only option to continue is <i>cancel</i>.</div>'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'AtomID'
              // Normalized complement (== violationsSQL): (src~;decsgn~;decpopu;left \\/ trg~;decsgn~;decpopu;right)/\\-(order;order~;cptos)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"src~;decsgn~;decpopu;left \\\\/ trg~;decsgn~;decpopu;right\",\"-(order;order~;cptos)\"] */
                          SELECT DISTINCT isect0.`src`, isect0.`left` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"src~;decsgn~;decpopu;left\",\"trg~;decsgn~;decpopu;right\"] */
                                 (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"src~\",\"decsgn~\",\"decpopu\",\"left\"] */
                                     
                                     SELECT DISTINCT ECps0.`src`, ECps3.`left`
                                     FROM 
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Sign`, `src`
                                            FROM `nssharedSign`
                                            WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                          ) AS ECps0,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Declaration`, `decsgn`
                                            FROM `nssharedDeclaration`
                                            WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL
                                          ) AS ECps1,
                                          `nsshareddecpopu` AS ECps2,
                                          `nssharedPairID` AS ECps3
                                     WHERE ECps0.`Sign`=ECps1.`decsgn`
                                       AND ECps1.`Declaration`=ECps2.`Declaration`
                                       AND ECps2.`PairID`=ECps3.`PairID`
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"trg~\",\"decsgn~\",\"decpopu\",\"right\"] */
                                     
                                     SELECT DISTINCT ECps0.`trg` AS `src`, ECps3.`right` AS `left`
                                     FROM 
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Sign`, `trg`
                                            FROM `nssharedSign`
                                            WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                          ) AS ECps0,
                                          
                                          ( /* case: EFlp x. */
                                            SELECT DISTINCT `Declaration`, `decsgn`
                                            FROM `nssharedDeclaration`
                                            WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL
                                          ) AS ECps1,
                                          `nsshareddecpopu` AS ECps2,
                                          `nssharedPairID` AS ECps3
                                     WHERE ECps0.`Sign`=ECps1.`decsgn`
                                       AND ECps1.`Declaration`=ECps2.`Declaration`
                                       AND ECps2.`PairID`=ECps3.`PairID`
                                 
                                 )
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"order\",\"order~\",\"cptos\"] */
                                             
                                             SELECT DISTINCT ECps0.`cptnm`, ECps2.`AtomID`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `cptnm`, `order`
                                                    FROM `nssharedConid`
                                                    WHERE `cptnm` IS NOT NULL AND `order` IS NOT NULL
                                                  ) AS ECps1,
                                                  `nssharedcptos` AS ECps2
                                             WHERE ECps0.`order`=ECps1.`order`
                                               AND ECps1.`cptnm`=ECps2.`Concept`
                                           ) AS cp
                                      WHERE isect0.`src`=cp.`cptnm` AND isect0.`left`=cp.`AtomID`) AND isect0.`src` IS NOT NULL AND isect0.`left` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Concept'
                            , 'expSQL' =>
                                'SELECT DISTINCT `cptnm` AS src, `cptnm` AS tgt
                                 FROM `nssharedConid`
                                 WHERE `cptnm` IS NOT NULL AND `cptnm` IS NOT NULL'
                            )
                    )
              )
    , 'entity integrity concept' =>
        array ( 'name' => 'entity integrity concept'
              , 'ruleAdl' => 'atomvalue;atomvalue~/\\cptos~;order;order~;cptos |- I'
              , 'origin' => 'line 97, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => 'You try to add atom values to the population of the concept, that already exist within the population of this concept or any ISA-related concept. This is a <b>violation of the integrity of the concept</b>. For more information, see book <i>Rule Based Design</i>, page 43 and 52, <i>entity integrity</i>. You need to remove duplicates to be able to save changes. You can make an atom more or less specific by moving it to another concept.'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalized complement (== violationsSQL): atomvalue;atomvalue~/\\cptos~;order;order~;cptos/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atomvalue;atomvalue~\",\"cptos~;order;order~;cptos\",\"-I\"] */
                          SELECT DISTINCT isect0.`AtomID` AS src, isect0.`AtomID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atomvalue\",\"atomvalue~\"] */
                                 
                                 SELECT DISTINCT ECps0.`AtomID`, ECps1.`AtomID` AS `AtomID1`
                                 FROM `nssharedAtomID` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AtomID`, `atomvalue`
                                        FROM `nssharedAtomID`
                                        WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`atomvalue`=ECps1.`atomvalue`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptos~\",\"order\",\"order~\",\"cptos\"] */
                                 
                                 SELECT DISTINCT ECps0.`AtomID`, ECps3.`AtomID` AS `AtomID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Concept`, `AtomID`
                                        FROM `nssharedcptos`
                                        WHERE `Concept` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `order`
                                        FROM `nssharedConid`
                                        WHERE `cptnm` IS NOT NULL AND `order` IS NOT NULL
                                      ) AS ECps2,
                                      `nssharedcptos` AS ECps3
                                 WHERE ECps0.`Concept`=ECps1.`cptnm`
                                   AND ECps1.`order`=ECps2.`order`
                                   AND ECps2.`cptnm`=ECps3.`Concept`
                               ) AS isect1
                          WHERE (isect0.`AtomID` = isect1.`AtomID` AND isect0.`AtomID1` = isect1.`AtomID1`) AND isect0.`AtomID` <> isect0.`AtomID1` AND isect0.`AtomID` IS NOT NULL AND isect0.`AtomID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is another atom in the population with the same value as atom ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'AtomID'
                            , 'expSQL' =>
                                'SELECT DISTINCT `AtomID` AS src, `AtomID` AS tgt
                                 FROM `nssharedAtomID`
                                 WHERE `AtomID` IS NOT NULL AND `AtomID` IS NOT NULL'
                            )
                    )
              )
    , 'eq declaration' =>
        array ( 'name' => 'eq declaration'
              , 'ruleAdl' => 'decnm;decnm~/\\decsgn;src;(decsgn;src)~/\\decsgn;trg;(decsgn;trg)~ |- I'
              , 'origin' => 'line 133, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalized complement (== violationsSQL): decnm;decnm~/\\decsgn;src;(decsgn;src)~/\\decsgn;trg;(decsgn;trg)~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decnm;decnm~\",\"decsgn;src;(decsgn;src)~\",\"decsgn;trg;(decsgn;trg)~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`Declaration1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decnm\",\"decnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps1.`Declaration` AS `Declaration1`
                                 FROM `nssharedDeclaration` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decnm`
                                        FROM `nssharedDeclaration`
                                        WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`decnm`=ECps1.`decnm`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"src\",\"(decsgn;src)~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps2.`Declaration` AS `Declaration1`
                                 FROM `nssharedDeclaration` AS ECps0,
                                      `nssharedSign` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        /* case: (ECps es), with two or more elements in es.
                                           ECps [\"decsgn\",\"src\"] */
                                        
                                        SELECT DISTINCT ECps0.`Declaration`, ECps1.`src`
                                        FROM `nssharedDeclaration` AS ECps0,
                                             `nssharedSign` AS ECps1
                                        WHERE ECps0.`decsgn`=ECps1.`Sign`
                                      ) AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`src`=ECps2.`src`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"trg\",\"(decsgn;trg)~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps2.`Declaration` AS `Declaration1`
                                 FROM `nssharedDeclaration` AS ECps0,
                                      `nssharedSign` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        /* case: (ECps es), with two or more elements in es.
                                           ECps [\"decsgn\",\"trg\"] */
                                        
                                        SELECT DISTINCT ECps0.`Declaration`, ECps1.`trg`
                                        FROM `nssharedDeclaration` AS ECps0,
                                             `nssharedSign` AS ECps1
                                        WHERE ECps0.`decsgn`=ECps1.`Sign`
                                      ) AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`trg`=ECps2.`trg`
                               ) AS isect2
                          WHERE (isect0.`Declaration` = isect1.`Declaration` AND isect0.`Declaration1` = isect1.`Declaration1`) AND (isect0.`Declaration` = isect2.`Declaration` AND isect0.`Declaration1` = isect2.`Declaration1`) AND isect0.`Declaration` <> isect0.`Declaration1` AND isect0.`Declaration` IS NOT NULL AND isect0.`Declaration1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'property enum' =>
        array ( 'name' => 'property enum'
              , 'ruleAdl' => 'I[Property] |- \'->\' \\/ \'UNI\' \\/ \'TOT\' \\/ \'INJ\' \\/ \'SUR\' \\/ \'RFX\' \\/ \'IRF\' \\/ \'SYM\' \\/ \'ASY\' \\/ \'TRN\' \\/ \'PROP\''
              , 'origin' => 'line 148, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Property'
              , 'tgtConcept' => 'Property'
              // Normalized complement (== violationsSQL): I[Property]/\\-\'->\'/\\-\'UNI\'/\\-\'TOT\'/\\-\'INJ\'/\\-\'SUR\'/\\-\'RFX\'/\\-\'IRF\'/\\-\'SYM\'/\\-\'ASY\'/\\-\'TRN\'/\\-\'PROP\'
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I[Property]\",\"-\'->\'\",\"-\'UNI\'\",\"-\'TOT\'\",\"-\'INJ\'\",\"-\'SUR\'\",\"-\'RFX\'\",\"-\'IRF\'\",\"-\'SYM\'\",\"-\'ASY\'\",\"-\'TRN\'\",\"-\'PROP\'\"] */
                          SELECT DISTINCT isect0.`Property` AS src, isect0.`Property1` AS tgt
                          FROM 
                               ( /* case: ETyp x _
                                    ETyp ( \"I\" ) _ */
                                 SELECT DISTINCT `Property`, `Property` AS `Property1`
                                 FROM `nssharedProperty`
                                 WHERE `Property` IS NOT NULL AND `Property` IS NOT NULL
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM ( SELECT \'->\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'UNI\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'TOT\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'INJ\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'SUR\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'RFX\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'IRF\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'SYM\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'ASY\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'TRN\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND NOT EXISTS (SELECT * FROM ( SELECT \'PROP\' AS `MpProperty` ) AS cp
                                      WHERE isect0.`Property`=cp.`MpProperty` AND isect0.`Property1`=cp.`MpProperty`) AND isect0.`Property` IS NOT NULL AND isect0.`Property1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'entity integrity of relation' =>
        array ( 'name' => 'entity integrity of relation'
              , 'ruleAdl' => 'left;left~/\\right;right~/\\decpopu~;decpopu |- I'
              , 'origin' => 'line 165, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => 'You try to add duplicate tuples to the population of the relation. This is a violation of the integrity of the relation. For more information, see book <i>Rule Based Design</i>, page 52, <i>entity integrity</i>. You need to remove duplicates to be able to save changes.'
              , 'srcConcept' => 'PairID'
              , 'tgtConcept' => 'PairID'
              // Normalized complement (== violationsSQL): left;left~/\\right;right~/\\decpopu~;decpopu/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"left;left~\",\"right;right~\",\"decpopu~;decpopu\",\"-I\"] */
                          SELECT DISTINCT isect0.`PairID` AS src, isect0.`PairID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"left\",\"left~\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                 FROM `nssharedPairID` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PairID`, `left`
                                        FROM `nssharedPairID`
                                        WHERE `PairID` IS NOT NULL AND `left` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`left`=ECps1.`left`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"right\",\"right~\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                 FROM `nssharedPairID` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PairID`, `right`
                                        FROM `nssharedPairID`
                                        WHERE `PairID` IS NOT NULL AND `right` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`right`=ECps1.`right`
                               ) AS isect1, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decpopu~\",\"decpopu\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `PairID`
                                        FROM `nsshareddecpopu`
                                        WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                      ) AS ECps0,
                                      `nsshareddecpopu` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect2
                          WHERE (isect0.`PairID` = isect1.`PairID` AND isect0.`PairID1` = isect1.`PairID1`) AND (isect0.`PairID` = isect2.`PairID` AND isect0.`PairID1` = isect2.`PairID1`) AND isect0.`PairID` <> isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'There is another tuple in the population with the same source and target as tuple ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'PairID'
                            , 'expSQL' =>
                                'SELECT DISTINCT `PairID` AS src, `PairID` AS tgt
                                 FROM `nssharedPairID`
                                 WHERE `PairID` IS NOT NULL AND `PairID` IS NOT NULL'
                            )
                    )
              )
    , 'typed domain' =>
        array ( 'name' => 'typed domain'
              , 'ruleAdl' => 'decpopu;left;cptos~;order |- decsgn;src;order'
              , 'origin' => 'line 170, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => 'You try to add a tuple with a source, that does not match the source of the relation. This is a violation of the type of the relation. TIP: enter the source of the relation in the left input field to get a shorter pick list. Note on ISA-relations: If you try to use an atom of a more generic concept, than you need to make the atom more specific first c.q. at least as specific as the source of the relation. You can make an atom more specific by adding it to the population of a more specific concept.'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Order'
              // Normalized complement (== violationsSQL): decpopu;left;cptos~;order/\\-(decsgn;src;order)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decpopu;left;cptos~;order\",\"-(decsgn;src;order)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`order` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decpopu\",\"left\",\"cptos~\",\"order\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps3.`order`
                                 FROM `nsshareddecpopu` AS ECps0,
                                      `nssharedPairID` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Concept`, `AtomID`
                                        FROM `nssharedcptos`
                                        WHERE `Concept` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps2,
                                      `nssharedConid` AS ECps3
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                                   AND ECps1.`left`=ECps2.`AtomID`
                                   AND ECps2.`Concept`=ECps3.`cptnm`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"src\",\"order\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps2.`order`
                                             FROM `nssharedDeclaration` AS ECps0,
                                                  `nssharedSign` AS ECps1,
                                                  `nssharedConid` AS ECps2
                                             WHERE ECps0.`decsgn`=ECps1.`Sign`
                                               AND ECps1.`src`=ECps2.`cptnm`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`order`=cp.`order`) AND isect0.`Declaration` IS NOT NULL AND isect0.`order` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'The atom ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Order'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ordername` AS src, `ordername` AS tgt
                                 FROM `nssharedString`
                                 WHERE `ordername` IS NOT NULL AND `ordername` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is of a concept that does not match source ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Concept'
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"src\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration` AS src, ECps1.`src` AS tgt
                                 FROM `nssharedDeclaration` AS ECps0,
                                      `nssharedSign` AS ECps1
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`'
                            )
                    )
              )
    , 'typed codomain' =>
        array ( 'name' => 'typed codomain'
              , 'ruleAdl' => 'decpopu;right;cptos~;order |- decsgn;trg;order'
              , 'origin' => 'line 174, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => 'You try to add a tuple with a target, that does not match the target of the relation. This is a violation of the type of the relation. TIP: enter the target of the relation in the right input field to get a shorter pick list. Note on ISA-relations: If you try to use an atom of a more generic concept, than you need to make the atom more specific first c.q. at least as specific as the target of the relation. You can make an atom more specific by adding it to the population of a more specific concept.'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Order'
              // Normalized complement (== violationsSQL): decpopu;right;cptos~;order/\\-(decsgn;trg;order)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decpopu;right;cptos~;order\",\"-(decsgn;trg;order)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`order` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decpopu\",\"right\",\"cptos~\",\"order\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration`, ECps3.`order`
                                 FROM `nsshareddecpopu` AS ECps0,
                                      `nssharedPairID` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Concept`, `AtomID`
                                        FROM `nssharedcptos`
                                        WHERE `Concept` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps2,
                                      `nssharedConid` AS ECps3
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                                   AND ECps1.`right`=ECps2.`AtomID`
                                   AND ECps2.`Concept`=ECps3.`cptnm`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"trg\",\"order\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps2.`order`
                                             FROM `nssharedDeclaration` AS ECps0,
                                                  `nssharedSign` AS ECps1,
                                                  `nssharedConid` AS ECps2
                                             WHERE ECps0.`decsgn`=ECps1.`Sign`
                                               AND ECps1.`trg`=ECps2.`cptnm`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`order`=cp.`order`) AND isect0.`Declaration` IS NOT NULL AND isect0.`order` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'The atom ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Order'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ordername` AS src, `ordername` AS tgt
                                 FROM `nssharedString`
                                 WHERE `ordername` IS NOT NULL AND `ordername` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is of a concept that does not match target ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Concept'
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"src\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration` AS src, ECps1.`src` AS tgt
                                 FROM `nssharedDeclaration` AS ECps0,
                                      `nssharedSign` AS ECps1
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`'
                            )
                    )
              )
    , 'rel name is decl name' =>
        array ( 'name' => 'rel name is decl name'
              , 'ruleAdl' => 'relnm = reldcl;decnm'
              , 'origin' => 'line 200, file "AST.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Varid'
              // Normalized complement (== violationsSQL): (relnm \\/ reldcl;decnm)/\\(-(reldcl;decnm) \\/ -relnm)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"relnm \\\\/ reldcl;decnm\",\"-(reldcl;decnm) \\\\/ -relnm\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`relnm` AS tgt
                          FROM 
                               ( /* case: EUni es
                                    EUni [\"relnm\",\"reldcl;decnm\"] */
                                 (SELECT DISTINCT `Relation`, `relnm`
                                     FROM `nssharedRelation`
                                     WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL
                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                        ECps [\"reldcl\",\"decnm\"] */
                                     
                                     SELECT DISTINCT ECps0.`Relation`, ECps1.`decnm` AS `relnm`
                                     FROM `nssharedRelation` AS ECps0,
                                          `nssharedDeclaration` AS ECps1
                                     WHERE ECps0.`reldcl`=ECps1.`Declaration`
                                 
                                 )
                               ) AS isect0, 
                               ( /* case: EUni es
                                    EUni [\"-(reldcl;decnm)\",\"-relnm\"] */
                                 (/* case: ECpl e
                                        ECpl [ \"reldcl;decnm\" ] */
                                     SELECT DISTINCT cfst.`Relation`, csnd.`Varid` AS `decnm`
                                     FROM `nssharedRelation` AS cfst,
                                          `nssharedVarid` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ECps [\"reldcl\",\"decnm\"] */
                                              
                                              SELECT DISTINCT ECps0.`Relation`, ECps1.`decnm`
                                              FROM `nssharedRelation` AS ECps0,
                                                   `nssharedDeclaration` AS ECps1
                                              WHERE ECps0.`reldcl`=ECps1.`Declaration`
                                            ) AS cp
                                       WHERE cfst.`Relation`=cp.`Relation` AND csnd.`Varid`=cp.`decnm`)
                                 ) UNION (/* case: ECpl e
                                        ECpl [ \"relnm\" ] */
                                     SELECT DISTINCT cfst.`Relation`, csnd.`Varid` AS `decnm`
                                     FROM `nssharedRelation` AS cfst,
                                          `nssharedVarid` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM `nssharedRelation` AS cp
                                       WHERE cfst.`Relation`=cp.`Relation` AND csnd.`Varid`=cp.`relnm`)
                                 
                                 )
                               ) AS isect1
                          WHERE (isect0.`Relation` = isect1.`Relation` AND isect0.`relnm` = isect1.`decnm`) AND isect0.`Relation` IS NOT NULL AND isect0.`relnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'specgenduplicate' =>
        array ( 'name' => 'specgenduplicate'
              , 'ruleAdl' => '-(cptos;atomvalue/\\(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue)'
              , 'origin' => 'line 41, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<span class=\'warnsignal\'>For an atom of a specific concept, there exists an equally named however different atom of a more generic concept.</span> This is temporarily allowed while you are editing the population untill you validate the changes. These atoms will be unified after you have validated the changes. The resulting atom will be of the most specific concept where it exists for now.'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Atom'
              // Normalized complement (== violationsSQL): cptos;atomvalue/\\(genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptos;atomvalue\",\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~;cptos;atomvalue\"] */
                          SELECT DISTINCT isect0.`Concept` AS src, isect0.`atomvalue` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptos\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`Concept`, ECps1.`atomvalue`
                                 FROM `nssharedcptos` AS ECps0,
                                      `nssharedAtomID` AS ECps1
                                 WHERE ECps0.`AtomID`=ECps1.`AtomID`
                               ) AS isect0, 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"(genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen \\\\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~\",\"cptos\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`gengen`, ECps2.`atomvalue`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        /* case: EUni es
                                           EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                        (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"genspc~\",\"gengen\"] */
                                            
                                            SELECT DISTINCT ECps0.`genspc`, ECps1.`gengen`
                                            FROM 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `nssharedGen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps0,
                                                 `nssharedGen` AS ECps1
                                            WHERE ECps0.`Gen`=ECps1.`Gen`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                            
                                            SELECT DISTINCT ECps0.`genspc`, ECps3.`gengen`
                                            FROM 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `nssharedGen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps0,
                                                 `nssharedGen` AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `nssharedGen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps2,
                                                 `nssharedGen` AS ECps3
                                            WHERE ECps0.`Gen`=ECps1.`Gen`
                                              AND ECps1.`gengen`=ECps2.`genspc`
                                              AND ECps2.`Gen`=ECps3.`Gen`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                            
                                            SELECT DISTINCT ECps0.`genspc`, ECps5.`gengen`
                                            FROM 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `nssharedGen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps0,
                                                 `nssharedGen` AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `nssharedGen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps2,
                                                 `nssharedGen` AS ECps3,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `Gen`, `genspc`
                                                   FROM `nssharedGen`
                                                   WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                 ) AS ECps4,
                                                 `nssharedGen` AS ECps5
                                            WHERE ECps0.`Gen`=ECps1.`Gen`
                                              AND ECps1.`gengen`=ECps2.`genspc`
                                              AND ECps2.`Gen`=ECps3.`Gen`
                                              AND ECps3.`gengen`=ECps4.`genspc`
                                              AND ECps4.`Gen`=ECps5.`Gen`
                                        
                                        
                                        )
                                      ) AS ECps0,
                                      `nssharedcptos` AS ECps1,
                                      `nssharedAtomID` AS ECps2
                                 WHERE ECps0.`genspc`=ECps1.`Concept`
                                   AND ECps1.`AtomID`=ECps2.`AtomID`
                               ) AS isect1
                          WHERE (isect0.`Concept` = isect1.`gengen` AND isect0.`atomvalue` = isect1.`atomvalue`) AND isect0.`Concept` IS NOT NULL AND isect0.`atomvalue` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Atom ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Atom'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Atom` AS src, `Atom` AS tgt
                                 FROM `nssharedAtom`
                                 WHERE `Atom` IS NOT NULL AND `Atom` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => 'will become more specific than ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Concept'
                            , 'expSQL' =>
                                'SELECT DISTINCT `cptnm` AS src, `cptnm` AS tgt
                                 FROM `nssharedConid`
                                 WHERE `cptnm` IS NOT NULL AND `cptnm` IS NOT NULL'
                            )
                    )
              )
    , 'multviolations' =>
        array ( 'name' => 'multviolations'
              , 'ruleAdl' => '-((I[PropertyRule]/\\declaredthrough;(\'->\' \\/ \'UNI\' \\/ \'TOT\' \\/ \'INJ\' \\/ \'SUR\');declaredthrough~);rrviols)'
              , 'origin' => 'line 45, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<br/><br/><span class=\'errsignal\'>Mult Violations of RULEs or relation properties have been detected.</span> Determine actions to resolve them.'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'Violation'
              // Normalized complement (== violationsSQL): (I[PropertyRule]/\\(declaredthrough;\'->\';declaredthrough~ \\/ declaredthrough;\'UNI\';declaredthrough~ \\/ declaredthrough;\'TOT\';declaredthrough~ \\/ declaredthrough;\'INJ\';declaredthrough~ \\/ declaredthrough;\'SUR\';declaredthrough~));rrviols
              , 'violationsSQL' => '/* case: (ECps es), with two or more elements in es.
                             ECps [\"I[PropertyRule]/\\\\(declaredthrough;\'->\';declaredthrough~ \\\\/ declaredthrough;\'UNI\';declaredthrough~ \\\\/ declaredthrough;\'TOT\';declaredthrough~ \\\\/ declaredthrough;\'INJ\';declaredthrough~ \\\\/ declaredthrough;\'SUR\';declaredthrough~)\",\"rrviols\"] */
                          
                          SELECT DISTINCT ECps0.`PropertyRule` AS src, ECps1.`Violation` AS tgt
                          FROM 
                               ( /* case: (EIsc lst@(_:_:_))
                                    EIsc [\"I[PropertyRule]\",\"declaredthrough;\'->\';declaredthrough~ \\\\/ declaredthrough;\'UNI\';declaredthrough~ \\\\/ declaredthrough;\'TOT\';declaredthrough~ \\\\/ declaredthrough;\'INJ\';declaredthrough~ \\\\/ declaredthrough;\'SUR\';declaredthrough~\"] */
                                 SELECT DISTINCT isect0.`PropertyRule`, isect0.`PropertyRule1`
                                 FROM 
                                      ( /* case: ETyp x _
                                           ETyp ( \"I\" ) _ */
                                        SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                        FROM `nssharedADLid`
                                        WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                      ) AS isect0, 
                                      ( /* case: EUni es
                                           EUni [\"declaredthrough;\'->\';declaredthrough~\",\"declaredthrough;\'UNI\';declaredthrough~\",\"declaredthrough;\'TOT\';declaredthrough~\",\"declaredthrough;\'INJ\';declaredthrough~\",\"declaredthrough;\'SUR\';declaredthrough~\"] */
                                        (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'->\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'->\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'UNI\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'UNI\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'TOT\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'TOT\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'INJ\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'INJ\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'SUR\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'SUR\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        
                                        
                                        
                                        
                                        )
                                      ) AS isect1
                                 WHERE (isect0.`PropertyRule` = isect1.`PropertyRule` AND isect0.`PropertyRule1` = isect1.`PropertyRule1`) AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule1` IS NOT NULL
                               ) AS ECps0,
                               `nssharedrrviols` AS ECps1
                          WHERE ECps0.`PropertyRule1`=ECps1.`Rule`'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'RULE ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'PropertyRule'
                            , 'expSQL' =>
                                'SELECT DISTINCT `PropertyRule` AS src, `PropertyRule` AS tgt
                                 FROM `nssharedADLid`
                                 WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is violated by pair ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Violation'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Violation` AS src, `Violation` AS tgt
                                 FROM `nssharedPairID`
                                 WHERE `Violation` IS NOT NULL AND `Violation` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '.')
                    )
              )
    , 'homoviolations' =>
        array ( 'name' => 'homoviolations'
              , 'ruleAdl' => '-((I[PropertyRule]/\\declaredthrough;(\'RFX\' \\/ \'IRF\' \\/ \'SYM\' \\/ \'ASY\' \\/ \'TRN\' \\/ \'PROP\');declaredthrough~);rrviols)'
              , 'origin' => 'line 49, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<br/><br/><span class=\'errsignal\'>Homo Violations of RULEs or relation properties have been detected.</span> Determine actions to resolve them.'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'Violation'
              // Normalized complement (== violationsSQL): (I[PropertyRule]/\\(declaredthrough;\'RFX\';declaredthrough~ \\/ declaredthrough;\'IRF\';declaredthrough~ \\/ declaredthrough;\'SYM\';declaredthrough~ \\/ declaredthrough;\'ASY\';declaredthrough~ \\/ declaredthrough;\'TRN\';declaredthrough~ \\/ declaredthrough;\'PROP\';declaredthrough~));rrviols
              , 'violationsSQL' => '/* case: (ECps es), with two or more elements in es.
                             ECps [\"I[PropertyRule]/\\\\(declaredthrough;\'RFX\';declaredthrough~ \\\\/ declaredthrough;\'IRF\';declaredthrough~ \\\\/ declaredthrough;\'SYM\';declaredthrough~ \\\\/ declaredthrough;\'ASY\';declaredthrough~ \\\\/ declaredthrough;\'TRN\';declaredthrough~ \\\\/ declaredthrough;\'PROP\';declaredthrough~)\",\"rrviols\"] */
                          
                          SELECT DISTINCT ECps0.`PropertyRule` AS src, ECps1.`Violation` AS tgt
                          FROM 
                               ( /* case: (EIsc lst@(_:_:_))
                                    EIsc [\"I[PropertyRule]\",\"declaredthrough;\'RFX\';declaredthrough~ \\\\/ declaredthrough;\'IRF\';declaredthrough~ \\\\/ declaredthrough;\'SYM\';declaredthrough~ \\\\/ declaredthrough;\'ASY\';declaredthrough~ \\\\/ declaredthrough;\'TRN\';declaredthrough~ \\\\/ declaredthrough;\'PROP\';declaredthrough~\"] */
                                 SELECT DISTINCT isect0.`PropertyRule`, isect0.`PropertyRule1`
                                 FROM 
                                      ( /* case: ETyp x _
                                           ETyp ( \"I\" ) _ */
                                        SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                        FROM `nssharedADLid`
                                        WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                      ) AS isect0, 
                                      ( /* case: EUni es
                                           EUni [\"declaredthrough;\'RFX\';declaredthrough~\",\"declaredthrough;\'IRF\';declaredthrough~\",\"declaredthrough;\'SYM\';declaredthrough~\",\"declaredthrough;\'ASY\';declaredthrough~\",\"declaredthrough;\'TRN\';declaredthrough~\",\"declaredthrough;\'PROP\';declaredthrough~\"] */
                                        (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'RFX\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'RFX\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'IRF\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'IRF\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'SYM\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'SYM\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'ASY\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'ASY\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'TRN\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'TRN\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        ) UNION (/* case: (ECps es), with two or more elements in es.
                                               ECps [\"declaredthrough\",\"\'PROP\'\",\"declaredthrough~\"] */
                                            
                                            SELECT DISTINCT ECps0.`PropertyRule`, ECps2.`PropertyRule` AS `PropertyRule1`
                                            FROM `nsshareddeclaredthrough` AS ECps0,
                                                 ( SELECT \'PROP\' AS `MpProperty` ) AS ECps1,
                                                 
                                                 ( /* case: EFlp x. */
                                                   SELECT DISTINCT `PropertyRule`, `Property`
                                                   FROM `nsshareddeclaredthrough`
                                                   WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                 ) AS ECps2
                                            WHERE ECps0.`Property`=ECps1.`MpProperty`
                                              AND ECps1.`MpProperty`=ECps2.`Property`
                                        
                                        
                                        
                                        
                                        
                                        )
                                      ) AS isect1
                                 WHERE (isect0.`PropertyRule` = isect1.`PropertyRule` AND isect0.`PropertyRule1` = isect1.`PropertyRule1`) AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule1` IS NOT NULL
                               ) AS ECps0,
                               `nssharedrrviols` AS ECps1
                          WHERE ECps0.`PropertyRule1`=ECps1.`Rule`'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'RULE ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'PropertyRule'
                            , 'expSQL' =>
                                'SELECT DISTINCT `PropertyRule` AS src, `PropertyRule` AS tgt
                                 FROM `nssharedADLid`
                                 WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is violated by pair ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Violation'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Violation` AS src, `Violation` AS tgt
                                 FROM `nssharedPairID`
                                 WHERE `Violation` IS NOT NULL AND `Violation` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '.')
                    )
              )
    , 'otherviolations' =>
        array ( 'name' => 'otherviolations'
              , 'ruleAdl' => '-((-I[PropertyRule]/\\I[Rule]);rrviols)'
              , 'origin' => 'line 53, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<br/><br/><span class=\'errsignal\'>Violations of RULEs or relation properties have been detected.</span> Determine actions to resolve them.'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Violation'
              // Normalized complement (== violationsSQL): (-I[PropertyRule]/\\I[Rule]);rrviols
              , 'violationsSQL' => '/* case: (ECps es), with two or more elements in es.
                             ECps [\"-I[PropertyRule]/\\\\I[Rule]\",\"rrviols\"] */
                          
                          SELECT DISTINCT ECps0.`PropertyRule` AS src, ECps1.`Violation` AS tgt
                          FROM 
                               ( /* case: (EIsc lst@(_:_:_))
                                    EIsc [\"-I[PropertyRule]\",\"I[Rule]\"] */
                                 SELECT DISTINCT isect0.`rrnm` AS `PropertyRule`, isect0.`rrnm1` AS `PropertyRule1`
                                 FROM 
                                      ( /* case: ETyp x _
                                           ETyp ( \"I\" ) _ */
                                        SELECT DISTINCT `rrnm`, `rrnm` AS `rrnm1`
                                        FROM `nssharedADLid`
                                        WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL
                                      ) AS isect0
                                 WHERE NOT EXISTS (SELECT * FROM 
                                                  ( /* case: ETyp x _
                                                       ETyp ( \"I\" ) _ */
                                                    SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                                    FROM `nssharedADLid`
                                                    WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                                  ) AS cp
                                             WHERE isect0.`rrnm`=cp.`PropertyRule` AND isect0.`rrnm1`=cp.`PropertyRule1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL
                               ) AS ECps0,
                               `nssharedrrviols` AS ECps1
                          WHERE ECps0.`PropertyRule1`=ECps1.`Rule`'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'RULE ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Rule'
                            , 'expSQL' =>
                                'SELECT DISTINCT `rrnm` AS src, `rrnm` AS tgt
                                 FROM `nssharedADLid`
                                 WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is violated by pair ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Violation'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Violation` AS src, `Violation` AS tgt
                                 FROM `nssharedPairID`
                                 WHERE `Violation` IS NOT NULL AND `Violation` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '.')
                    )
              )
    , 'dummy' =>
        array ( 'name' => 'dummy'
              , 'ruleAdl' => 'ctxnm |- ctxnm'
              , 'origin' => 'line 60, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => ''
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Conid'
              // Normalized complement (== violationsSQL): -V
              , 'violationsSQL' => '/* EUni [] */
                          SELECT DISTINCT 1 AS src, 1 AS tgt
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView' =>
                  array
                    ()
              )
    , 'popadd' =>
        array ( 'name' => 'popadd'
              , 'ruleAdl' => '(left;atomvalue)~;(decpopu~;decpopu/\\I);right;atomvalue |- inileft~;(inipopu~;inipopu/\\I);iniright'
              , 'origin' => 'line 76, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<br/>You have added tuples to the population of a relation. <span class=\'warnsignal\'>You still need to commit and validate the new population against your rules, to update the violations of your rules.</span> Go to <a href=\'index.php?interface=Validate&atom=1&role=0\'>Validate</a> to store the new population in a source file with the next version of your CONTEXT. This next version will be loaded automatically and available in <i>CONTEXT files</i>. WARNING: These changes will be overwritten when (re)loading any other source file now!'
              , 'srcConcept' => 'Atom'
              , 'tgtConcept' => 'Atom'
              // Normalized complement (== violationsSQL): (left;atomvalue)~;(decpopu~;decpopu/\\I);right;atomvalue/\\-(inileft~;(inipopu~;inipopu/\\I);iniright)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"(left;atomvalue)~;(decpopu~;decpopu/\\\\I);right;atomvalue\",\"-(inileft~;(inipopu~;inipopu/\\\\I);iniright)\"] */
                          SELECT DISTINCT isect0.`atomvalue` AS src, isect0.`atomvalue1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"(left;atomvalue)~\",\"decpopu~;decpopu/\\\\I\",\"right\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`atomvalue`, ECps3.`atomvalue` AS `atomvalue1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        /* case: (ECps es), with two or more elements in es.
                                           ECps [\"left\",\"atomvalue\"] */
                                        
                                        SELECT DISTINCT ECps0.`PairID`, ECps1.`atomvalue`
                                        FROM `nssharedPairID` AS ECps0,
                                             `nssharedAtomID` AS ECps1
                                        WHERE ECps0.`left`=ECps1.`AtomID`
                                      ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst@(_:_:_))
                                           EIsc [\"decpopu~;decpopu\",\"I\"] */
                                        SELECT DISTINCT isect0.`PairID`, isect0.`PairID1`
                                        FROM 
                                             ( /* case: (ECps es), with two or more elements in es.
                                                  ECps [\"decpopu~\",\"decpopu\"] */
                                               
                                               SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                               FROM 
                                                    ( /* case: EFlp x. */
                                                      SELECT DISTINCT `Declaration`, `PairID`
                                                      FROM `nsshareddecpopu`
                                                      WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                                    ) AS ECps0,
                                                    `nsshareddecpopu` AS ECps1
                                               WHERE ECps0.`Declaration`=ECps1.`Declaration`
                                             ) AS isect0, `nssharedPairID` AS isect1
                                        WHERE isect0.`PairID` = isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL
                                      ) AS ECps1,
                                      `nssharedPairID` AS ECps2,
                                      `nssharedAtomID` AS ECps3
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                                   AND ECps1.`PairID1`=ECps2.`PairID`
                                   AND ECps2.`right`=ECps3.`AtomID`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"inileft~\",\"inipopu~;inipopu/\\\\I\",\"iniright\"] */
                                             
                                             SELECT DISTINCT ECps0.`Atom`, ECps2.`Atom` AS `Atom1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PairID`, `Atom`
                                                    FROM `nssharedinileft`
                                                    WHERE `PairID` IS NOT NULL AND `Atom` IS NOT NULL
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"inipopu~;inipopu\",\"I\"] */
                                                    SELECT DISTINCT isect0.`PairID`, isect0.`PairID1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"inipopu~\",\"inipopu\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Declaration`, `PairID`
                                                                  FROM `nssharedinipopu`
                                                                  WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                                                ) AS ECps0,
                                                                `nssharedinipopu` AS ECps1
                                                           WHERE ECps0.`Declaration`=ECps1.`Declaration`
                                                         ) AS isect0, `nssharedPairID` AS isect1
                                                    WHERE isect0.`PairID` = isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL
                                                  ) AS ECps1,
                                                  `nssharediniright` AS ECps2
                                             WHERE ECps0.`PairID`=ECps1.`PairID`
                                               AND ECps1.`PairID1`=ECps2.`PairID`
                                           ) AS cp
                                      WHERE isect0.`atomvalue`=cp.`Atom` AND isect0.`atomvalue1`=cp.`Atom1`) AND isect0.`atomvalue` IS NOT NULL AND isect0.`atomvalue1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'added pair ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Atom'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Atom` AS src, `Atom` AS tgt
                                 FROM `nssharedAtom`
                                 WHERE `Atom` IS NOT NULL AND `Atom` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Atom'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Atom` AS src, `Atom` AS tgt
                                 FROM `nssharedAtom`
                                 WHERE `Atom` IS NOT NULL AND `Atom` IS NOT NULL'
                            )
                    )
              )
    , 'popdel' =>
        array ( 'name' => 'popdel'
              , 'ruleAdl' => 'inileft~;(inipopu~;inipopu/\\I);iniright |- (left;atomvalue)~;(decpopu~;decpopu/\\I);right;atomvalue'
              , 'origin' => 'line 80, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<br/>You have removed tuples from the population of a relation. <span class=\'warnsignal\'>You still need to commit and validate the new population against your rules, to update the violations of your rules.</span> Go to <a href=\'index.php?interface=Validate&atom=1&role=0\'>Validate</a> to store the new population in a source file with the next version of your CONTEXT. This next version will be loaded automatically and available in <i>CONTEXT files</i>. WARNING: These changes will be overwritten when (re)loading any other source file now!'
              , 'srcConcept' => 'Atom'
              , 'tgtConcept' => 'Atom'
              // Normalized complement (== violationsSQL): inileft~;(inipopu~;inipopu/\\I);iniright/\\-((left;atomvalue)~;(decpopu~;decpopu/\\I);right;atomvalue)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"inileft~;(inipopu~;inipopu/\\\\I);iniright\",\"-((left;atomvalue)~;(decpopu~;decpopu/\\\\I);right;atomvalue)\"] */
                          SELECT DISTINCT isect0.`Atom` AS src, isect0.`Atom1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"inileft~\",\"inipopu~;inipopu/\\\\I\",\"iniright\"] */
                                 
                                 SELECT DISTINCT ECps0.`Atom`, ECps2.`Atom` AS `Atom1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PairID`, `Atom`
                                        FROM `nssharedinileft`
                                        WHERE `PairID` IS NOT NULL AND `Atom` IS NOT NULL
                                      ) AS ECps0,
                                      
                                      ( /* case: (EIsc lst@(_:_:_))
                                           EIsc [\"inipopu~;inipopu\",\"I\"] */
                                        SELECT DISTINCT isect0.`PairID`, isect0.`PairID1`
                                        FROM 
                                             ( /* case: (ECps es), with two or more elements in es.
                                                  ECps [\"inipopu~\",\"inipopu\"] */
                                               
                                               SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                               FROM 
                                                    ( /* case: EFlp x. */
                                                      SELECT DISTINCT `Declaration`, `PairID`
                                                      FROM `nssharedinipopu`
                                                      WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                                    ) AS ECps0,
                                                    `nssharedinipopu` AS ECps1
                                               WHERE ECps0.`Declaration`=ECps1.`Declaration`
                                             ) AS isect0, `nssharedPairID` AS isect1
                                        WHERE isect0.`PairID` = isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL
                                      ) AS ECps1,
                                      `nssharediniright` AS ECps2
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                                   AND ECps1.`PairID1`=ECps2.`PairID`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"(left;atomvalue)~\",\"decpopu~;decpopu/\\\\I\",\"right\",\"atomvalue\"] */
                                             
                                             SELECT DISTINCT ECps0.`atomvalue`, ECps3.`atomvalue` AS `atomvalue1`
                                             FROM 
                                                  ( /* case: EFlp x. */
                                                    /* case: (ECps es), with two or more elements in es.
                                                       ECps [\"left\",\"atomvalue\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`PairID`, ECps1.`atomvalue`
                                                    FROM `nssharedPairID` AS ECps0,
                                                         `nssharedAtomID` AS ECps1
                                                    WHERE ECps0.`left`=ECps1.`AtomID`
                                                  ) AS ECps0,
                                                  
                                                  ( /* case: (EIsc lst@(_:_:_))
                                                       EIsc [\"decpopu~;decpopu\",\"I\"] */
                                                    SELECT DISTINCT isect0.`PairID`, isect0.`PairID1`
                                                    FROM 
                                                         ( /* case: (ECps es), with two or more elements in es.
                                                              ECps [\"decpopu~\",\"decpopu\"] */
                                                           
                                                           SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                                           FROM 
                                                                ( /* case: EFlp x. */
                                                                  SELECT DISTINCT `Declaration`, `PairID`
                                                                  FROM `nsshareddecpopu`
                                                                  WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL
                                                                ) AS ECps0,
                                                                `nsshareddecpopu` AS ECps1
                                                           WHERE ECps0.`Declaration`=ECps1.`Declaration`
                                                         ) AS isect0, `nssharedPairID` AS isect1
                                                    WHERE isect0.`PairID` = isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL
                                                  ) AS ECps1,
                                                  `nssharedPairID` AS ECps2,
                                                  `nssharedAtomID` AS ECps3
                                             WHERE ECps0.`PairID`=ECps1.`PairID`
                                               AND ECps1.`PairID1`=ECps2.`PairID`
                                               AND ECps2.`right`=ECps3.`AtomID`
                                           ) AS cp
                                      WHERE isect0.`Atom`=cp.`atomvalue` AND isect0.`Atom1`=cp.`atomvalue1`) AND isect0.`Atom` IS NOT NULL AND isect0.`Atom1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'removed pair ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Atom'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Atom` AS src, `Atom` AS tgt
                                 FROM `nssharedAtom`
                                 WHERE `Atom` IS NOT NULL AND `Atom` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Atom'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Atom` AS src, `Atom` AS tgt
                                 FROM `nssharedAtom`
                                 WHERE `Atom` IS NOT NULL AND `Atom` IS NOT NULL'
                            )
                    )
              )
    , 'parseerror' =>
        array ( 'name' => 'parseerror'
              , 'ruleAdl' => 'parseerror |- -parseerror'
              , 'origin' => 'line 84, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<span class=\'errsignal\'>The source file causes a parse error.</span> Therefore there is no CONTEXT.'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'ParseError'
              // Normalized complement (== violationsSQL): parseerror
              , 'violationsSQL' => 'SELECT DISTINCT `File` AS src, `parseerror` AS tgt
                          FROM `nssharedFile`
                          WHERE `File` IS NOT NULL AND `parseerror` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Error in source file ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'File'
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `File` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `File` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' (click to edit): expecting ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'String'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ParseError` AS src, `pe_expecting` AS tgt
                                 FROM `nssharedParseError`
                                 WHERE `ParseError` IS NOT NULL AND `pe_expecting` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'String'
                            , 'expSQL' =>
                                'SELECT DISTINCT `ParseError` AS src, `pe_position` AS tgt
                                 FROM `nssharedParseError`
                                 WHERE `ParseError` IS NOT NULL AND `pe_position` IS NOT NULL'
                            )
                    )
              )
    , 'typeerror' =>
        array ( 'name' => 'typeerror'
              , 'ruleAdl' => 'typeerror |- -typeerror'
              , 'origin' => 'line 88, file "rap.adl"'
              , 'meaning' => ''
              , 'message' => '<span class=\'errsignal\'>The source file causes one or more type errors.</span> Therefore the CONTEXT could not be loaded entirely. Only declarations and concepts have been loaded as information, which may be useful to understand and fix the errors.'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'TypeError'
              // Normalized complement (== violationsSQL): typeerror
              , 'violationsSQL' => 'SELECT DISTINCT `File` AS src, `TypeError` AS tgt
                          FROM `nssharedtypeerror2`
                          WHERE `File` IS NOT NULL AND `TypeError` IS NOT NULL'
              , 'pairView' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'The source file: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'File'
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `File` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `File` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' (click to edit). The error message: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ErrorMessage'
                            , 'expSQL' =>
                                'SELECT DISTINCT `TypeError` AS src, `te_message` AS tgt
                                 FROM `nssharedTypeError1`
                                 WHERE `TypeError` IS NOT NULL AND `te_message` IS NOT NULL'
                            )
                    )
              )
    , 'UNI firstloadedwith::AdlFile*AdlVersion' =>
        array ( 'name' => 'UNI firstloadedwith::AdlFile*AdlVersion'
              , 'ruleAdl' => 'firstloadedwith~;firstloadedwith |- I'
              , 'origin' => 'line 100, file "rap.adl"'
              , 'meaning' => 'firstloadedwith[AdlFile\\*AdlVersion] is univalent'
              , 'message' => 'firstloadedwith[AdlFile\\*AdlVersion] is niet univalent'
              , 'srcConcept' => 'AdlVersion'
              , 'tgtConcept' => 'AdlVersion'
              // Normalized complement (== violationsSQL): firstloadedwith~;firstloadedwith/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"firstloadedwith~;firstloadedwith\",\"-I\"] */
                          SELECT DISTINCT isect0.`firstloadedwith` AS src, isect0.`firstloadedwith1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"firstloadedwith~\",\"firstloadedwith\"] */
                                 
                                 SELECT DISTINCT ECps0.`firstloadedwith`, ECps1.`firstloadedwith` AS `firstloadedwith1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AdlFile`, `firstloadedwith`
                                        FROM `nssharedFile`
                                        WHERE `AdlFile` IS NOT NULL AND `firstloadedwith` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`firstloadedwith` <> isect0.`firstloadedwith1` AND isect0.`firstloadedwith` IS NOT NULL AND isect0.`firstloadedwith1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI parseerror::File*ParseError' =>
        array ( 'name' => 'UNI parseerror::File*ParseError'
              , 'ruleAdl' => 'parseerror~;parseerror |- I'
              , 'origin' => 'line 111, file "rap.adl"'
              , 'meaning' => 'parseerror[File\\*ParseError] is univalent'
              , 'message' => 'parseerror[File\\*ParseError] is niet univalent'
              , 'srcConcept' => 'ParseError'
              , 'tgtConcept' => 'ParseError'
              // Normalized complement (== violationsSQL): parseerror~;parseerror/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"parseerror~;parseerror\",\"-I\"] */
                          SELECT DISTINCT isect0.`parseerror` AS src, isect0.`parseerror1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"parseerror~\",\"parseerror\"] */
                                 
                                 SELECT DISTINCT ECps0.`parseerror`, ECps1.`parseerror` AS `parseerror1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `parseerror`
                                        FROM `nssharedFile`
                                        WHERE `File` IS NOT NULL AND `parseerror` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`parseerror` <> isect0.`parseerror1` AND isect0.`parseerror` IS NOT NULL AND isect0.`parseerror1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI pe_action::ParseError*String' =>
        array ( 'name' => 'UNI pe_action::ParseError*String'
              , 'ruleAdl' => 'pe_action~;pe_action |- I'
              , 'origin' => 'line 113, file "rap.adl"'
              , 'meaning' => 'pe\\_action[ParseError\\*String] is univalent'
              , 'message' => 'pe\\_action[ParseError\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): pe_action~;pe_action/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"pe_action~;pe_action\",\"-I\"] */
                          SELECT DISTINCT isect0.`pe_action` AS src, isect0.`pe_action1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"pe_action~\",\"pe_action\"] */
                                 
                                 SELECT DISTINCT ECps0.`pe_action`, ECps1.`pe_action` AS `pe_action1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ParseError`, `pe_action`
                                        FROM `nssharedParseError`
                                        WHERE `ParseError` IS NOT NULL AND `pe_action` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedParseError` AS ECps1
                                 WHERE ECps0.`ParseError`=ECps1.`ParseError`
                               ) AS isect0
                          WHERE isect0.`pe_action` <> isect0.`pe_action1` AND isect0.`pe_action` IS NOT NULL AND isect0.`pe_action1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT pe_action::ParseError*String' =>
        array ( 'name' => 'TOT pe_action::ParseError*String'
              , 'ruleAdl' => 'I |- pe_action;pe_action~'
              , 'origin' => 'line 113, file "rap.adl"'
              , 'meaning' => 'pe\\_action[ParseError\\*String] is totaal'
              , 'message' => 'pe\\_action[ParseError\\*String] is niet totaal'
              , 'srcConcept' => 'ParseError'
              , 'tgtConcept' => 'ParseError'
              // Normalized complement (== violationsSQL): I/\\-(pe_action;pe_action~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(pe_action;pe_action~)\"] */
                          SELECT DISTINCT isect0.`ParseError` AS src, isect0.`ParseError` AS tgt
                          FROM `nssharedParseError` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"pe_action\",\"pe_action~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ParseError`, ECps1.`ParseError` AS `ParseError1`
                                             FROM `nssharedParseError` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ParseError`, `pe_action`
                                                    FROM `nssharedParseError`
                                                    WHERE `ParseError` IS NOT NULL AND `pe_action` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`pe_action`=ECps1.`pe_action`
                                           ) AS cp
                                      WHERE isect0.`ParseError`=cp.`ParseError` AND isect0.`ParseError`=cp.`ParseError1`) AND isect0.`ParseError` IS NOT NULL AND isect0.`ParseError` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI pe_position::ParseError*String' =>
        array ( 'name' => 'UNI pe_position::ParseError*String'
              , 'ruleAdl' => 'pe_position~;pe_position |- I'
              , 'origin' => 'line 115, file "rap.adl"'
              , 'meaning' => 'pe\\_position[ParseError\\*String] is univalent'
              , 'message' => 'pe\\_position[ParseError\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): pe_position~;pe_position/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"pe_position~;pe_position\",\"-I\"] */
                          SELECT DISTINCT isect0.`pe_position` AS src, isect0.`pe_position1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"pe_position~\",\"pe_position\"] */
                                 
                                 SELECT DISTINCT ECps0.`pe_position`, ECps1.`pe_position` AS `pe_position1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ParseError`, `pe_position`
                                        FROM `nssharedParseError`
                                        WHERE `ParseError` IS NOT NULL AND `pe_position` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedParseError` AS ECps1
                                 WHERE ECps0.`ParseError`=ECps1.`ParseError`
                               ) AS isect0
                          WHERE isect0.`pe_position` <> isect0.`pe_position1` AND isect0.`pe_position` IS NOT NULL AND isect0.`pe_position1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT pe_position::ParseError*String' =>
        array ( 'name' => 'TOT pe_position::ParseError*String'
              , 'ruleAdl' => 'I |- pe_position;pe_position~'
              , 'origin' => 'line 115, file "rap.adl"'
              , 'meaning' => 'pe\\_position[ParseError\\*String] is totaal'
              , 'message' => 'pe\\_position[ParseError\\*String] is niet totaal'
              , 'srcConcept' => 'ParseError'
              , 'tgtConcept' => 'ParseError'
              // Normalized complement (== violationsSQL): I/\\-(pe_position;pe_position~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(pe_position;pe_position~)\"] */
                          SELECT DISTINCT isect0.`ParseError` AS src, isect0.`ParseError` AS tgt
                          FROM `nssharedParseError` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"pe_position\",\"pe_position~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ParseError`, ECps1.`ParseError` AS `ParseError1`
                                             FROM `nssharedParseError` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ParseError`, `pe_position`
                                                    FROM `nssharedParseError`
                                                    WHERE `ParseError` IS NOT NULL AND `pe_position` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`pe_position`=ECps1.`pe_position`
                                           ) AS cp
                                      WHERE isect0.`ParseError`=cp.`ParseError` AND isect0.`ParseError`=cp.`ParseError1`) AND isect0.`ParseError` IS NOT NULL AND isect0.`ParseError` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI pe_expecting::ParseError*String' =>
        array ( 'name' => 'UNI pe_expecting::ParseError*String'
              , 'ruleAdl' => 'pe_expecting~;pe_expecting |- I'
              , 'origin' => 'line 117, file "rap.adl"'
              , 'meaning' => 'pe\\_expecting[ParseError\\*String] is univalent'
              , 'message' => 'pe\\_expecting[ParseError\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): pe_expecting~;pe_expecting/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"pe_expecting~;pe_expecting\",\"-I\"] */
                          SELECT DISTINCT isect0.`pe_expecting` AS src, isect0.`pe_expecting1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"pe_expecting~\",\"pe_expecting\"] */
                                 
                                 SELECT DISTINCT ECps0.`pe_expecting`, ECps1.`pe_expecting` AS `pe_expecting1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ParseError`, `pe_expecting`
                                        FROM `nssharedParseError`
                                        WHERE `ParseError` IS NOT NULL AND `pe_expecting` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedParseError` AS ECps1
                                 WHERE ECps0.`ParseError`=ECps1.`ParseError`
                               ) AS isect0
                          WHERE isect0.`pe_expecting` <> isect0.`pe_expecting1` AND isect0.`pe_expecting` IS NOT NULL AND isect0.`pe_expecting1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT pe_expecting::ParseError*String' =>
        array ( 'name' => 'TOT pe_expecting::ParseError*String'
              , 'ruleAdl' => 'I |- pe_expecting;pe_expecting~'
              , 'origin' => 'line 117, file "rap.adl"'
              , 'meaning' => 'pe\\_expecting[ParseError\\*String] is totaal'
              , 'message' => 'pe\\_expecting[ParseError\\*String] is niet totaal'
              , 'srcConcept' => 'ParseError'
              , 'tgtConcept' => 'ParseError'
              // Normalized complement (== violationsSQL): I/\\-(pe_expecting;pe_expecting~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(pe_expecting;pe_expecting~)\"] */
                          SELECT DISTINCT isect0.`ParseError` AS src, isect0.`ParseError` AS tgt
                          FROM `nssharedParseError` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"pe_expecting\",\"pe_expecting~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ParseError`, ECps1.`ParseError` AS `ParseError1`
                                             FROM `nssharedParseError` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ParseError`, `pe_expecting`
                                                    FROM `nssharedParseError`
                                                    WHERE `ParseError` IS NOT NULL AND `pe_expecting` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`pe_expecting`=ECps1.`pe_expecting`
                                           ) AS cp
                                      WHERE isect0.`ParseError`=cp.`ParseError` AND isect0.`ParseError`=cp.`ParseError1`) AND isect0.`ParseError` IS NOT NULL AND isect0.`ParseError` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI te_message::TypeError*ErrorMessage' =>
        array ( 'name' => 'UNI te_message::TypeError*ErrorMessage'
              , 'ruleAdl' => 'te_message~;te_message |- I'
              , 'origin' => 'line 121, file "rap.adl"'
              , 'meaning' => 'te\\_message[TypeError\\*ErrorMessage] is univalent'
              , 'message' => 'te\\_message[TypeError\\*ErrorMessage] is niet univalent'
              , 'srcConcept' => 'ErrorMessage'
              , 'tgtConcept' => 'ErrorMessage'
              // Normalized complement (== violationsSQL): te_message~;te_message/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"te_message~;te_message\",\"-I\"] */
                          SELECT DISTINCT isect0.`te_message` AS src, isect0.`te_message1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"te_message~\",\"te_message\"] */
                                 
                                 SELECT DISTINCT ECps0.`te_message`, ECps1.`te_message` AS `te_message1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `TypeError`, `te_message`
                                        FROM `nssharedTypeError1`
                                        WHERE `TypeError` IS NOT NULL AND `te_message` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedTypeError1` AS ECps1
                                 WHERE ECps0.`TypeError`=ECps1.`TypeError`
                               ) AS isect0
                          WHERE isect0.`te_message` <> isect0.`te_message1` AND isect0.`te_message` IS NOT NULL AND isect0.`te_message1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI te_parent::TypeError*TypeError' =>
        array ( 'name' => 'UNI te_parent::TypeError*TypeError'
              , 'ruleAdl' => 'te_parent~;te_parent |- I'
              , 'origin' => 'line 123, file "rap.adl"'
              , 'meaning' => 'te\\_parent[TypeError\\*TypeError] is univalent'
              , 'message' => 'te\\_parent[TypeError\\*TypeError] is niet univalent'
              , 'srcConcept' => 'TypeError'
              , 'tgtConcept' => 'TypeError'
              // Normalized complement (== violationsSQL): te_parent~;te_parent/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"te_parent~;te_parent\",\"-I\"] */
                          SELECT DISTINCT isect0.`te_parent` AS src, isect0.`te_parent1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"te_parent~\",\"te_parent\"] */
                                 
                                 SELECT DISTINCT ECps0.`te_parent`, ECps1.`te_parent` AS `te_parent1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `TypeError`, `te_parent`
                                        FROM `nssharedTypeError1`
                                        WHERE `TypeError` IS NOT NULL AND `te_parent` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedTypeError1` AS ECps1
                                 WHERE ECps0.`TypeError`=ECps1.`TypeError`
                               ) AS isect0
                          WHERE isect0.`te_parent` <> isect0.`te_parent1` AND isect0.`te_parent` IS NOT NULL AND isect0.`te_parent1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI te_position::TypeError*String' =>
        array ( 'name' => 'UNI te_position::TypeError*String'
              , 'ruleAdl' => 'te_position~;te_position |- I'
              , 'origin' => 'line 125, file "rap.adl"'
              , 'meaning' => 'te\\_position[TypeError\\*String] is univalent'
              , 'message' => 'te\\_position[TypeError\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): te_position~;te_position/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"te_position~;te_position\",\"-I\"] */
                          SELECT DISTINCT isect0.`te_position` AS src, isect0.`te_position1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"te_position~\",\"te_position\"] */
                                 
                                 SELECT DISTINCT ECps0.`te_position`, ECps1.`te_position` AS `te_position1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `TypeError`, `te_position`
                                        FROM `nssharedTypeError1`
                                        WHERE `TypeError` IS NOT NULL AND `te_position` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedTypeError1` AS ECps1
                                 WHERE ECps0.`TypeError`=ECps1.`TypeError`
                               ) AS isect0
                          WHERE isect0.`te_position` <> isect0.`te_position1` AND isect0.`te_position` IS NOT NULL AND isect0.`te_position1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI te_origtype::TypeError*String' =>
        array ( 'name' => 'UNI te_origtype::TypeError*String'
              , 'ruleAdl' => 'te_origtype~;te_origtype |- I'
              , 'origin' => 'line 127, file "rap.adl"'
              , 'meaning' => 'te\\_origtype[TypeError\\*String] is univalent'
              , 'message' => 'te\\_origtype[TypeError\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): te_origtype~;te_origtype/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"te_origtype~;te_origtype\",\"-I\"] */
                          SELECT DISTINCT isect0.`te_origtype` AS src, isect0.`te_origtype1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"te_origtype~\",\"te_origtype\"] */
                                 
                                 SELECT DISTINCT ECps0.`te_origtype`, ECps1.`te_origtype` AS `te_origtype1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `TypeError`, `te_origtype`
                                        FROM `nssharedTypeError1`
                                        WHERE `TypeError` IS NOT NULL AND `te_origtype` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedTypeError1` AS ECps1
                                 WHERE ECps0.`TypeError`=ECps1.`TypeError`
                               ) AS isect0
                          WHERE isect0.`te_origtype` <> isect0.`te_origtype1` AND isect0.`te_origtype` IS NOT NULL AND isect0.`te_origtype1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI te_origname::TypeError*String' =>
        array ( 'name' => 'UNI te_origname::TypeError*String'
              , 'ruleAdl' => 'te_origname~;te_origname |- I'
              , 'origin' => 'line 129, file "rap.adl"'
              , 'meaning' => 'te\\_origname[TypeError\\*String] is univalent'
              , 'message' => 'te\\_origname[TypeError\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): te_origname~;te_origname/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"te_origname~;te_origname\",\"-I\"] */
                          SELECT DISTINCT isect0.`te_origname` AS src, isect0.`te_origname1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"te_origname~\",\"te_origname\"] */
                                 
                                 SELECT DISTINCT ECps0.`te_origname`, ECps1.`te_origname` AS `te_origname1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `TypeError`, `te_origname`
                                        FROM `nssharedTypeError1`
                                        WHERE `TypeError` IS NOT NULL AND `te_origname` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedTypeError1` AS ECps1
                                 WHERE ECps0.`TypeError`=ECps1.`TypeError`
                               ) AS isect0
                          WHERE isect0.`te_origname` <> isect0.`te_origname1` AND isect0.`te_origname` IS NOT NULL AND isect0.`te_origname1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI filename::File*FileName' =>
        array ( 'name' => 'UNI filename::File*FileName'
              , 'ruleAdl' => 'filename~;filename |- I'
              , 'origin' => 'line 134, file "rap.adl"'
              , 'meaning' => 'filename[File\\*FileName] is univalent'
              , 'message' => 'filename[File\\*FileName] is niet univalent'
              , 'srcConcept' => 'FileName'
              , 'tgtConcept' => 'FileName'
              // Normalized complement (== violationsSQL): filename~;filename/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filename~;filename\",\"-I\"] */
                          SELECT DISTINCT isect0.`filename` AS src, isect0.`filename1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filename~\",\"filename\"] */
                                 
                                 SELECT DISTINCT ECps0.`filename`, ECps1.`filename` AS `filename1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filename`
                                        FROM `nssharedFile`
                                        WHERE `File` IS NOT NULL AND `filename` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`filename` <> isect0.`filename1` AND isect0.`filename` IS NOT NULL AND isect0.`filename1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT filename::File*FileName' =>
        array ( 'name' => 'TOT filename::File*FileName'
              , 'ruleAdl' => 'I |- filename;filename~'
              , 'origin' => 'line 134, file "rap.adl"'
              , 'meaning' => 'filename[File\\*FileName] is totaal'
              , 'message' => 'filename[File\\*FileName] is niet totaal'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalized complement (== violationsSQL): I/\\-(filename;filename~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(filename;filename~)\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File` AS tgt
                          FROM `nssharedFile` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"filename\",\"filename~\"] */
                                             
                                             SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                             FROM `nssharedFile` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `File`, `filename`
                                                    FROM `nssharedFile`
                                                    WHERE `File` IS NOT NULL AND `filename` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`filename`=ECps1.`filename`
                                           ) AS cp
                                      WHERE isect0.`File`=cp.`File` AND isect0.`File`=cp.`File1`) AND isect0.`File` IS NOT NULL AND isect0.`File` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI filepath::File*FilePath' =>
        array ( 'name' => 'UNI filepath::File*FilePath'
              , 'ruleAdl' => 'filepath~;filepath |- I'
              , 'origin' => 'line 136, file "rap.adl"'
              , 'meaning' => 'filepath[File\\*FilePath] is univalent'
              , 'message' => 'filepath[File\\*FilePath] is niet univalent'
              , 'srcConcept' => 'FilePath'
              , 'tgtConcept' => 'FilePath'
              // Normalized complement (== violationsSQL): filepath~;filepath/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filepath~;filepath\",\"-I\"] */
                          SELECT DISTINCT isect0.`filepath` AS src, isect0.`filepath1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filepath~\",\"filepath\"] */
                                 
                                 SELECT DISTINCT ECps0.`filepath`, ECps1.`filepath` AS `filepath1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filepath`
                                        FROM `nssharedFile`
                                        WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`filepath` <> isect0.`filepath1` AND isect0.`filepath` IS NOT NULL AND isect0.`filepath1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI filetime::File*CalendarTime' =>
        array ( 'name' => 'UNI filetime::File*CalendarTime'
              , 'ruleAdl' => 'filetime~;filetime |- I'
              , 'origin' => 'line 143, file "rap.adl"'
              , 'meaning' => 'filetime[File\\*CalendarTime] is univalent'
              , 'message' => 'filetime[File\\*CalendarTime] is niet univalent'
              , 'srcConcept' => 'CalendarTime'
              , 'tgtConcept' => 'CalendarTime'
              // Normalized complement (== violationsSQL): filetime~;filetime/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"filetime~;filetime\",\"-I\"] */
                          SELECT DISTINCT isect0.`filetime` AS src, isect0.`filetime1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"filetime~\",\"filetime\"] */
                                 
                                 SELECT DISTINCT ECps0.`filetime`, ECps1.`filetime` AS `filetime1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `File`, `filetime`
                                        FROM `nssharedFile`
                                        WHERE `File` IS NOT NULL AND `filetime` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`filetime` <> isect0.`filetime1` AND isect0.`filetime` IS NOT NULL AND isect0.`filetime1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI userrole::User*Role' =>
        array ( 'name' => 'UNI userrole::User*Role'
              , 'ruleAdl' => 'userrole~;userrole |- I'
              , 'origin' => 'line 148, file "rap.adl"'
              , 'meaning' => 'userrole[User\\*Role] is univalent'
              , 'message' => 'userrole[User\\*Role] is niet univalent'
              , 'srcConcept' => 'Role'
              , 'tgtConcept' => 'Role'
              // Normalized complement (== violationsSQL): userrole~;userrole/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"userrole~;userrole\",\"-I\"] */
                          SELECT DISTINCT isect0.`userrole` AS src, isect0.`userrole1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"userrole~\",\"userrole\"] */
                                 
                                 SELECT DISTINCT ECps0.`userrole`, ECps1.`userrole` AS `userrole1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `User`, `userrole`
                                        FROM `nssharedUser`
                                        WHERE `User` IS NOT NULL AND `userrole` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedUser` AS ECps1
                                 WHERE ECps0.`User`=ECps1.`User`
                               ) AS isect0
                          WHERE isect0.`userrole` <> isect0.`userrole1` AND isect0.`userrole` IS NOT NULL AND isect0.`userrole1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI sourcefile::Context*AdlFile' =>
        array ( 'name' => 'UNI sourcefile::Context*AdlFile'
              , 'ruleAdl' => 'sourcefile~;sourcefile |- I'
              , 'origin' => 'line 155, file "rap.adl"'
              , 'meaning' => 'sourcefile[Context\\*AdlFile] is univalent'
              , 'message' => 'sourcefile[Context\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalized complement (== violationsSQL): sourcefile~;sourcefile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"sourcefile~;sourcefile\",\"-I\"] */
                          SELECT DISTINCT isect0.`sourcefile` AS src, isect0.`sourcefile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"sourcefile~\",\"sourcefile\"] */
                                 
                                 SELECT DISTINCT ECps0.`sourcefile`, ECps1.`sourcefile` AS `sourcefile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `sourcefile`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`sourcefile` <> isect0.`sourcefile1` AND isect0.`sourcefile` IS NOT NULL AND isect0.`sourcefile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT sourcefile::Context*AdlFile' =>
        array ( 'name' => 'TOT sourcefile::Context*AdlFile'
              , 'ruleAdl' => 'I |- sourcefile;sourcefile~'
              , 'origin' => 'line 155, file "rap.adl"'
              , 'meaning' => 'sourcefile[Context\\*AdlFile] is totaal'
              , 'message' => 'sourcefile[Context\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalized complement (== violationsSQL): I/\\-(sourcefile;sourcefile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(sourcefile;sourcefile~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"sourcefile\",\"sourcefile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `sourcefile`
                                                    FROM `nssharedConid`
                                                    WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`sourcefile`=ECps1.`sourcefile`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI applyto::G*AdlFile' =>
        array ( 'name' => 'UNI applyto::G*AdlFile'
              , 'ruleAdl' => 'applyto~;applyto |- I'
              , 'origin' => 'line 160, file "rap.adl"'
              , 'meaning' => 'applyto[G\\*AdlFile] is univalent'
              , 'message' => 'applyto[G\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalized complement (== violationsSQL): applyto~;applyto/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"applyto~;applyto\",\"-I\"] */
                          SELECT DISTINCT isect0.`applyto` AS src, isect0.`applyto1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto~\",\"applyto\"] */
                                 
                                 SELECT DISTINCT ECps0.`applyto`, ECps1.`applyto` AS `applyto1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `G`, `applyto`
                                        FROM `nssharedG`
                                        WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedG` AS ECps1
                                 WHERE ECps0.`G`=ECps1.`G`
                               ) AS isect0
                          WHERE isect0.`applyto` <> isect0.`applyto1` AND isect0.`applyto` IS NOT NULL AND isect0.`applyto1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT applyto::G*AdlFile' =>
        array ( 'name' => 'TOT applyto::G*AdlFile'
              , 'ruleAdl' => 'I |- applyto;applyto~'
              , 'origin' => 'line 160, file "rap.adl"'
              , 'meaning' => 'applyto[G\\*AdlFile] is totaal'
              , 'message' => 'applyto[G\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'G'
              , 'tgtConcept' => 'G'
              // Normalized complement (== violationsSQL): I/\\-(applyto;applyto~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(applyto;applyto~)\"] */
                          SELECT DISTINCT isect0.`G` AS src, isect0.`G` AS tgt
                          FROM `nssharedG` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"applyto\",\"applyto~\"] */
                                             
                                             SELECT DISTINCT ECps0.`G`, ECps1.`G` AS `G1`
                                             FROM `nssharedG` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `G`, `applyto`
                                                    FROM `nssharedG`
                                                    WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`applyto`=ECps1.`applyto`
                                           ) AS cp
                                      WHERE isect0.`G`=cp.`G` AND isect0.`G`=cp.`G1`) AND isect0.`G` IS NOT NULL AND isect0.`G` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI functionname::G*String' =>
        array ( 'name' => 'UNI functionname::G*String'
              , 'ruleAdl' => 'functionname~;functionname |- I'
              , 'origin' => 'line 162, file "rap.adl"'
              , 'meaning' => 'functionname[G\\*String] is univalent'
              , 'message' => 'functionname[G\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): functionname~;functionname/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"functionname~;functionname\",\"-I\"] */
                          SELECT DISTINCT isect0.`functionname` AS src, isect0.`functionname1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"functionname~\",\"functionname\"] */
                                 
                                 SELECT DISTINCT ECps0.`functionname`, ECps1.`functionname` AS `functionname1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `G`, `functionname`
                                        FROM `nssharedG`
                                        WHERE `G` IS NOT NULL AND `functionname` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedG` AS ECps1
                                 WHERE ECps0.`G`=ECps1.`G`
                               ) AS isect0
                          WHERE isect0.`functionname` <> isect0.`functionname1` AND isect0.`functionname` IS NOT NULL AND isect0.`functionname1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT functionname::G*String' =>
        array ( 'name' => 'TOT functionname::G*String'
              , 'ruleAdl' => 'I |- functionname;functionname~'
              , 'origin' => 'line 162, file "rap.adl"'
              , 'meaning' => 'functionname[G\\*String] is totaal'
              , 'message' => 'functionname[G\\*String] is niet totaal'
              , 'srcConcept' => 'G'
              , 'tgtConcept' => 'G'
              // Normalized complement (== violationsSQL): I/\\-(functionname;functionname~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(functionname;functionname~)\"] */
                          SELECT DISTINCT isect0.`G` AS src, isect0.`G` AS tgt
                          FROM `nssharedG` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"functionname\",\"functionname~\"] */
                                             
                                             SELECT DISTINCT ECps0.`G`, ECps1.`G` AS `G1`
                                             FROM `nssharedG` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `G`, `functionname`
                                                    FROM `nssharedG`
                                                    WHERE `G` IS NOT NULL AND `functionname` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`functionname`=ECps1.`functionname`
                                           ) AS cp
                                      WHERE isect0.`G`=cp.`G` AND isect0.`G`=cp.`G1`) AND isect0.`G` IS NOT NULL AND isect0.`G` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI operation::G*Int' =>
        array ( 'name' => 'UNI operation::G*Int'
              , 'ruleAdl' => 'operation~;operation |- I'
              , 'origin' => 'line 164, file "rap.adl"'
              , 'meaning' => 'operation[G\\*Int] is univalent'
              , 'message' => 'operation[G\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalized complement (== violationsSQL): operation~;operation/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"operation~;operation\",\"-I\"] */
                          SELECT DISTINCT isect0.`operation` AS src, isect0.`operation1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"operation~\",\"operation\"] */
                                 
                                 SELECT DISTINCT ECps0.`operation`, ECps1.`operation` AS `operation1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `G`, `operation`
                                        FROM `nssharedG`
                                        WHERE `G` IS NOT NULL AND `operation` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedG` AS ECps1
                                 WHERE ECps0.`G`=ECps1.`G`
                               ) AS isect0
                          WHERE isect0.`operation` <> isect0.`operation1` AND isect0.`operation` IS NOT NULL AND isect0.`operation1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT operation::G*Int' =>
        array ( 'name' => 'TOT operation::G*Int'
              , 'ruleAdl' => 'I |- operation;operation~'
              , 'origin' => 'line 164, file "rap.adl"'
              , 'meaning' => 'operation[G\\*Int] is totaal'
              , 'message' => 'operation[G\\*Int] is niet totaal'
              , 'srcConcept' => 'G'
              , 'tgtConcept' => 'G'
              // Normalized complement (== violationsSQL): I/\\-(operation;operation~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(operation;operation~)\"] */
                          SELECT DISTINCT isect0.`G` AS src, isect0.`G` AS tgt
                          FROM `nssharedG` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"operation\",\"operation~\"] */
                                             
                                             SELECT DISTINCT ECps0.`G`, ECps1.`G` AS `G1`
                                             FROM `nssharedG` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `G`, `operation`
                                                    FROM `nssharedG`
                                                    WHERE `G` IS NOT NULL AND `operation` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`operation`=ECps1.`operation`
                                           ) AS cp
                                      WHERE isect0.`G`=cp.`G` AND isect0.`G`=cp.`G1`) AND isect0.`G` IS NOT NULL AND isect0.`G` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI newfile::User*NewAdlFile' =>
        array ( 'name' => 'UNI newfile::User*NewAdlFile'
              , 'ruleAdl' => 'newfile~;newfile |- I'
              , 'origin' => 'line 174, file "rap.adl"'
              , 'meaning' => 'newfile[User\\*NewAdlFile] is univalent'
              , 'message' => 'newfile[User\\*NewAdlFile] is niet univalent'
              , 'srcConcept' => 'NewAdlFile'
              , 'tgtConcept' => 'NewAdlFile'
              // Normalized complement (== violationsSQL): newfile~;newfile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"newfile~;newfile\",\"-I\"] */
                          SELECT DISTINCT isect0.`newfile` AS src, isect0.`newfile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"newfile~\",\"newfile\"] */
                                 
                                 SELECT DISTINCT ECps0.`newfile`, ECps1.`newfile` AS `newfile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `User`, `newfile`
                                        FROM `nssharedUser`
                                        WHERE `User` IS NOT NULL AND `newfile` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedUser` AS ECps1
                                 WHERE ECps0.`User`=ECps1.`User`
                               ) AS isect0
                          WHERE isect0.`newfile` <> isect0.`newfile1` AND isect0.`newfile` IS NOT NULL AND isect0.`newfile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT newfile::User*NewAdlFile' =>
        array ( 'name' => 'TOT newfile::User*NewAdlFile'
              , 'ruleAdl' => 'I |- newfile;newfile~'
              , 'origin' => 'line 174, file "rap.adl"'
              , 'meaning' => 'newfile[User\\*NewAdlFile] is totaal'
              , 'message' => 'newfile[User\\*NewAdlFile] is niet totaal'
              , 'srcConcept' => 'User'
              , 'tgtConcept' => 'User'
              // Normalized complement (== violationsSQL): I/\\-(newfile;newfile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(newfile;newfile~)\"] */
                          SELECT DISTINCT isect0.`User` AS src, isect0.`User` AS tgt
                          FROM `nssharedUser` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"newfile\",\"newfile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`User`, ECps1.`User` AS `User1`
                                             FROM `nssharedUser` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `User`, `newfile`
                                                    FROM `nssharedUser`
                                                    WHERE `User` IS NOT NULL AND `newfile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`newfile`=ECps1.`newfile`
                                           ) AS cp
                                      WHERE isect0.`User`=cp.`User` AND isect0.`User`=cp.`User1`) AND isect0.`User` IS NOT NULL AND isect0.`User` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI savepopulation::Context*SavePopFile' =>
        array ( 'name' => 'UNI savepopulation::Context*SavePopFile'
              , 'ruleAdl' => 'savepopulation~;savepopulation |- I'
              , 'origin' => 'line 180, file "rap.adl"'
              , 'meaning' => 'savepopulation[Context\\*SavePopFile] is univalent'
              , 'message' => 'savepopulation[Context\\*SavePopFile] is niet univalent'
              , 'srcConcept' => 'SavePopFile'
              , 'tgtConcept' => 'SavePopFile'
              // Normalized complement (== violationsSQL): savepopulation~;savepopulation/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"savepopulation~;savepopulation\",\"-I\"] */
                          SELECT DISTINCT isect0.`savepopulation` AS src, isect0.`savepopulation1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"savepopulation~\",\"savepopulation\"] */
                                 
                                 SELECT DISTINCT ECps0.`savepopulation`, ECps1.`savepopulation` AS `savepopulation1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `savepopulation`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `savepopulation` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`savepopulation` <> isect0.`savepopulation1` AND isect0.`savepopulation` IS NOT NULL AND isect0.`savepopulation1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT savepopulation::Context*SavePopFile' =>
        array ( 'name' => 'TOT savepopulation::Context*SavePopFile'
              , 'ruleAdl' => 'I |- savepopulation;savepopulation~'
              , 'origin' => 'line 180, file "rap.adl"'
              , 'meaning' => 'savepopulation[Context\\*SavePopFile] is totaal'
              , 'message' => 'savepopulation[Context\\*SavePopFile] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalized complement (== violationsSQL): I/\\-(savepopulation;savepopulation~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(savepopulation;savepopulation~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"savepopulation\",\"savepopulation~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `savepopulation`
                                                    FROM `nssharedConid`
                                                    WHERE `ctxnm` IS NOT NULL AND `savepopulation` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`savepopulation`=ECps1.`savepopulation`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI savecontext::Context*SaveAdlFile' =>
        array ( 'name' => 'UNI savecontext::Context*SaveAdlFile'
              , 'ruleAdl' => 'savecontext~;savecontext |- I'
              , 'origin' => 'line 187, file "rap.adl"'
              , 'meaning' => 'savecontext[Context\\*SaveAdlFile] is univalent'
              , 'message' => 'savecontext[Context\\*SaveAdlFile] is niet univalent'
              , 'srcConcept' => 'SaveAdlFile'
              , 'tgtConcept' => 'SaveAdlFile'
              // Normalized complement (== violationsSQL): savecontext~;savecontext/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"savecontext~;savecontext\",\"-I\"] */
                          SELECT DISTINCT isect0.`savecontext` AS src, isect0.`savecontext1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"savecontext~\",\"savecontext\"] */
                                 
                                 SELECT DISTINCT ECps0.`savecontext`, ECps1.`savecontext` AS `savecontext1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `savecontext`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `savecontext` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`savecontext` <> isect0.`savecontext1` AND isect0.`savecontext` IS NOT NULL AND isect0.`savecontext1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT savecontext::Context*SaveAdlFile' =>
        array ( 'name' => 'TOT savecontext::Context*SaveAdlFile'
              , 'ruleAdl' => 'I |- savecontext;savecontext~'
              , 'origin' => 'line 187, file "rap.adl"'
              , 'meaning' => 'savecontext[Context\\*SaveAdlFile] is totaal'
              , 'message' => 'savecontext[Context\\*SaveAdlFile] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalized complement (== violationsSQL): I/\\-(savecontext;savecontext~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(savecontext;savecontext~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"savecontext\",\"savecontext~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `savecontext`
                                                    FROM `nssharedConid`
                                                    WHERE `ctxnm` IS NOT NULL AND `savecontext` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`savecontext`=ECps1.`savecontext`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI AdlFile::AdlFile*File' =>
        array ( 'name' => 'UNI AdlFile::AdlFile*File'
              , 'ruleAdl' => 'AdlFile~;AdlFile |- I'
              , 'origin' => 'line 153, file "rap.adl"'
              , 'meaning' => 'AdlFile[AdlFile\\*File] is univalent'
              , 'message' => 'AdlFile[AdlFile\\*File] is niet univalent'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalized complement (== violationsSQL): AdlFile~;AdlFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"AdlFile~;AdlFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"AdlFile~\",\"AdlFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AdlFile`, `File`
                                        FROM `nssharedFile`
                                        WHERE `AdlFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`File` <> isect0.`File1` AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT AdlFile::AdlFile*File' =>
        array ( 'name' => 'TOT AdlFile::AdlFile*File'
              , 'ruleAdl' => 'I |- AdlFile;AdlFile~'
              , 'origin' => 'line 153, file "rap.adl"'
              , 'meaning' => 'AdlFile[AdlFile\\*File] is totaal'
              , 'message' => 'AdlFile[AdlFile\\*File] is niet totaal'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalized complement (== violationsSQL): I/\\-(AdlFile;AdlFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(AdlFile;AdlFile~)\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile` AS tgt
                          FROM `nssharedFile` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"AdlFile\",\"AdlFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                             FROM `nssharedFile` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `AdlFile`, `File`
                                                    FROM `nssharedFile`
                                                    WHERE `AdlFile` IS NOT NULL AND `File` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`File`=ECps1.`File`
                                           ) AS cp
                                      WHERE isect0.`AdlFile`=cp.`AdlFile` AND isect0.`AdlFile`=cp.`AdlFile1`) AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ AdlFile::AdlFile*File' =>
        array ( 'name' => 'INJ AdlFile::AdlFile*File'
              , 'ruleAdl' => 'AdlFile;AdlFile~ |- I'
              , 'origin' => 'line 153, file "rap.adl"'
              , 'meaning' => 'AdlFile[AdlFile\\*File] is injectief'
              , 'message' => 'AdlFile[AdlFile\\*File] is niet injectief'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalized complement (== violationsSQL): AdlFile;AdlFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"AdlFile;AdlFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"AdlFile\",\"AdlFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                 FROM `nssharedFile` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AdlFile`, `File`
                                        FROM `nssharedFile`
                                        WHERE `AdlFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`AdlFile` <> isect0.`AdlFile1` AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI NewAdlFile::NewAdlFile*AdlFile' =>
        array ( 'name' => 'UNI NewAdlFile::NewAdlFile*AdlFile'
              , 'ruleAdl' => 'NewAdlFile~;NewAdlFile |- I'
              , 'origin' => 'line 172, file "rap.adl"'
              , 'meaning' => 'NewAdlFile[NewAdlFile\\*AdlFile] is univalent'
              , 'message' => 'NewAdlFile[NewAdlFile\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalized complement (== violationsSQL): NewAdlFile~;NewAdlFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"NewAdlFile~;NewAdlFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"NewAdlFile~\",\"NewAdlFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `NewAdlFile`, `AdlFile`
                                        FROM `nssharedFile`
                                        WHERE `NewAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`NewAdlFile`=ECps1.`NewAdlFile`
                               ) AS isect0
                          WHERE isect0.`AdlFile` <> isect0.`AdlFile1` AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT NewAdlFile::NewAdlFile*AdlFile' =>
        array ( 'name' => 'TOT NewAdlFile::NewAdlFile*AdlFile'
              , 'ruleAdl' => 'I |- NewAdlFile;NewAdlFile~'
              , 'origin' => 'line 172, file "rap.adl"'
              , 'meaning' => 'NewAdlFile[NewAdlFile\\*AdlFile] is totaal'
              , 'message' => 'NewAdlFile[NewAdlFile\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'NewAdlFile'
              , 'tgtConcept' => 'NewAdlFile'
              // Normalized complement (== violationsSQL): I/\\-(NewAdlFile;NewAdlFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(NewAdlFile;NewAdlFile~)\"] */
                          SELECT DISTINCT isect0.`NewAdlFile` AS src, isect0.`NewAdlFile` AS tgt
                          FROM `nssharedFile` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"NewAdlFile\",\"NewAdlFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`NewAdlFile`, ECps1.`NewAdlFile` AS `NewAdlFile1`
                                             FROM `nssharedFile` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `NewAdlFile`, `AdlFile`
                                                    FROM `nssharedFile`
                                                    WHERE `NewAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                                           ) AS cp
                                      WHERE isect0.`NewAdlFile`=cp.`NewAdlFile` AND isect0.`NewAdlFile`=cp.`NewAdlFile1`) AND isect0.`NewAdlFile` IS NOT NULL AND isect0.`NewAdlFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ NewAdlFile::NewAdlFile*AdlFile' =>
        array ( 'name' => 'INJ NewAdlFile::NewAdlFile*AdlFile'
              , 'ruleAdl' => 'NewAdlFile;NewAdlFile~ |- I'
              , 'origin' => 'line 172, file "rap.adl"'
              , 'meaning' => 'NewAdlFile[NewAdlFile\\*AdlFile] is injectief'
              , 'message' => 'NewAdlFile[NewAdlFile\\*AdlFile] is niet injectief'
              , 'srcConcept' => 'NewAdlFile'
              , 'tgtConcept' => 'NewAdlFile'
              // Normalized complement (== violationsSQL): NewAdlFile;NewAdlFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"NewAdlFile;NewAdlFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`NewAdlFile` AS src, isect0.`NewAdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"NewAdlFile\",\"NewAdlFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`NewAdlFile`, ECps1.`NewAdlFile` AS `NewAdlFile1`
                                 FROM `nssharedFile` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `NewAdlFile`, `AdlFile`
                                        FROM `nssharedFile`
                                        WHERE `NewAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`NewAdlFile` <> isect0.`NewAdlFile1` AND isect0.`NewAdlFile` IS NOT NULL AND isect0.`NewAdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI SavePopFile::SavePopFile*File' =>
        array ( 'name' => 'UNI SavePopFile::SavePopFile*File'
              , 'ruleAdl' => 'SavePopFile~;SavePopFile |- I'
              , 'origin' => 'line 177, file "rap.adl"'
              , 'meaning' => 'SavePopFile[SavePopFile\\*File] is univalent'
              , 'message' => 'SavePopFile[SavePopFile\\*File] is niet univalent'
              , 'srcConcept' => 'File'
              , 'tgtConcept' => 'File'
              // Normalized complement (== violationsSQL): SavePopFile~;SavePopFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SavePopFile~;SavePopFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`File` AS src, isect0.`File1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SavePopFile~\",\"SavePopFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`File`, ECps1.`File` AS `File1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SavePopFile`, `File`
                                        FROM `nssharedFile`
                                        WHERE `SavePopFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`SavePopFile`=ECps1.`SavePopFile`
                               ) AS isect0
                          WHERE isect0.`File` <> isect0.`File1` AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT SavePopFile::SavePopFile*File' =>
        array ( 'name' => 'TOT SavePopFile::SavePopFile*File'
              , 'ruleAdl' => 'I |- SavePopFile;SavePopFile~'
              , 'origin' => 'line 177, file "rap.adl"'
              , 'meaning' => 'SavePopFile[SavePopFile\\*File] is totaal'
              , 'message' => 'SavePopFile[SavePopFile\\*File] is niet totaal'
              , 'srcConcept' => 'SavePopFile'
              , 'tgtConcept' => 'SavePopFile'
              // Normalized complement (== violationsSQL): I/\\-(SavePopFile;SavePopFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(SavePopFile;SavePopFile~)\"] */
                          SELECT DISTINCT isect0.`SavePopFile` AS src, isect0.`SavePopFile` AS tgt
                          FROM `nssharedFile` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"SavePopFile\",\"SavePopFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SavePopFile`, ECps1.`SavePopFile` AS `SavePopFile1`
                                             FROM `nssharedFile` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SavePopFile`, `File`
                                                    FROM `nssharedFile`
                                                    WHERE `SavePopFile` IS NOT NULL AND `File` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`File`=ECps1.`File`
                                           ) AS cp
                                      WHERE isect0.`SavePopFile`=cp.`SavePopFile` AND isect0.`SavePopFile`=cp.`SavePopFile1`) AND isect0.`SavePopFile` IS NOT NULL AND isect0.`SavePopFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ SavePopFile::SavePopFile*File' =>
        array ( 'name' => 'INJ SavePopFile::SavePopFile*File'
              , 'ruleAdl' => 'SavePopFile;SavePopFile~ |- I'
              , 'origin' => 'line 177, file "rap.adl"'
              , 'meaning' => 'SavePopFile[SavePopFile\\*File] is injectief'
              , 'message' => 'SavePopFile[SavePopFile\\*File] is niet injectief'
              , 'srcConcept' => 'SavePopFile'
              , 'tgtConcept' => 'SavePopFile'
              // Normalized complement (== violationsSQL): SavePopFile;SavePopFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SavePopFile;SavePopFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`SavePopFile` AS src, isect0.`SavePopFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SavePopFile\",\"SavePopFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SavePopFile`, ECps1.`SavePopFile` AS `SavePopFile1`
                                 FROM `nssharedFile` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SavePopFile`, `File`
                                        FROM `nssharedFile`
                                        WHERE `SavePopFile` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`File`=ECps1.`File`
                               ) AS isect0
                          WHERE isect0.`SavePopFile` <> isect0.`SavePopFile1` AND isect0.`SavePopFile` IS NOT NULL AND isect0.`SavePopFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI SaveAdlFile::SaveAdlFile*AdlFile' =>
        array ( 'name' => 'UNI SaveAdlFile::SaveAdlFile*AdlFile'
              , 'ruleAdl' => 'SaveAdlFile~;SaveAdlFile |- I'
              , 'origin' => 'line 183, file "rap.adl"'
              , 'meaning' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is univalent'
              , 'message' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is niet univalent'
              , 'srcConcept' => 'AdlFile'
              , 'tgtConcept' => 'AdlFile'
              // Normalized complement (== violationsSQL): SaveAdlFile~;SaveAdlFile/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SaveAdlFile~;SaveAdlFile\",\"-I\"] */
                          SELECT DISTINCT isect0.`AdlFile` AS src, isect0.`AdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SaveAdlFile~\",\"SaveAdlFile\"] */
                                 
                                 SELECT DISTINCT ECps0.`AdlFile`, ECps1.`AdlFile` AS `AdlFile1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SaveAdlFile`, `AdlFile`
                                        FROM `nssharedFile`
                                        WHERE `SaveAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`SaveAdlFile`=ECps1.`SaveAdlFile`
                               ) AS isect0
                          WHERE isect0.`AdlFile` <> isect0.`AdlFile1` AND isect0.`AdlFile` IS NOT NULL AND isect0.`AdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT SaveAdlFile::SaveAdlFile*AdlFile' =>
        array ( 'name' => 'TOT SaveAdlFile::SaveAdlFile*AdlFile'
              , 'ruleAdl' => 'I |- SaveAdlFile;SaveAdlFile~'
              , 'origin' => 'line 183, file "rap.adl"'
              , 'meaning' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is totaal'
              , 'message' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is niet totaal'
              , 'srcConcept' => 'SaveAdlFile'
              , 'tgtConcept' => 'SaveAdlFile'
              // Normalized complement (== violationsSQL): I/\\-(SaveAdlFile;SaveAdlFile~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(SaveAdlFile;SaveAdlFile~)\"] */
                          SELECT DISTINCT isect0.`SaveAdlFile` AS src, isect0.`SaveAdlFile` AS tgt
                          FROM `nssharedFile` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"SaveAdlFile\",\"SaveAdlFile~\"] */
                                             
                                             SELECT DISTINCT ECps0.`SaveAdlFile`, ECps1.`SaveAdlFile` AS `SaveAdlFile1`
                                             FROM `nssharedFile` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `SaveAdlFile`, `AdlFile`
                                                    FROM `nssharedFile`
                                                    WHERE `SaveAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                                           ) AS cp
                                      WHERE isect0.`SaveAdlFile`=cp.`SaveAdlFile` AND isect0.`SaveAdlFile`=cp.`SaveAdlFile1`) AND isect0.`SaveAdlFile` IS NOT NULL AND isect0.`SaveAdlFile` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ SaveAdlFile::SaveAdlFile*AdlFile' =>
        array ( 'name' => 'INJ SaveAdlFile::SaveAdlFile*AdlFile'
              , 'ruleAdl' => 'SaveAdlFile;SaveAdlFile~ |- I'
              , 'origin' => 'line 183, file "rap.adl"'
              , 'meaning' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is injectief'
              , 'message' => 'SaveAdlFile[SaveAdlFile\\*AdlFile] is niet injectief'
              , 'srcConcept' => 'SaveAdlFile'
              , 'tgtConcept' => 'SaveAdlFile'
              // Normalized complement (== violationsSQL): SaveAdlFile;SaveAdlFile~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"SaveAdlFile;SaveAdlFile~\",\"-I\"] */
                          SELECT DISTINCT isect0.`SaveAdlFile` AS src, isect0.`SaveAdlFile1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"SaveAdlFile\",\"SaveAdlFile~\"] */
                                 
                                 SELECT DISTINCT ECps0.`SaveAdlFile`, ECps1.`SaveAdlFile` AS `SaveAdlFile1`
                                 FROM `nssharedFile` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `SaveAdlFile`, `AdlFile`
                                        FROM `nssharedFile`
                                        WHERE `SaveAdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`AdlFile`=ECps1.`AdlFile`
                               ) AS isect0
                          WHERE isect0.`SaveAdlFile` <> isect0.`SaveAdlFile1` AND isect0.`SaveAdlFile` IS NOT NULL AND isect0.`SaveAdlFile1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI countrules::Context*Int' =>
        array ( 'name' => 'UNI countrules::Context*Int'
              , 'ruleAdl' => 'countrules~;countrules |- I'
              , 'origin' => 'line 192, file "rap.adl"'
              , 'meaning' => 'countrules[Context\\*Int] is univalent'
              , 'message' => 'countrules[Context\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalized complement (== violationsSQL): countrules~;countrules/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"countrules~;countrules\",\"-I\"] */
                          SELECT DISTINCT isect0.`countrules` AS src, isect0.`countrules1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"countrules~\",\"countrules\"] */
                                 
                                 SELECT DISTINCT ECps0.`countrules`, ECps1.`countrules` AS `countrules1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `countrules`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `countrules` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`countrules` <> isect0.`countrules1` AND isect0.`countrules` IS NOT NULL AND isect0.`countrules1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI countdecls::Context*Int' =>
        array ( 'name' => 'UNI countdecls::Context*Int'
              , 'ruleAdl' => 'countdecls~;countdecls |- I'
              , 'origin' => 'line 194, file "rap.adl"'
              , 'meaning' => 'countdecls[Context\\*Int] is univalent'
              , 'message' => 'countdecls[Context\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalized complement (== violationsSQL): countdecls~;countdecls/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"countdecls~;countdecls\",\"-I\"] */
                          SELECT DISTINCT isect0.`countdecls` AS src, isect0.`countdecls1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"countdecls~\",\"countdecls\"] */
                                 
                                 SELECT DISTINCT ECps0.`countdecls`, ECps1.`countdecls` AS `countdecls1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `countdecls`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `countdecls` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`countdecls` <> isect0.`countdecls1` AND isect0.`countdecls` IS NOT NULL AND isect0.`countdecls1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI countcpts::Context*Int' =>
        array ( 'name' => 'UNI countcpts::Context*Int'
              , 'ruleAdl' => 'countcpts~;countcpts |- I'
              , 'origin' => 'line 196, file "rap.adl"'
              , 'meaning' => 'countcpts[Context\\*Int] is univalent'
              , 'message' => 'countcpts[Context\\*Int] is niet univalent'
              , 'srcConcept' => 'Int'
              , 'tgtConcept' => 'Int'
              // Normalized complement (== violationsSQL): countcpts~;countcpts/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"countcpts~;countcpts\",\"-I\"] */
                          SELECT DISTINCT isect0.`countcpts` AS src, isect0.`countcpts1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"countcpts~\",\"countcpts\"] */
                                 
                                 SELECT DISTINCT ECps0.`countcpts`, ECps1.`countcpts` AS `countcpts1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `countcpts`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `countcpts` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`countcpts` <> isect0.`countcpts1` AND isect0.`countcpts` IS NOT NULL AND isect0.`countcpts1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI ptpic::Pattern*Image' =>
        array ( 'name' => 'UNI ptpic::Pattern*Image'
              , 'ruleAdl' => 'ptpic~;ptpic |- I'
              , 'origin' => 'line 13, file "Fspec.adl"'
              , 'meaning' => 'ptpic[Pattern\\*Image] is univalent'
              , 'message' => 'ptpic[Pattern\\*Image] is niet univalent'
              , 'srcConcept' => 'Image'
              , 'tgtConcept' => 'Image'
              // Normalized complement (== violationsSQL): ptpic~;ptpic/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ptpic~;ptpic\",\"-I\"] */
                          SELECT DISTINCT isect0.`ptpic` AS src, isect0.`ptpic1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ptpic~\",\"ptpic\"] */
                                 
                                 SELECT DISTINCT ECps0.`ptpic`, ECps1.`ptpic` AS `ptpic1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ptnm`, `ptpic`
                                        FROM `nssharedConid`
                                        WHERE `ptnm` IS NOT NULL AND `ptpic` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ptnm`=ECps1.`ptnm`
                               ) AS isect0
                          WHERE isect0.`ptpic` <> isect0.`ptpic1` AND isect0.`ptpic` IS NOT NULL AND isect0.`ptpic1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI cptpic::Concept*Image' =>
        array ( 'name' => 'UNI cptpic::Concept*Image'
              , 'ruleAdl' => 'cptpic~;cptpic |- I'
              , 'origin' => 'line 15, file "Fspec.adl"'
              , 'meaning' => 'cptpic[Concept\\*Image] is univalent'
              , 'message' => 'cptpic[Concept\\*Image] is niet univalent'
              , 'srcConcept' => 'Image'
              , 'tgtConcept' => 'Image'
              // Normalized complement (== violationsSQL): cptpic~;cptpic/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptpic~;cptpic\",\"-I\"] */
                          SELECT DISTINCT isect0.`cptpic` AS src, isect0.`cptpic1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptpic~\",\"cptpic\"] */
                                 
                                 SELECT DISTINCT ECps0.`cptpic`, ECps1.`cptpic` AS `cptpic1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `cptpic`
                                        FROM `nssharedConid`
                                        WHERE `cptnm` IS NOT NULL AND `cptpic` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`cptnm`=ECps1.`cptnm`
                               ) AS isect0
                          WHERE isect0.`cptpic` <> isect0.`cptpic1` AND isect0.`cptpic` IS NOT NULL AND isect0.`cptpic1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI rrpic::Rule*Image' =>
        array ( 'name' => 'UNI rrpic::Rule*Image'
              , 'ruleAdl' => 'rrpic~;rrpic |- I'
              , 'origin' => 'line 17, file "Fspec.adl"'
              , 'meaning' => 'rrpic[Rule\\*Image] is univalent'
              , 'message' => 'rrpic[Rule\\*Image] is niet univalent'
              , 'srcConcept' => 'Image'
              , 'tgtConcept' => 'Image'
              // Normalized complement (== violationsSQL): rrpic~;rrpic/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrpic~;rrpic\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrpic` AS src, isect0.`rrpic1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrpic~\",\"rrpic\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrpic`, ECps1.`rrpic` AS `rrpic1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `rrpic`
                                        FROM `nssharedADLid`
                                        WHERE `rrnm` IS NOT NULL AND `rrpic` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedADLid` AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`rrpic` <> isect0.`rrpic1` AND isect0.`rrpic` IS NOT NULL AND isect0.`rrpic1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI Violation::Violation*PairID' =>
        array ( 'name' => 'UNI Violation::Violation*PairID'
              , 'ruleAdl' => 'Violation~;Violation |- I'
              , 'origin' => 'line 22, file "Fspec.adl"'
              , 'meaning' => 'Violation[Violation\\*PairID] is univalent'
              , 'message' => 'Violation[Violation\\*PairID] is niet univalent'
              , 'srcConcept' => 'PairID'
              , 'tgtConcept' => 'PairID'
              // Normalized complement (== violationsSQL): Violation~;Violation/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"Violation~;Violation\",\"-I\"] */
                          SELECT DISTINCT isect0.`PairID` AS src, isect0.`PairID1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"Violation~\",\"Violation\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Violation`, `PairID`
                                        FROM `nssharedPairID`
                                        WHERE `Violation` IS NOT NULL AND `PairID` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedPairID` AS ECps1
                                 WHERE ECps0.`Violation`=ECps1.`Violation`
                               ) AS isect0
                          WHERE isect0.`PairID` <> isect0.`PairID1` AND isect0.`PairID` IS NOT NULL AND isect0.`PairID1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT Violation::Violation*PairID' =>
        array ( 'name' => 'TOT Violation::Violation*PairID'
              , 'ruleAdl' => 'I |- Violation;Violation~'
              , 'origin' => 'line 22, file "Fspec.adl"'
              , 'meaning' => 'Violation[Violation\\*PairID] is totaal'
              , 'message' => 'Violation[Violation\\*PairID] is niet totaal'
              , 'srcConcept' => 'Violation'
              , 'tgtConcept' => 'Violation'
              // Normalized complement (== violationsSQL): I/\\-(Violation;Violation~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(Violation;Violation~)\"] */
                          SELECT DISTINCT isect0.`Violation` AS src, isect0.`Violation` AS tgt
                          FROM `nssharedPairID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"Violation\",\"Violation~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Violation`, ECps1.`Violation` AS `Violation1`
                                             FROM `nssharedPairID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Violation`, `PairID`
                                                    FROM `nssharedPairID`
                                                    WHERE `Violation` IS NOT NULL AND `PairID` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`PairID`=ECps1.`PairID`
                                           ) AS cp
                                      WHERE isect0.`Violation`=cp.`Violation` AND isect0.`Violation`=cp.`Violation1`) AND isect0.`Violation` IS NOT NULL AND isect0.`Violation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ Violation::Violation*PairID' =>
        array ( 'name' => 'INJ Violation::Violation*PairID'
              , 'ruleAdl' => 'Violation;Violation~ |- I'
              , 'origin' => 'line 22, file "Fspec.adl"'
              , 'meaning' => 'Violation[Violation\\*PairID] is injectief'
              , 'message' => 'Violation[Violation\\*PairID] is niet injectief'
              , 'srcConcept' => 'Violation'
              , 'tgtConcept' => 'Violation'
              // Normalized complement (== violationsSQL): Violation;Violation~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"Violation;Violation~\",\"-I\"] */
                          SELECT DISTINCT isect0.`Violation` AS src, isect0.`Violation1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"Violation\",\"Violation~\"] */
                                 
                                 SELECT DISTINCT ECps0.`Violation`, ECps1.`Violation` AS `Violation1`
                                 FROM `nssharedPairID` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Violation`, `PairID`
                                        FROM `nssharedPairID`
                                        WHERE `Violation` IS NOT NULL AND `PairID` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                               ) AS isect0
                          WHERE isect0.`Violation` <> isect0.`Violation1` AND isect0.`Violation` IS NOT NULL AND isect0.`Violation1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ ctxnm::Context*Conid' =>
        array ( 'name' => 'INJ ctxnm::Context*Conid'
              , 'ruleAdl' => 'ctxnm;ctxnm~ |- I'
              , 'origin' => 'line 19, file "AST.adl"'
              , 'meaning' => 'ctxnm[Context\\*Conid] is injectief'
              , 'message' => 'ctxnm[Context\\*Conid] is niet injectief'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalized complement (== violationsSQL): ctxnm;ctxnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ctxnm;ctxnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ctxnm\",\"ctxnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                 FROM `nssharedConid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `Conid`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Conid`=ECps1.`Conid`
                               ) AS isect0
                          WHERE isect0.`ctxnm` <> isect0.`ctxnm1` AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI ctxnm::Context*Conid' =>
        array ( 'name' => 'UNI ctxnm::Context*Conid'
              , 'ruleAdl' => 'ctxnm~;ctxnm |- I'
              , 'origin' => 'line 19, file "AST.adl"'
              , 'meaning' => 'ctxnm[Context\\*Conid] is univalent'
              , 'message' => 'ctxnm[Context\\*Conid] is niet univalent'
              , 'srcConcept' => 'Conid'
              , 'tgtConcept' => 'Conid'
              // Normalized complement (== violationsSQL): ctxnm~;ctxnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ctxnm~;ctxnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Conid` AS src, isect0.`Conid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ctxnm~\",\"ctxnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Conid`, ECps1.`Conid` AS `Conid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `Conid`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                               ) AS isect0
                          WHERE isect0.`Conid` <> isect0.`Conid1` AND isect0.`Conid` IS NOT NULL AND isect0.`Conid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT ctxnm::Context*Conid' =>
        array ( 'name' => 'TOT ctxnm::Context*Conid'
              , 'ruleAdl' => 'I |- ctxnm;ctxnm~'
              , 'origin' => 'line 19, file "AST.adl"'
              , 'meaning' => 'ctxnm[Context\\*Conid] is totaal'
              , 'message' => 'ctxnm[Context\\*Conid] is niet totaal'
              , 'srcConcept' => 'Context'
              , 'tgtConcept' => 'Context'
              // Normalized complement (== violationsSQL): I/\\-(ctxnm;ctxnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(ctxnm;ctxnm~)\"] */
                          SELECT DISTINCT isect0.`ctxnm` AS src, isect0.`ctxnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"ctxnm\",\"ctxnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ctxnm`, ECps1.`ctxnm` AS `ctxnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ctxnm`, `Conid`
                                                    FROM `nssharedConid`
                                                    WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Conid`=ECps1.`Conid`
                                           ) AS cp
                                      WHERE isect0.`ctxnm`=cp.`ctxnm` AND isect0.`ctxnm`=cp.`ctxnm1`) AND isect0.`ctxnm` IS NOT NULL AND isect0.`ctxnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ ptnm::Pattern*Conid' =>
        array ( 'name' => 'INJ ptnm::Pattern*Conid'
              , 'ruleAdl' => 'ptnm;ptnm~ |- I'
              , 'origin' => 'line 32, file "AST.adl"'
              , 'meaning' => 'ptnm[Pattern\\*Conid] is injectief'
              , 'message' => 'ptnm[Pattern\\*Conid] is niet injectief'
              , 'srcConcept' => 'Pattern'
              , 'tgtConcept' => 'Pattern'
              // Normalized complement (== violationsSQL): ptnm;ptnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ptnm;ptnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`ptnm` AS src, isect0.`ptnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ptnm\",\"ptnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`ptnm`, ECps1.`ptnm` AS `ptnm1`
                                 FROM `nssharedConid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ptnm`, `Conid`
                                        FROM `nssharedConid`
                                        WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Conid`=ECps1.`Conid`
                               ) AS isect0
                          WHERE isect0.`ptnm` <> isect0.`ptnm1` AND isect0.`ptnm` IS NOT NULL AND isect0.`ptnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI ptnm::Pattern*Conid' =>
        array ( 'name' => 'UNI ptnm::Pattern*Conid'
              , 'ruleAdl' => 'ptnm~;ptnm |- I'
              , 'origin' => 'line 32, file "AST.adl"'
              , 'meaning' => 'ptnm[Pattern\\*Conid] is univalent'
              , 'message' => 'ptnm[Pattern\\*Conid] is niet univalent'
              , 'srcConcept' => 'Conid'
              , 'tgtConcept' => 'Conid'
              // Normalized complement (== violationsSQL): ptnm~;ptnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ptnm~;ptnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Conid` AS src, isect0.`Conid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ptnm~\",\"ptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Conid`, ECps1.`Conid` AS `Conid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ptnm`, `Conid`
                                        FROM `nssharedConid`
                                        WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`ptnm`=ECps1.`ptnm`
                               ) AS isect0
                          WHERE isect0.`Conid` <> isect0.`Conid1` AND isect0.`Conid` IS NOT NULL AND isect0.`Conid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT ptnm::Pattern*Conid' =>
        array ( 'name' => 'TOT ptnm::Pattern*Conid'
              , 'ruleAdl' => 'I |- ptnm;ptnm~'
              , 'origin' => 'line 32, file "AST.adl"'
              , 'meaning' => 'ptnm[Pattern\\*Conid] is totaal'
              , 'message' => 'ptnm[Pattern\\*Conid] is niet totaal'
              , 'srcConcept' => 'Pattern'
              , 'tgtConcept' => 'Pattern'
              // Normalized complement (== violationsSQL): I/\\-(ptnm;ptnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(ptnm;ptnm~)\"] */
                          SELECT DISTINCT isect0.`ptnm` AS src, isect0.`ptnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"ptnm\",\"ptnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ptnm`, ECps1.`ptnm` AS `ptnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ptnm`, `Conid`
                                                    FROM `nssharedConid`
                                                    WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Conid`=ECps1.`Conid`
                                           ) AS cp
                                      WHERE isect0.`ptnm`=cp.`ptnm` AND isect0.`ptnm`=cp.`ptnm1`) AND isect0.`ptnm` IS NOT NULL AND isect0.`ptnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI gengen::Gen*Concept' =>
        array ( 'name' => 'UNI gengen::Gen*Concept'
              , 'ruleAdl' => 'gengen~;gengen |- I'
              , 'origin' => 'line 50, file "AST.adl"'
              , 'meaning' => 'gengen[Gen\\*Concept] is univalent'
              , 'message' => 'gengen[Gen\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): gengen~;gengen/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"gengen~;gengen\",\"-I\"] */
                          SELECT DISTINCT isect0.`gengen` AS src, isect0.`gengen1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"gengen~\",\"gengen\"] */
                                 
                                 SELECT DISTINCT ECps0.`gengen`, ECps1.`gengen` AS `gengen1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `gengen`
                                        FROM `nssharedGen`
                                        WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedGen` AS ECps1
                                 WHERE ECps0.`Gen`=ECps1.`Gen`
                               ) AS isect0
                          WHERE isect0.`gengen` <> isect0.`gengen1` AND isect0.`gengen` IS NOT NULL AND isect0.`gengen1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT gengen::Gen*Concept' =>
        array ( 'name' => 'TOT gengen::Gen*Concept'
              , 'ruleAdl' => 'I |- gengen;gengen~'
              , 'origin' => 'line 50, file "AST.adl"'
              , 'meaning' => 'gengen[Gen\\*Concept] is totaal'
              , 'message' => 'gengen[Gen\\*Concept] is niet totaal'
              , 'srcConcept' => 'Gen'
              , 'tgtConcept' => 'Gen'
              // Normalized complement (== violationsSQL): I/\\-(gengen;gengen~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(gengen;gengen~)\"] */
                          SELECT DISTINCT isect0.`Gen` AS src, isect0.`Gen` AS tgt
                          FROM `nssharedGen` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"gengen\",\"gengen~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                             FROM `nssharedGen` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Gen`, `gengen`
                                                    FROM `nssharedGen`
                                                    WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`gengen`=ECps1.`gengen`
                                           ) AS cp
                                      WHERE isect0.`Gen`=cp.`Gen` AND isect0.`Gen`=cp.`Gen1`) AND isect0.`Gen` IS NOT NULL AND isect0.`Gen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI genspc::Gen*Concept' =>
        array ( 'name' => 'UNI genspc::Gen*Concept'
              , 'ruleAdl' => 'genspc~;genspc |- I'
              , 'origin' => 'line 52, file "AST.adl"'
              , 'meaning' => 'genspc[Gen\\*Concept] is univalent'
              , 'message' => 'genspc[Gen\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): genspc~;genspc/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"genspc~;genspc\",\"-I\"] */
                          SELECT DISTINCT isect0.`genspc` AS src, isect0.`genspc1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"genspc~\",\"genspc\"] */
                                 
                                 SELECT DISTINCT ECps0.`genspc`, ECps1.`genspc` AS `genspc1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Gen`, `genspc`
                                        FROM `nssharedGen`
                                        WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedGen` AS ECps1
                                 WHERE ECps0.`Gen`=ECps1.`Gen`
                               ) AS isect0
                          WHERE isect0.`genspc` <> isect0.`genspc1` AND isect0.`genspc` IS NOT NULL AND isect0.`genspc1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT genspc::Gen*Concept' =>
        array ( 'name' => 'TOT genspc::Gen*Concept'
              , 'ruleAdl' => 'I |- genspc;genspc~'
              , 'origin' => 'line 52, file "AST.adl"'
              , 'meaning' => 'genspc[Gen\\*Concept] is totaal'
              , 'message' => 'genspc[Gen\\*Concept] is niet totaal'
              , 'srcConcept' => 'Gen'
              , 'tgtConcept' => 'Gen'
              // Normalized complement (== violationsSQL): I/\\-(genspc;genspc~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(genspc;genspc~)\"] */
                          SELECT DISTINCT isect0.`Gen` AS src, isect0.`Gen` AS tgt
                          FROM `nssharedGen` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"genspc\",\"genspc~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Gen`, ECps1.`Gen` AS `Gen1`
                                             FROM `nssharedGen` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Gen`, `genspc`
                                                    FROM `nssharedGen`
                                                    WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`genspc`=ECps1.`genspc`
                                           ) AS cp
                                      WHERE isect0.`Gen`=cp.`Gen` AND isect0.`Gen`=cp.`Gen1`) AND isect0.`Gen` IS NOT NULL AND isect0.`Gen` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ cptnm::Concept*Conid' =>
        array ( 'name' => 'INJ cptnm::Concept*Conid'
              , 'ruleAdl' => 'cptnm;cptnm~ |- I'
              , 'origin' => 'line 62, file "AST.adl"'
              , 'meaning' => 'cptnm[Concept\\*Conid] is injectief'
              , 'message' => 'cptnm[Concept\\*Conid] is niet injectief'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): cptnm;cptnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptnm;cptnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`cptnm` AS src, isect0.`cptnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptnm\",\"cptnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`cptnm`, ECps1.`cptnm` AS `cptnm1`
                                 FROM `nssharedConid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `Conid`
                                        FROM `nssharedConid`
                                        WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`Conid`=ECps1.`Conid`
                               ) AS isect0
                          WHERE isect0.`cptnm` <> isect0.`cptnm1` AND isect0.`cptnm` IS NOT NULL AND isect0.`cptnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI cptnm::Concept*Conid' =>
        array ( 'name' => 'UNI cptnm::Concept*Conid'
              , 'ruleAdl' => 'cptnm~;cptnm |- I'
              , 'origin' => 'line 62, file "AST.adl"'
              , 'meaning' => 'cptnm[Concept\\*Conid] is univalent'
              , 'message' => 'cptnm[Concept\\*Conid] is niet univalent'
              , 'srcConcept' => 'Conid'
              , 'tgtConcept' => 'Conid'
              // Normalized complement (== violationsSQL): cptnm~;cptnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"cptnm~;cptnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`Conid` AS src, isect0.`Conid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptnm~\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Conid`, ECps1.`Conid` AS `Conid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `Conid`
                                        FROM `nssharedConid`
                                        WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`cptnm`=ECps1.`cptnm`
                               ) AS isect0
                          WHERE isect0.`Conid` <> isect0.`Conid1` AND isect0.`Conid` IS NOT NULL AND isect0.`Conid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT cptnm::Concept*Conid' =>
        array ( 'name' => 'TOT cptnm::Concept*Conid'
              , 'ruleAdl' => 'I |- cptnm;cptnm~'
              , 'origin' => 'line 62, file "AST.adl"'
              , 'meaning' => 'cptnm[Concept\\*Conid] is totaal'
              , 'message' => 'cptnm[Concept\\*Conid] is niet totaal'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): I/\\-(cptnm;cptnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(cptnm;cptnm~)\"] */
                          SELECT DISTINCT isect0.`cptnm` AS src, isect0.`cptnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"cptnm\",\"cptnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`cptnm`, ECps1.`cptnm` AS `cptnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `cptnm`, `Conid`
                                                    FROM `nssharedConid`
                                                    WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Conid`=ECps1.`Conid`
                                           ) AS cp
                                      WHERE isect0.`cptnm`=cp.`cptnm` AND isect0.`cptnm`=cp.`cptnm1`) AND isect0.`cptnm` IS NOT NULL AND isect0.`cptnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ ordername::Order*String' =>
        array ( 'name' => 'INJ ordername::Order*String'
              , 'ruleAdl' => 'ordername;ordername~ |- I'
              , 'origin' => 'line 74, file "AST.adl"'
              , 'meaning' => 'ordername[Order\\*String] is injectief'
              , 'message' => 'ordername[Order\\*String] is niet injectief'
              , 'srcConcept' => 'Order'
              , 'tgtConcept' => 'Order'
              // Normalized complement (== violationsSQL): ordername;ordername~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ordername;ordername~\",\"-I\"] */
                          SELECT DISTINCT isect0.`ordername` AS src, isect0.`ordername1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ordername\",\"ordername~\"] */
                                 
                                 SELECT DISTINCT ECps0.`ordername`, ECps1.`ordername` AS `ordername1`
                                 FROM `nssharedString` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ordername`, `String`
                                        FROM `nssharedString`
                                        WHERE `ordername` IS NOT NULL AND `String` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`String`=ECps1.`String`
                               ) AS isect0
                          WHERE isect0.`ordername` <> isect0.`ordername1` AND isect0.`ordername` IS NOT NULL AND isect0.`ordername1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI ordername::Order*String' =>
        array ( 'name' => 'UNI ordername::Order*String'
              , 'ruleAdl' => 'ordername~;ordername |- I'
              , 'origin' => 'line 74, file "AST.adl"'
              , 'meaning' => 'ordername[Order\\*String] is univalent'
              , 'message' => 'ordername[Order\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): ordername~;ordername/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"ordername~;ordername\",\"-I\"] */
                          SELECT DISTINCT isect0.`String` AS src, isect0.`String1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"ordername~\",\"ordername\"] */
                                 
                                 SELECT DISTINCT ECps0.`String`, ECps1.`String` AS `String1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ordername`, `String`
                                        FROM `nssharedString`
                                        WHERE `ordername` IS NOT NULL AND `String` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedString` AS ECps1
                                 WHERE ECps0.`ordername`=ECps1.`ordername`
                               ) AS isect0
                          WHERE isect0.`String` <> isect0.`String1` AND isect0.`String` IS NOT NULL AND isect0.`String1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT ordername::Order*String' =>
        array ( 'name' => 'TOT ordername::Order*String'
              , 'ruleAdl' => 'I |- ordername;ordername~'
              , 'origin' => 'line 74, file "AST.adl"'
              , 'meaning' => 'ordername[Order\\*String] is totaal'
              , 'message' => 'ordername[Order\\*String] is niet totaal'
              , 'srcConcept' => 'Order'
              , 'tgtConcept' => 'Order'
              // Normalized complement (== violationsSQL): I/\\-(ordername;ordername~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(ordername;ordername~)\"] */
                          SELECT DISTINCT isect0.`ordername` AS src, isect0.`ordername` AS tgt
                          FROM `nssharedString` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"ordername\",\"ordername~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ordername`, ECps1.`ordername` AS `ordername1`
                                             FROM `nssharedString` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ordername`, `String`
                                                    FROM `nssharedString`
                                                    WHERE `ordername` IS NOT NULL AND `String` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`String`=ECps1.`String`
                                           ) AS cp
                                      WHERE isect0.`ordername`=cp.`ordername` AND isect0.`ordername`=cp.`ordername1`) AND isect0.`ordername` IS NOT NULL AND isect0.`ordername` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI order::Concept*Order' =>
        array ( 'name' => 'UNI order::Concept*Order'
              , 'ruleAdl' => 'order~;order |- I'
              , 'origin' => 'line 76, file "AST.adl"'
              , 'meaning' => 'order[Concept\\*Order] is univalent'
              , 'message' => 'order[Concept\\*Order] is niet univalent'
              , 'srcConcept' => 'Order'
              , 'tgtConcept' => 'Order'
              // Normalized complement (== violationsSQL): order~;order/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"order~;order\",\"-I\"] */
                          SELECT DISTINCT isect0.`order` AS src, isect0.`order1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"order~\",\"order\"] */
                                 
                                 SELECT DISTINCT ECps0.`order`, ECps1.`order` AS `order1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `cptnm`, `order`
                                        FROM `nssharedConid`
                                        WHERE `cptnm` IS NOT NULL AND `order` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`cptnm`=ECps1.`cptnm`
                               ) AS isect0
                          WHERE isect0.`order` <> isect0.`order1` AND isect0.`order` IS NOT NULL AND isect0.`order1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT order::Concept*Order' =>
        array ( 'name' => 'TOT order::Concept*Order'
              , 'ruleAdl' => 'I |- order;order~'
              , 'origin' => 'line 76, file "AST.adl"'
              , 'meaning' => 'order[Concept\\*Order] is totaal'
              , 'message' => 'order[Concept\\*Order] is niet totaal'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): I/\\-(order;order~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(order;order~)\"] */
                          SELECT DISTINCT isect0.`cptnm` AS src, isect0.`cptnm` AS tgt
                          FROM `nssharedConid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"order\",\"order~\"] */
                                             
                                             SELECT DISTINCT ECps0.`cptnm`, ECps1.`cptnm` AS `cptnm1`
                                             FROM `nssharedConid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `cptnm`, `order`
                                                    FROM `nssharedConid`
                                                    WHERE `cptnm` IS NOT NULL AND `order` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`order`=ECps1.`order`
                                           ) AS cp
                                      WHERE isect0.`cptnm`=cp.`cptnm` AND isect0.`cptnm`=cp.`cptnm1`) AND isect0.`cptnm` IS NOT NULL AND isect0.`cptnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI atomvalue::AtomID*Atom' =>
        array ( 'name' => 'UNI atomvalue::AtomID*Atom'
              , 'ruleAdl' => 'atomvalue~;atomvalue |- I'
              , 'origin' => 'line 95, file "AST.adl"'
              , 'meaning' => 'atomvalue[AtomID\\*Atom] is univalent'
              , 'message' => 'atomvalue[AtomID\\*Atom] is niet univalent'
              , 'srcConcept' => 'Atom'
              , 'tgtConcept' => 'Atom'
              // Normalized complement (== violationsSQL): atomvalue~;atomvalue/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"atomvalue~;atomvalue\",\"-I\"] */
                          SELECT DISTINCT isect0.`atomvalue` AS src, isect0.`atomvalue1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"atomvalue~\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`atomvalue`, ECps1.`atomvalue` AS `atomvalue1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `AtomID`, `atomvalue`
                                        FROM `nssharedAtomID`
                                        WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedAtomID` AS ECps1
                                 WHERE ECps0.`AtomID`=ECps1.`AtomID`
                               ) AS isect0
                          WHERE isect0.`atomvalue` <> isect0.`atomvalue1` AND isect0.`atomvalue` IS NOT NULL AND isect0.`atomvalue1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT atomvalue::AtomID*Atom' =>
        array ( 'name' => 'TOT atomvalue::AtomID*Atom'
              , 'ruleAdl' => 'I |- atomvalue;atomvalue~'
              , 'origin' => 'line 95, file "AST.adl"'
              , 'meaning' => 'atomvalue[AtomID\\*Atom] is totaal'
              , 'message' => 'atomvalue[AtomID\\*Atom] is niet totaal'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalized complement (== violationsSQL): I/\\-(atomvalue;atomvalue~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(atomvalue;atomvalue~)\"] */
                          SELECT DISTINCT isect0.`AtomID` AS src, isect0.`AtomID` AS tgt
                          FROM `nssharedAtomID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"atomvalue\",\"atomvalue~\"] */
                                             
                                             SELECT DISTINCT ECps0.`AtomID`, ECps1.`AtomID` AS `AtomID1`
                                             FROM `nssharedAtomID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `AtomID`, `atomvalue`
                                                    FROM `nssharedAtomID`
                                                    WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`atomvalue`=ECps1.`atomvalue`
                                           ) AS cp
                                      WHERE isect0.`AtomID`=cp.`AtomID` AND isect0.`AtomID`=cp.`AtomID1`) AND isect0.`AtomID` IS NOT NULL AND isect0.`AtomID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI src::Sign*Concept' =>
        array ( 'name' => 'UNI src::Sign*Concept'
              , 'ruleAdl' => 'src~;src |- I'
              , 'origin' => 'line 108, file "AST.adl"'
              , 'meaning' => 'src[Sign\\*Concept] is univalent'
              , 'message' => 'src[Sign\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): src~;src/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"src~;src\",\"-I\"] */
                          SELECT DISTINCT isect0.`src`, isect0.`src1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"src~\",\"src\"] */
                                 
                                 SELECT DISTINCT ECps0.`src`, ECps1.`src` AS `src1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Sign`, `src`
                                        FROM `nssharedSign`
                                        WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedSign` AS ECps1
                                 WHERE ECps0.`Sign`=ECps1.`Sign`
                               ) AS isect0
                          WHERE isect0.`src` <> isect0.`src1` AND isect0.`src` IS NOT NULL AND isect0.`src1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT src::Sign*Concept' =>
        array ( 'name' => 'TOT src::Sign*Concept'
              , 'ruleAdl' => 'I |- src;src~'
              , 'origin' => 'line 108, file "AST.adl"'
              , 'meaning' => 'src[Sign\\*Concept] is totaal'
              , 'message' => 'src[Sign\\*Concept] is niet totaal'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalized complement (== violationsSQL): I/\\-(src;src~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(src;src~)\"] */
                          SELECT DISTINCT isect0.`Sign` AS src, isect0.`Sign` AS tgt
                          FROM `nssharedSign` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"src\",\"src~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Sign`, ECps1.`Sign` AS `Sign1`
                                             FROM `nssharedSign` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Sign`, `src`
                                                    FROM `nssharedSign`
                                                    WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`src`=ECps1.`src`
                                           ) AS cp
                                      WHERE isect0.`Sign`=cp.`Sign` AND isect0.`Sign`=cp.`Sign1`) AND isect0.`Sign` IS NOT NULL AND isect0.`Sign` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI trg::Sign*Concept' =>
        array ( 'name' => 'UNI trg::Sign*Concept'
              , 'ruleAdl' => 'trg~;trg |- I'
              , 'origin' => 'line 110, file "AST.adl"'
              , 'meaning' => 'trg[Sign\\*Concept] is univalent'
              , 'message' => 'trg[Sign\\*Concept] is niet univalent'
              , 'srcConcept' => 'Concept'
              , 'tgtConcept' => 'Concept'
              // Normalized complement (== violationsSQL): trg~;trg/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"trg~;trg\",\"-I\"] */
                          SELECT DISTINCT isect0.`trg` AS src, isect0.`trg1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"trg~\",\"trg\"] */
                                 
                                 SELECT DISTINCT ECps0.`trg`, ECps1.`trg` AS `trg1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Sign`, `trg`
                                        FROM `nssharedSign`
                                        WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedSign` AS ECps1
                                 WHERE ECps0.`Sign`=ECps1.`Sign`
                               ) AS isect0
                          WHERE isect0.`trg` <> isect0.`trg1` AND isect0.`trg` IS NOT NULL AND isect0.`trg1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT trg::Sign*Concept' =>
        array ( 'name' => 'TOT trg::Sign*Concept'
              , 'ruleAdl' => 'I |- trg;trg~'
              , 'origin' => 'line 110, file "AST.adl"'
              , 'meaning' => 'trg[Sign\\*Concept] is totaal'
              , 'message' => 'trg[Sign\\*Concept] is niet totaal'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalized complement (== violationsSQL): I/\\-(trg;trg~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(trg;trg~)\"] */
                          SELECT DISTINCT isect0.`Sign` AS src, isect0.`Sign` AS tgt
                          FROM `nssharedSign` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"trg\",\"trg~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Sign`, ECps1.`Sign` AS `Sign1`
                                             FROM `nssharedSign` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Sign`, `trg`
                                                    FROM `nssharedSign`
                                                    WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`trg`=ECps1.`trg`
                                           ) AS cp
                                      WHERE isect0.`Sign`=cp.`Sign` AND isect0.`Sign`=cp.`Sign1`) AND isect0.`Sign` IS NOT NULL AND isect0.`Sign` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI left::PairID*AtomID' =>
        array ( 'name' => 'UNI left::PairID*AtomID'
              , 'ruleAdl' => 'left~;left |- I'
              , 'origin' => 'line 123, file "AST.adl"'
              , 'meaning' => 'left[PairID\\*AtomID] is univalent'
              , 'message' => 'left[PairID\\*AtomID] is niet univalent'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalized complement (== violationsSQL): left~;left/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"left~;left\",\"-I\"] */
                          SELECT DISTINCT isect0.`left` AS src, isect0.`left1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"left~\",\"left\"] */
                                 
                                 SELECT DISTINCT ECps0.`left`, ECps1.`left` AS `left1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PairID`, `left`
                                        FROM `nssharedPairID`
                                        WHERE `PairID` IS NOT NULL AND `left` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedPairID` AS ECps1
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                               ) AS isect0
                          WHERE isect0.`left` <> isect0.`left1` AND isect0.`left` IS NOT NULL AND isect0.`left1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT left::PairID*AtomID' =>
        array ( 'name' => 'TOT left::PairID*AtomID'
              , 'ruleAdl' => 'I |- left;left~'
              , 'origin' => 'line 123, file "AST.adl"'
              , 'meaning' => 'left[PairID\\*AtomID] is totaal'
              , 'message' => 'left[PairID\\*AtomID] is niet totaal'
              , 'srcConcept' => 'PairID'
              , 'tgtConcept' => 'PairID'
              // Normalized complement (== violationsSQL): I/\\-(left;left~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(left;left~)\"] */
                          SELECT DISTINCT isect0.`PairID` AS src, isect0.`PairID` AS tgt
                          FROM `nssharedPairID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"left\",\"left~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                             FROM `nssharedPairID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PairID`, `left`
                                                    FROM `nssharedPairID`
                                                    WHERE `PairID` IS NOT NULL AND `left` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`left`=ECps1.`left`
                                           ) AS cp
                                      WHERE isect0.`PairID`=cp.`PairID` AND isect0.`PairID`=cp.`PairID1`) AND isect0.`PairID` IS NOT NULL AND isect0.`PairID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI right::PairID*AtomID' =>
        array ( 'name' => 'UNI right::PairID*AtomID'
              , 'ruleAdl' => 'right~;right |- I'
              , 'origin' => 'line 125, file "AST.adl"'
              , 'meaning' => 'right[PairID\\*AtomID] is univalent'
              , 'message' => 'right[PairID\\*AtomID] is niet univalent'
              , 'srcConcept' => 'AtomID'
              , 'tgtConcept' => 'AtomID'
              // Normalized complement (== violationsSQL): right~;right/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"right~;right\",\"-I\"] */
                          SELECT DISTINCT isect0.`right` AS src, isect0.`right1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"right~\",\"right\"] */
                                 
                                 SELECT DISTINCT ECps0.`right`, ECps1.`right` AS `right1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PairID`, `right`
                                        FROM `nssharedPairID`
                                        WHERE `PairID` IS NOT NULL AND `right` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedPairID` AS ECps1
                                 WHERE ECps0.`PairID`=ECps1.`PairID`
                               ) AS isect0
                          WHERE isect0.`right` <> isect0.`right1` AND isect0.`right` IS NOT NULL AND isect0.`right1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT right::PairID*AtomID' =>
        array ( 'name' => 'TOT right::PairID*AtomID'
              , 'ruleAdl' => 'I |- right;right~'
              , 'origin' => 'line 125, file "AST.adl"'
              , 'meaning' => 'right[PairID\\*AtomID] is totaal'
              , 'message' => 'right[PairID\\*AtomID] is niet totaal'
              , 'srcConcept' => 'PairID'
              , 'tgtConcept' => 'PairID'
              // Normalized complement (== violationsSQL): I/\\-(right;right~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(right;right~)\"] */
                          SELECT DISTINCT isect0.`PairID` AS src, isect0.`PairID` AS tgt
                          FROM `nssharedPairID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"right\",\"right~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PairID`, ECps1.`PairID` AS `PairID1`
                                             FROM `nssharedPairID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PairID`, `right`
                                                    FROM `nssharedPairID`
                                                    WHERE `PairID` IS NOT NULL AND `right` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`right`=ECps1.`right`
                                           ) AS cp
                                      WHERE isect0.`PairID`=cp.`PairID` AND isect0.`PairID`=cp.`PairID1`) AND isect0.`PairID` IS NOT NULL AND isect0.`PairID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI decnm::Declaration*Varid' =>
        array ( 'name' => 'UNI decnm::Declaration*Varid'
              , 'ruleAdl' => 'decnm~;decnm |- I'
              , 'origin' => 'line 136, file "AST.adl"'
              , 'meaning' => 'decnm[Declaration\\*Varid] is univalent'
              , 'message' => 'decnm[Declaration\\*Varid] is niet univalent'
              , 'srcConcept' => 'Varid'
              , 'tgtConcept' => 'Varid'
              // Normalized complement (== violationsSQL): decnm~;decnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decnm~;decnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`decnm` AS src, isect0.`decnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decnm~\",\"decnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`decnm`, ECps1.`decnm` AS `decnm1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decnm`
                                        FROM `nssharedDeclaration`
                                        WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedDeclaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decnm` <> isect0.`decnm1` AND isect0.`decnm` IS NOT NULL AND isect0.`decnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT decnm::Declaration*Varid' =>
        array ( 'name' => 'TOT decnm::Declaration*Varid'
              , 'ruleAdl' => 'I |- decnm;decnm~'
              , 'origin' => 'line 136, file "AST.adl"'
              , 'meaning' => 'decnm[Declaration\\*Varid] is totaal'
              , 'message' => 'decnm[Declaration\\*Varid] is niet totaal'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalized complement (== violationsSQL): I/\\-(decnm;decnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(decnm;decnm~)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`Declaration` AS tgt
                          FROM `nssharedDeclaration` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decnm\",\"decnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps1.`Declaration` AS `Declaration1`
                                             FROM `nssharedDeclaration` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Declaration`, `decnm`
                                                    FROM `nssharedDeclaration`
                                                    WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`decnm`=ECps1.`decnm`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`Declaration`=cp.`Declaration1`) AND isect0.`Declaration` IS NOT NULL AND isect0.`Declaration` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI decsgn::Declaration*Sign' =>
        array ( 'name' => 'UNI decsgn::Declaration*Sign'
              , 'ruleAdl' => 'decsgn~;decsgn |- I'
              , 'origin' => 'line 138, file "AST.adl"'
              , 'meaning' => 'decsgn[Declaration\\*Sign] is univalent'
              , 'message' => 'decsgn[Declaration\\*Sign] is niet univalent'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalized complement (== violationsSQL): decsgn~;decsgn/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decsgn~;decsgn\",\"-I\"] */
                          SELECT DISTINCT isect0.`decsgn` AS src, isect0.`decsgn1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn~\",\"decsgn\"] */
                                 
                                 SELECT DISTINCT ECps0.`decsgn`, ECps1.`decsgn` AS `decsgn1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decsgn`
                                        FROM `nssharedDeclaration`
                                        WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedDeclaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decsgn` <> isect0.`decsgn1` AND isect0.`decsgn` IS NOT NULL AND isect0.`decsgn1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT decsgn::Declaration*Sign' =>
        array ( 'name' => 'TOT decsgn::Declaration*Sign'
              , 'ruleAdl' => 'I |- decsgn;decsgn~'
              , 'origin' => 'line 138, file "AST.adl"'
              , 'meaning' => 'decsgn[Declaration\\*Sign] is totaal'
              , 'message' => 'decsgn[Declaration\\*Sign] is niet totaal'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalized complement (== violationsSQL): I/\\-(decsgn;decsgn~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(decsgn;decsgn~)\"] */
                          SELECT DISTINCT isect0.`Declaration` AS src, isect0.`Declaration` AS tgt
                          FROM `nssharedDeclaration` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"decsgn\",\"decsgn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Declaration`, ECps1.`Declaration` AS `Declaration1`
                                             FROM `nssharedDeclaration` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Declaration`, `decsgn`
                                                    FROM `nssharedDeclaration`
                                                    WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`decsgn`=ECps1.`decsgn`
                                           ) AS cp
                                      WHERE isect0.`Declaration`=cp.`Declaration` AND isect0.`Declaration`=cp.`Declaration1`) AND isect0.`Declaration` IS NOT NULL AND isect0.`Declaration` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ decprps::Declaration*PropertyRule' =>
        array ( 'name' => 'INJ decprps::Declaration*PropertyRule'
              , 'ruleAdl' => 'decprps;decprps~ |- I'
              , 'origin' => 'line 140, file "AST.adl"'
              , 'meaning' => 'decprps[Declaration\\*PropertyRule] is injectief'
              , 'message' => 'decprps[Declaration\\*PropertyRule] is niet injectief'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalized complement (== violationsSQL): decprps;decprps~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprps;decprps~\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprps` AS src, isect0.`decprps1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprps\",\"decprps~\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprps`, ECps1.`decprps` AS `decprps1`
                                 FROM `nssharedADLid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `decprps`, `PropertyRule`
                                        FROM `nssharedADLid`
                                        WHERE `decprps` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`
                               ) AS isect0
                          WHERE isect0.`decprps` <> isect0.`decprps1` AND isect0.`decprps` IS NOT NULL AND isect0.`decprps1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT declaredthrough::PropertyRule*Property' =>
        array ( 'name' => 'TOT declaredthrough::PropertyRule*Property'
              , 'ruleAdl' => 'I |- declaredthrough;declaredthrough~'
              , 'origin' => 'line 149, file "AST.adl"'
              , 'meaning' => 'declaredthrough[PropertyRule\\*Property] is totaal'
              , 'message' => 'declaredthrough[PropertyRule\\*Property] is niet totaal'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'PropertyRule'
              // Normalized complement (== violationsSQL): I/\\-(declaredthrough;declaredthrough~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(declaredthrough;declaredthrough~)\"] */
                          SELECT DISTINCT isect0.`PropertyRule` AS src, isect0.`PropertyRule` AS tgt
                          FROM `nssharedADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"declaredthrough\",\"declaredthrough~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PropertyRule`, ECps1.`PropertyRule` AS `PropertyRule1`
                                             FROM `nsshareddeclaredthrough` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PropertyRule`, `Property`
                                                    FROM `nsshareddeclaredthrough`
                                                    WHERE `PropertyRule` IS NOT NULL AND `Property` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`Property`=ECps1.`Property`
                                           ) AS cp
                                      WHERE isect0.`PropertyRule`=cp.`PropertyRule` AND isect0.`PropertyRule`=cp.`PropertyRule1`) AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI decprL::Declaration*String' =>
        array ( 'name' => 'UNI decprL::Declaration*String'
              , 'ruleAdl' => 'decprL~;decprL |- I'
              , 'origin' => 'line 152, file "AST.adl"'
              , 'meaning' => 'decprL[Declaration\\*String] is univalent'
              , 'message' => 'decprL[Declaration\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): decprL~;decprL/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprL~;decprL\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprL` AS src, isect0.`decprL1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprL~\",\"decprL\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprL`, ECps1.`decprL` AS `decprL1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decprL`
                                        FROM `nssharedDeclaration`
                                        WHERE `Declaration` IS NOT NULL AND `decprL` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedDeclaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decprL` <> isect0.`decprL1` AND isect0.`decprL` IS NOT NULL AND isect0.`decprL1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI decprM::Declaration*String' =>
        array ( 'name' => 'UNI decprM::Declaration*String'
              , 'ruleAdl' => 'decprM~;decprM |- I'
              , 'origin' => 'line 154, file "AST.adl"'
              , 'meaning' => 'decprM[Declaration\\*String] is univalent'
              , 'message' => 'decprM[Declaration\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): decprM~;decprM/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprM~;decprM\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprM` AS src, isect0.`decprM1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprM~\",\"decprM\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprM`, ECps1.`decprM` AS `decprM1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decprM`
                                        FROM `nssharedDeclaration`
                                        WHERE `Declaration` IS NOT NULL AND `decprM` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedDeclaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decprM` <> isect0.`decprM1` AND isect0.`decprM` IS NOT NULL AND isect0.`decprM1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI decprR::Declaration*String' =>
        array ( 'name' => 'UNI decprR::Declaration*String'
              , 'ruleAdl' => 'decprR~;decprR |- I'
              , 'origin' => 'line 156, file "AST.adl"'
              , 'meaning' => 'decprR[Declaration\\*String] is univalent'
              , 'message' => 'decprR[Declaration\\*String] is niet univalent'
              , 'srcConcept' => 'String'
              , 'tgtConcept' => 'String'
              // Normalized complement (== violationsSQL): decprR~;decprR/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"decprR~;decprR\",\"-I\"] */
                          SELECT DISTINCT isect0.`decprR` AS src, isect0.`decprR1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"decprR~\",\"decprR\"] */
                                 
                                 SELECT DISTINCT ECps0.`decprR`, ECps1.`decprR` AS `decprR1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Declaration`, `decprR`
                                        FROM `nssharedDeclaration`
                                        WHERE `Declaration` IS NOT NULL AND `decprR` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedDeclaration` AS ECps1
                                 WHERE ECps0.`Declaration`=ECps1.`Declaration`
                               ) AS isect0
                          WHERE isect0.`decprR` <> isect0.`decprR1` AND isect0.`decprR` IS NOT NULL AND isect0.`decprR1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI PropertyRule::PropertyRule*Rule' =>
        array ( 'name' => 'UNI PropertyRule::PropertyRule*Rule'
              , 'ruleAdl' => 'PropertyRule~;PropertyRule |- I'
              , 'origin' => 'line 145, file "AST.adl"'
              , 'meaning' => 'PropertyRule[PropertyRule\\*Rule] is univalent'
              , 'message' => 'PropertyRule[PropertyRule\\*Rule] is niet univalent'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalized complement (== violationsSQL): PropertyRule~;PropertyRule/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"PropertyRule~;PropertyRule\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"PropertyRule~\",\"PropertyRule\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PropertyRule`, `rrnm`
                                        FROM `nssharedADLid`
                                        WHERE `PropertyRule` IS NOT NULL AND `rrnm` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedADLid` AS ECps1
                                 WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`
                               ) AS isect0
                          WHERE isect0.`rrnm` <> isect0.`rrnm1` AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT PropertyRule::PropertyRule*Rule' =>
        array ( 'name' => 'TOT PropertyRule::PropertyRule*Rule'
              , 'ruleAdl' => 'I |- PropertyRule;PropertyRule~'
              , 'origin' => 'line 145, file "AST.adl"'
              , 'meaning' => 'PropertyRule[PropertyRule\\*Rule] is totaal'
              , 'message' => 'PropertyRule[PropertyRule\\*Rule] is niet totaal'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'PropertyRule'
              // Normalized complement (== violationsSQL): I/\\-(PropertyRule;PropertyRule~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(PropertyRule;PropertyRule~)\"] */
                          SELECT DISTINCT isect0.`PropertyRule` AS src, isect0.`PropertyRule` AS tgt
                          FROM `nssharedADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"PropertyRule\",\"PropertyRule~\"] */
                                             
                                             SELECT DISTINCT ECps0.`PropertyRule`, ECps1.`PropertyRule` AS `PropertyRule1`
                                             FROM `nssharedADLid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `PropertyRule`, `rrnm`
                                                    FROM `nssharedADLid`
                                                    WHERE `PropertyRule` IS NOT NULL AND `rrnm` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`rrnm`=ECps1.`rrnm`
                                           ) AS cp
                                      WHERE isect0.`PropertyRule`=cp.`PropertyRule` AND isect0.`PropertyRule`=cp.`PropertyRule1`) AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ PropertyRule::PropertyRule*Rule' =>
        array ( 'name' => 'INJ PropertyRule::PropertyRule*Rule'
              , 'ruleAdl' => 'PropertyRule;PropertyRule~ |- I'
              , 'origin' => 'line 145, file "AST.adl"'
              , 'meaning' => 'PropertyRule[PropertyRule\\*Rule] is injectief'
              , 'message' => 'PropertyRule[PropertyRule\\*Rule] is niet injectief'
              , 'srcConcept' => 'PropertyRule'
              , 'tgtConcept' => 'PropertyRule'
              // Normalized complement (== violationsSQL): PropertyRule;PropertyRule~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"PropertyRule;PropertyRule~\",\"-I\"] */
                          SELECT DISTINCT isect0.`PropertyRule` AS src, isect0.`PropertyRule1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"PropertyRule\",\"PropertyRule~\"] */
                                 
                                 SELECT DISTINCT ECps0.`PropertyRule`, ECps1.`PropertyRule` AS `PropertyRule1`
                                 FROM `nssharedADLid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `PropertyRule`, `rrnm`
                                        FROM `nssharedADLid`
                                        WHERE `PropertyRule` IS NOT NULL AND `rrnm` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`PropertyRule` <> isect0.`PropertyRule1` AND isect0.`PropertyRule` IS NOT NULL AND isect0.`PropertyRule1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI exprvalue::ExpressionID*Expression' =>
        array ( 'name' => 'UNI exprvalue::ExpressionID*Expression'
              , 'ruleAdl' => 'exprvalue~;exprvalue |- I'
              , 'origin' => 'line 186, file "AST.adl"'
              , 'meaning' => 'exprvalue[ExpressionID\\*Expression] is univalent'
              , 'message' => 'exprvalue[ExpressionID\\*Expression] is niet univalent'
              , 'srcConcept' => 'Expression'
              , 'tgtConcept' => 'Expression'
              // Normalized complement (== violationsSQL): exprvalue~;exprvalue/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"exprvalue~;exprvalue\",\"-I\"] */
                          SELECT DISTINCT isect0.`exprvalue` AS src, isect0.`exprvalue1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"exprvalue~\",\"exprvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`exprvalue`, ECps1.`exprvalue` AS `exprvalue1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ExpressionID`, `exprvalue`
                                        FROM `nssharedExpressionID`
                                        WHERE `ExpressionID` IS NOT NULL AND `exprvalue` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedExpressionID` AS ECps1
                                 WHERE ECps0.`ExpressionID`=ECps1.`ExpressionID`
                               ) AS isect0
                          WHERE isect0.`exprvalue` <> isect0.`exprvalue1` AND isect0.`exprvalue` IS NOT NULL AND isect0.`exprvalue1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT exprvalue::ExpressionID*Expression' =>
        array ( 'name' => 'TOT exprvalue::ExpressionID*Expression'
              , 'ruleAdl' => 'I |- exprvalue;exprvalue~'
              , 'origin' => 'line 186, file "AST.adl"'
              , 'meaning' => 'exprvalue[ExpressionID\\*Expression] is totaal'
              , 'message' => 'exprvalue[ExpressionID\\*Expression] is niet totaal'
              , 'srcConcept' => 'ExpressionID'
              , 'tgtConcept' => 'ExpressionID'
              // Normalized complement (== violationsSQL): I/\\-(exprvalue;exprvalue~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(exprvalue;exprvalue~)\"] */
                          SELECT DISTINCT isect0.`ExpressionID` AS src, isect0.`ExpressionID` AS tgt
                          FROM `nssharedExpressionID` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"exprvalue\",\"exprvalue~\"] */
                                             
                                             SELECT DISTINCT ECps0.`ExpressionID`, ECps1.`ExpressionID` AS `ExpressionID1`
                                             FROM `nssharedExpressionID` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `ExpressionID`, `exprvalue`
                                                    FROM `nssharedExpressionID`
                                                    WHERE `ExpressionID` IS NOT NULL AND `exprvalue` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`exprvalue`=ECps1.`exprvalue`
                                           ) AS cp
                                      WHERE isect0.`ExpressionID`=cp.`ExpressionID` AND isect0.`ExpressionID`=cp.`ExpressionID1`) AND isect0.`ExpressionID` IS NOT NULL AND isect0.`ExpressionID` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI relnm::Relation*Varid' =>
        array ( 'name' => 'UNI relnm::Relation*Varid'
              , 'ruleAdl' => 'relnm~;relnm |- I'
              , 'origin' => 'line 194, file "AST.adl"'
              , 'meaning' => 'relnm[Relation\\*Varid] is univalent'
              , 'message' => 'relnm[Relation\\*Varid] is niet univalent'
              , 'srcConcept' => 'Varid'
              , 'tgtConcept' => 'Varid'
              // Normalized complement (== violationsSQL): relnm~;relnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"relnm~;relnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`relnm` AS src, isect0.`relnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"relnm~\",\"relnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`relnm`, ECps1.`relnm` AS `relnm1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Relation`, `relnm`
                                        FROM `nssharedRelation`
                                        WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedRelation` AS ECps1
                                 WHERE ECps0.`Relation`=ECps1.`Relation`
                               ) AS isect0
                          WHERE isect0.`relnm` <> isect0.`relnm1` AND isect0.`relnm` IS NOT NULL AND isect0.`relnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT relnm::Relation*Varid' =>
        array ( 'name' => 'TOT relnm::Relation*Varid'
              , 'ruleAdl' => 'I |- relnm;relnm~'
              , 'origin' => 'line 194, file "AST.adl"'
              , 'meaning' => 'relnm[Relation\\*Varid] is totaal'
              , 'message' => 'relnm[Relation\\*Varid] is niet totaal'
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Relation'
              // Normalized complement (== violationsSQL): I/\\-(relnm;relnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(relnm;relnm~)\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`Relation` AS tgt
                          FROM `nssharedRelation` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"relnm\",\"relnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Relation`, ECps1.`Relation` AS `Relation1`
                                             FROM `nssharedRelation` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Relation`, `relnm`
                                                    FROM `nssharedRelation`
                                                    WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`relnm`=ECps1.`relnm`
                                           ) AS cp
                                      WHERE isect0.`Relation`=cp.`Relation` AND isect0.`Relation`=cp.`Relation1`) AND isect0.`Relation` IS NOT NULL AND isect0.`Relation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI relsgn::Relation*Sign' =>
        array ( 'name' => 'UNI relsgn::Relation*Sign'
              , 'ruleAdl' => 'relsgn~;relsgn |- I'
              , 'origin' => 'line 196, file "AST.adl"'
              , 'meaning' => 'relsgn[Relation\\*Sign] is univalent'
              , 'message' => 'relsgn[Relation\\*Sign] is niet univalent'
              , 'srcConcept' => 'Sign'
              , 'tgtConcept' => 'Sign'
              // Normalized complement (== violationsSQL): relsgn~;relsgn/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"relsgn~;relsgn\",\"-I\"] */
                          SELECT DISTINCT isect0.`relsgn` AS src, isect0.`relsgn1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"relsgn~\",\"relsgn\"] */
                                 
                                 SELECT DISTINCT ECps0.`relsgn`, ECps1.`relsgn` AS `relsgn1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Relation`, `relsgn`
                                        FROM `nssharedRelation`
                                        WHERE `Relation` IS NOT NULL AND `relsgn` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedRelation` AS ECps1
                                 WHERE ECps0.`Relation`=ECps1.`Relation`
                               ) AS isect0
                          WHERE isect0.`relsgn` <> isect0.`relsgn1` AND isect0.`relsgn` IS NOT NULL AND isect0.`relsgn1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT relsgn::Relation*Sign' =>
        array ( 'name' => 'TOT relsgn::Relation*Sign'
              , 'ruleAdl' => 'I |- relsgn;relsgn~'
              , 'origin' => 'line 196, file "AST.adl"'
              , 'meaning' => 'relsgn[Relation\\*Sign] is totaal'
              , 'message' => 'relsgn[Relation\\*Sign] is niet totaal'
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Relation'
              // Normalized complement (== violationsSQL): I/\\-(relsgn;relsgn~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(relsgn;relsgn~)\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`Relation` AS tgt
                          FROM `nssharedRelation` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"relsgn\",\"relsgn~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Relation`, ECps1.`Relation` AS `Relation1`
                                             FROM `nssharedRelation` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Relation`, `relsgn`
                                                    FROM `nssharedRelation`
                                                    WHERE `Relation` IS NOT NULL AND `relsgn` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`relsgn`=ECps1.`relsgn`
                                           ) AS cp
                                      WHERE isect0.`Relation`=cp.`Relation` AND isect0.`Relation`=cp.`Relation1`) AND isect0.`Relation` IS NOT NULL AND isect0.`Relation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI reldcl::Relation*Declaration' =>
        array ( 'name' => 'UNI reldcl::Relation*Declaration'
              , 'ruleAdl' => 'reldcl~;reldcl |- I'
              , 'origin' => 'line 198, file "AST.adl"'
              , 'meaning' => 'reldcl[Relation\\*Declaration] is univalent'
              , 'message' => 'reldcl[Relation\\*Declaration] is niet univalent'
              , 'srcConcept' => 'Declaration'
              , 'tgtConcept' => 'Declaration'
              // Normalized complement (== violationsSQL): reldcl~;reldcl/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"reldcl~;reldcl\",\"-I\"] */
                          SELECT DISTINCT isect0.`reldcl` AS src, isect0.`reldcl1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"reldcl~\",\"reldcl\"] */
                                 
                                 SELECT DISTINCT ECps0.`reldcl`, ECps1.`reldcl` AS `reldcl1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Relation`, `reldcl`
                                        FROM `nssharedRelation`
                                        WHERE `Relation` IS NOT NULL AND `reldcl` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedRelation` AS ECps1
                                 WHERE ECps0.`Relation`=ECps1.`Relation`
                               ) AS isect0
                          WHERE isect0.`reldcl` <> isect0.`reldcl1` AND isect0.`reldcl` IS NOT NULL AND isect0.`reldcl1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT reldcl::Relation*Declaration' =>
        array ( 'name' => 'TOT reldcl::Relation*Declaration'
              , 'ruleAdl' => 'I |- reldcl;reldcl~'
              , 'origin' => 'line 198, file "AST.adl"'
              , 'meaning' => 'reldcl[Relation\\*Declaration] is totaal'
              , 'message' => 'reldcl[Relation\\*Declaration] is niet totaal'
              , 'srcConcept' => 'Relation'
              , 'tgtConcept' => 'Relation'
              // Normalized complement (== violationsSQL): I/\\-(reldcl;reldcl~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(reldcl;reldcl~)\"] */
                          SELECT DISTINCT isect0.`Relation` AS src, isect0.`Relation` AS tgt
                          FROM `nssharedRelation` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"reldcl\",\"reldcl~\"] */
                                             
                                             SELECT DISTINCT ECps0.`Relation`, ECps1.`Relation` AS `Relation1`
                                             FROM `nssharedRelation` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `Relation`, `reldcl`
                                                    FROM `nssharedRelation`
                                                    WHERE `Relation` IS NOT NULL AND `reldcl` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`reldcl`=ECps1.`reldcl`
                                           ) AS cp
                                      WHERE isect0.`Relation`=cp.`Relation` AND isect0.`Relation`=cp.`Relation1`) AND isect0.`Relation` IS NOT NULL AND isect0.`Relation` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'INJ rrnm::Rule*ADLid' =>
        array ( 'name' => 'INJ rrnm::Rule*ADLid'
              , 'ruleAdl' => 'rrnm;rrnm~ |- I'
              , 'origin' => 'line 209, file "AST.adl"'
              , 'meaning' => 'rrnm[Rule\\*ADLid] is injectief'
              , 'message' => 'rrnm[Rule\\*ADLid] is niet injectief'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalized complement (== violationsSQL): rrnm;rrnm~/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrnm;rrnm~\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrnm\",\"rrnm~\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                 FROM `nssharedADLid` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `ADLid`
                                        FROM `nssharedADLid`
                                        WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL
                                      ) AS ECps1
                                 WHERE ECps0.`ADLid`=ECps1.`ADLid`
                               ) AS isect0
                          WHERE isect0.`rrnm` <> isect0.`rrnm1` AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI rrnm::Rule*ADLid' =>
        array ( 'name' => 'UNI rrnm::Rule*ADLid'
              , 'ruleAdl' => 'rrnm~;rrnm |- I'
              , 'origin' => 'line 209, file "AST.adl"'
              , 'meaning' => 'rrnm[Rule\\*ADLid] is univalent'
              , 'message' => 'rrnm[Rule\\*ADLid] is niet univalent'
              , 'srcConcept' => 'ADLid'
              , 'tgtConcept' => 'ADLid'
              // Normalized complement (== violationsSQL): rrnm~;rrnm/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrnm~;rrnm\",\"-I\"] */
                          SELECT DISTINCT isect0.`ADLid` AS src, isect0.`ADLid1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrnm~\",\"rrnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`ADLid`, ECps1.`ADLid` AS `ADLid1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `ADLid`
                                        FROM `nssharedADLid`
                                        WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedADLid` AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`ADLid` <> isect0.`ADLid1` AND isect0.`ADLid` IS NOT NULL AND isect0.`ADLid1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT rrnm::Rule*ADLid' =>
        array ( 'name' => 'TOT rrnm::Rule*ADLid'
              , 'ruleAdl' => 'I |- rrnm;rrnm~'
              , 'origin' => 'line 209, file "AST.adl"'
              , 'meaning' => 'rrnm[Rule\\*ADLid] is totaal'
              , 'message' => 'rrnm[Rule\\*ADLid] is niet totaal'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalized complement (== violationsSQL): I/\\-(rrnm;rrnm~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(rrnm;rrnm~)\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm` AS tgt
                          FROM `nssharedADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"rrnm\",\"rrnm~\"] */
                                             
                                             SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                             FROM `nssharedADLid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `rrnm`, `ADLid`
                                                    FROM `nssharedADLid`
                                                    WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`ADLid`=ECps1.`ADLid`
                                           ) AS cp
                                      WHERE isect0.`rrnm`=cp.`rrnm` AND isect0.`rrnm`=cp.`rrnm1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'UNI rrexp::Rule*ExpressionID' =>
        array ( 'name' => 'UNI rrexp::Rule*ExpressionID'
              , 'ruleAdl' => 'rrexp~;rrexp |- I'
              , 'origin' => 'line 211, file "AST.adl"'
              , 'meaning' => 'rrexp[Rule\\*ExpressionID] is univalent'
              , 'message' => 'rrexp[Rule\\*ExpressionID] is niet univalent'
              , 'srcConcept' => 'ExpressionID'
              , 'tgtConcept' => 'ExpressionID'
              // Normalized complement (== violationsSQL): rrexp~;rrexp/\\-I
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"rrexp~;rrexp\",\"-I\"] */
                          SELECT DISTINCT isect0.`rrexp` AS src, isect0.`rrexp1` AS tgt
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ECps [\"rrexp~\",\"rrexp\"] */
                                 
                                 SELECT DISTINCT ECps0.`rrexp`, ECps1.`rrexp` AS `rrexp1`
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `rrnm`, `rrexp`
                                        FROM `nssharedADLid`
                                        WHERE `rrnm` IS NOT NULL AND `rrexp` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedADLid` AS ECps1
                                 WHERE ECps0.`rrnm`=ECps1.`rrnm`
                               ) AS isect0
                          WHERE isect0.`rrexp` <> isect0.`rrexp1` AND isect0.`rrexp` IS NOT NULL AND isect0.`rrexp1` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    , 'TOT rrexp::Rule*ExpressionID' =>
        array ( 'name' => 'TOT rrexp::Rule*ExpressionID'
              , 'ruleAdl' => 'I |- rrexp;rrexp~'
              , 'origin' => 'line 211, file "AST.adl"'
              , 'meaning' => 'rrexp[Rule\\*ExpressionID] is totaal'
              , 'message' => 'rrexp[Rule\\*ExpressionID] is niet totaal'
              , 'srcConcept' => 'Rule'
              , 'tgtConcept' => 'Rule'
              // Normalized complement (== violationsSQL): I/\\-(rrexp;rrexp~)
              , 'violationsSQL' => '/* case: (EIsc lst@(_:_:_))
                             EIsc [\"I\",\"-(rrexp;rrexp~)\"] */
                          SELECT DISTINCT isect0.`rrnm` AS src, isect0.`rrnm` AS tgt
                          FROM `nssharedADLid` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                           ( /* case: (ECps es), with two or more elements in es.
                                                ECps [\"rrexp\",\"rrexp~\"] */
                                             
                                             SELECT DISTINCT ECps0.`rrnm`, ECps1.`rrnm` AS `rrnm1`
                                             FROM `nssharedADLid` AS ECps0,
                                                  
                                                  ( /* case: EFlp x. */
                                                    SELECT DISTINCT `rrnm`, `rrexp`
                                                    FROM `nssharedADLid`
                                                    WHERE `rrnm` IS NOT NULL AND `rrexp` IS NOT NULL
                                                  ) AS ECps1
                                             WHERE ECps0.`rrexp`=ECps1.`rrexp`
                                           ) AS cp
                                      WHERE isect0.`rrnm`=cp.`rrnm` AND isect0.`rrnm`=cp.`rrnm1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm` IS NOT NULL'
              , 'pairView' =>
                  array
                    ()
              )
    );

$invariantRuleNames = array ('UNI firstloadedwith::AdlFile*AdlVersion', 'UNI parseerror::File*ParseError', 'UNI pe_action::ParseError*String', 'TOT pe_action::ParseError*String', 'UNI pe_position::ParseError*String', 'TOT pe_position::ParseError*String', 'UNI pe_expecting::ParseError*String', 'TOT pe_expecting::ParseError*String', 'UNI te_message::TypeError*ErrorMessage', 'UNI te_parent::TypeError*TypeError', 'UNI te_position::TypeError*String', 'UNI te_origtype::TypeError*String', 'UNI te_origname::TypeError*String', 'UNI filename::File*FileName', 'TOT filename::File*FileName', 'UNI filepath::File*FilePath', 'UNI filetime::File*CalendarTime', 'UNI userrole::User*Role', 'UNI sourcefile::Context*AdlFile', 'TOT sourcefile::Context*AdlFile', 'UNI applyto::G*AdlFile', 'TOT applyto::G*AdlFile', 'UNI functionname::G*String', 'TOT functionname::G*String', 'UNI operation::G*Int', 'TOT operation::G*Int', 'UNI newfile::User*NewAdlFile', 'TOT newfile::User*NewAdlFile', 'UNI savepopulation::Context*SavePopFile', 'TOT savepopulation::Context*SavePopFile', 'UNI savecontext::Context*SaveAdlFile', 'TOT savecontext::Context*SaveAdlFile', 'UNI AdlFile::AdlFile*File', 'TOT AdlFile::AdlFile*File', 'INJ AdlFile::AdlFile*File', 'UNI NewAdlFile::NewAdlFile*AdlFile', 'TOT NewAdlFile::NewAdlFile*AdlFile', 'INJ NewAdlFile::NewAdlFile*AdlFile', 'UNI SavePopFile::SavePopFile*File', 'TOT SavePopFile::SavePopFile*File', 'INJ SavePopFile::SavePopFile*File', 'UNI SaveAdlFile::SaveAdlFile*AdlFile', 'TOT SaveAdlFile::SaveAdlFile*AdlFile', 'INJ SaveAdlFile::SaveAdlFile*AdlFile', 'UNI countrules::Context*Int', 'UNI countdecls::Context*Int', 'UNI countcpts::Context*Int', 'UNI ptpic::Pattern*Image', 'UNI cptpic::Concept*Image', 'UNI rrpic::Rule*Image', 'UNI Violation::Violation*PairID', 'TOT Violation::Violation*PairID', 'INJ Violation::Violation*PairID', 'INJ ctxnm::Context*Conid', 'UNI ctxnm::Context*Conid', 'TOT ctxnm::Context*Conid', 'INJ ptnm::Pattern*Conid', 'UNI ptnm::Pattern*Conid', 'TOT ptnm::Pattern*Conid', 'UNI gengen::Gen*Concept', 'TOT gengen::Gen*Concept', 'UNI genspc::Gen*Concept', 'TOT genspc::Gen*Concept', 'INJ cptnm::Concept*Conid', 'UNI cptnm::Concept*Conid', 'TOT cptnm::Concept*Conid', 'INJ ordername::Order*String', 'UNI ordername::Order*String', 'TOT ordername::Order*String', 'UNI order::Concept*Order', 'TOT order::Concept*Order', 'UNI atomvalue::AtomID*Atom', 'TOT atomvalue::AtomID*Atom', 'UNI src::Sign*Concept', 'TOT src::Sign*Concept', 'UNI trg::Sign*Concept', 'TOT trg::Sign*Concept', 'UNI left::PairID*AtomID', 'TOT left::PairID*AtomID', 'UNI right::PairID*AtomID', 'TOT right::PairID*AtomID', 'UNI decnm::Declaration*Varid', 'TOT decnm::Declaration*Varid', 'UNI decsgn::Declaration*Sign', 'TOT decsgn::Declaration*Sign', 'INJ decprps::Declaration*PropertyRule', 'TOT declaredthrough::PropertyRule*Property', 'UNI decprL::Declaration*String', 'UNI decprM::Declaration*String', 'UNI decprR::Declaration*String', 'UNI PropertyRule::PropertyRule*Rule', 'TOT PropertyRule::PropertyRule*Rule', 'INJ PropertyRule::PropertyRule*Rule', 'UNI exprvalue::ExpressionID*Expression', 'TOT exprvalue::ExpressionID*Expression', 'UNI relnm::Relation*Varid', 'TOT relnm::Relation*Varid', 'UNI relsgn::Relation*Sign', 'TOT relsgn::Relation*Sign', 'UNI reldcl::Relation*Declaration', 'TOT reldcl::Relation*Declaration', 'INJ rrnm::Rule*ADLid', 'UNI rrnm::Rule*ADLid', 'TOT rrnm::Rule*ADLid', 'UNI rrexp::Rule*ExpressionID', 'TOT rrexp::Rule*ExpressionID', 'unique file location', 'user roles', 'eq gen', 'order', 'referential integrity', 'entity integrity concept', 'eq declaration', 'property enum', 'entity integrity of relation', 'typed domain', 'typed codomain', 'rel name is decl name');

$allRoles =
  array
    ( array ( 'name' => 'Student'
            , 'ruleNames' => array ('specgenduplicate', 'multviolations', 'homoviolations', 'otherviolations', 'popadd', 'popdel', 'parseerror', 'typeerror')
            )
    , array ( 'name' => 'Admin'
            , 'ruleNames' => array ('dummy')
            )
    );

//$allKeys is sorted from spec to gen such that the first match for a concept will be the most specific (e.g. see DatabaseUtils.getKey()).
$allKeys =
  array
    (   array ( 'label' => 'NewAdlFile'
              , 'concept' => 'NewAdlFile'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filename[NewAdlFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'SavePopFile'
              , 'concept' => 'SavePopFile'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?operation=4&file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filepath[SavePopFile*FilePath]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filepath\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: filename[SavePopFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: filename[SavePopFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'SaveAdlFile'
              , 'concept' => 'SaveAdlFile'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?operation=2&file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filepath[SaveAdlFile*FilePath]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filepath\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: filename[SaveAdlFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '&userrole=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: savecontext~;sourcefile;uploaded[User*AdlFile]~;userrole
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"savecontext~\",\"sourcefile\",\"uploaded[User*AdlFile]~\",\"userrole\"] */
                                 
                                 SELECT DISTINCT ECps0.`savecontext` AS src, ECps3.`userrole` AS tgt
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `ctxnm`, `savecontext`
                                        FROM `nssharedConid`
                                        WHERE `ctxnm` IS NOT NULL AND `savecontext` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1,
                                      
                                      ( /* case: EFlp x. */
                                        /* case: ETyp x _
                                           ETyp ( \"uploaded\" ) _ */
                                        SELECT DISTINCT `User`, `File`
                                        FROM `nsshareduploaded`
                                        WHERE `User` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps2,
                                      `nssharedUser` AS ECps3
                                 WHERE ECps0.`ctxnm`=ECps1.`ctxnm`
                                   AND ECps1.`sourcefile`=ECps2.`File`
                                   AND ECps2.`User`=ECps3.`User`' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '7' // key exp: filename[SaveAdlFile*FileName]
                            , 'expSQL' =>
                                '/* case: ETyp x _
                                    ETyp ( \"filename\" ) _ */
                                 SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'File'
              , 'concept' => 'File'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: filepath
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: filename
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '&userrole=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: uploaded~;userrole
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"uploaded~\",\"userrole\"] */
                                 
                                 SELECT DISTINCT ECps0.`File` AS src, ECps1.`userrole` AS tgt
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `User`, `File`
                                        FROM `nsshareduploaded`
                                        WHERE `User` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedUser` AS ECps1
                                 WHERE ECps0.`User`=ECps1.`User`' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '7' // key exp: filename
                            , 'expSQL' =>
                                'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                 FROM `nssharedFile`
                                 WHERE `File` IS NOT NULL AND `filename` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'PairID'
              , 'concept' => 'PairID'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: left;atomvalue
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"left\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID` AS src, ECps1.`atomvalue` AS tgt
                                 FROM `nssharedPairID` AS ECps0,
                                      `nssharedAtomID` AS ECps1
                                 WHERE ECps0.`left`=ECps1.`AtomID`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: right;atomvalue
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"right\",\"atomvalue\"] */
                                 
                                 SELECT DISTINCT ECps0.`PairID` AS src, ECps1.`atomvalue` AS tgt
                                 FROM `nssharedPairID` AS ECps0,
                                      `nssharedAtomID` AS ECps1
                                 WHERE ECps0.`right`=ECps1.`AtomID`' )
                    )
            )
    ,   array ( 'label' => 'Rule'
              , 'concept' => 'Rule'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: rrnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `rrnm` AS src, `ADLid` AS tgt
                                 FROM `nssharedADLid`
                                 WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Concept'
              , 'concept' => 'Concept'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: cptnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `cptnm` AS src, `Conid` AS tgt
                                 FROM `nssharedConid`
                                 WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'AtomID'
              , 'concept' => 'AtomID'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: atomvalue
                            , 'expSQL' =>
                                'SELECT DISTINCT `AtomID` AS src, `atomvalue` AS tgt
                                 FROM `nssharedAtomID`
                                 WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' :: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: cptos~;order;ordername
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"cptos~\",\"order\",\"ordername\"] */
                                 
                                 SELECT DISTINCT ECps0.`AtomID` AS src, ECps2.`String` AS tgt
                                 FROM 
                                      ( /* case: EFlp x. */
                                        SELECT DISTINCT `Concept`, `AtomID`
                                        FROM `nssharedcptos`
                                        WHERE `Concept` IS NOT NULL AND `AtomID` IS NOT NULL
                                      ) AS ECps0,
                                      `nssharedConid` AS ECps1,
                                      `nssharedString` AS ECps2
                                 WHERE ECps0.`Concept`=ECps1.`cptnm`
                                   AND ECps1.`order`=ECps2.`ordername`' )
                    )
            )
    ,   array ( 'label' => 'Declaration'
              , 'concept' => 'Declaration'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: decnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `Declaration` AS src, `decnm` AS tgt
                                 FROM `nssharedDeclaration`
                                 WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' :: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: decsgn;src;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"src\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration` AS src, ECps2.`Conid` AS tgt
                                 FROM `nssharedDeclaration` AS ECps0,
                                      `nssharedSign` AS ECps1,
                                      `nssharedConid` AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`src`=ECps2.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: decsgn;trg;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"decsgn\",\"trg\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Declaration` AS src, ECps2.`Conid` AS tgt
                                 FROM `nssharedDeclaration` AS ECps0,
                                      `nssharedSign` AS ECps1,
                                      `nssharedConid` AS ECps2
                                 WHERE ECps0.`decsgn`=ECps1.`Sign`
                                   AND ECps1.`trg`=ECps2.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'Context'
              , 'concept' => 'Context'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: ctxnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                 FROM `nssharedConid`
                                 WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'G'
              , 'concept' => 'G'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<a href=\'../../index.php?operation=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: operation
                            , 'expSQL' =>
                                'SELECT DISTINCT `G` AS src, `operation` AS tgt
                                 FROM `nssharedG`
                                 WHERE `G` IS NOT NULL AND `operation` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '&file=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '4' // key exp: applyto;filepath
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto\",\"filepath\"] */
                                 
                                 SELECT DISTINCT ECps0.`G` AS src, ECps1.`filepath` AS tgt
                                 FROM `nssharedG` AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`applyto`=ECps1.`File`' )
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: applyto;filename
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto\",\"filename\"] */
                                 
                                 SELECT DISTINCT ECps0.`G` AS src, ECps1.`filename` AS tgt
                                 FROM `nssharedG` AS ECps0,
                                      `nssharedFile` AS ECps1
                                 WHERE ECps0.`applyto`=ECps1.`File`' )
                    , array ( 'segmentType' => 'Html', 'Html' => '&userrole=')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '7' // key exp: applyto;uploaded[User*AdlFile]~;userrole
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"applyto\",\"uploaded[User*AdlFile]~\",\"userrole\"] */
                                 
                                 SELECT DISTINCT ECps0.`G` AS src, ECps2.`userrole` AS tgt
                                 FROM `nssharedG` AS ECps0,
                                      
                                      ( /* case: EFlp x. */
                                        /* case: ETyp x _
                                           ETyp ( \"uploaded\" ) _ */
                                        SELECT DISTINCT `User`, `File`
                                        FROM `nsshareduploaded`
                                        WHERE `User` IS NOT NULL AND `File` IS NOT NULL
                                      ) AS ECps1,
                                      `nssharedUser` AS ECps2
                                 WHERE ECps0.`applyto`=ECps1.`File`
                                   AND ECps1.`User`=ECps2.`User`' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '9' // key exp: functionname
                            , 'expSQL' =>
                                'SELECT DISTINCT `G` AS src, `functionname` AS tgt
                                 FROM `nssharedG`
                                 WHERE `G` IS NOT NULL AND `functionname` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '</a>')
                    )
            )
    ,   array ( 'label' => 'Image'
              , 'concept' => 'Image'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Html', 'Html' => '<img src=\'')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: imageurl
                            , 'expSQL' =>
                                'SELECT DISTINCT `Image` AS src, `URL` AS tgt
                                 FROM `nssharedimageurl`
                                 WHERE `Image` IS NOT NULL AND `URL` IS NOT NULL' )
                    , array ( 'segmentType' => 'Html', 'Html' => '\'>')
                    )
            )
    ,   array ( 'label' => 'Pattern'
              , 'concept' => 'Pattern'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: ptnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `ptnm` AS src, `Conid` AS tgt
                                 FROM `nssharedConid`
                                 WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Gen'
              , 'concept' => 'Gen'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'SPEC ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '2' // key exp: genspc;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"genspc\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen` AS src, ECps1.`Conid` AS tgt
                                 FROM `nssharedGen` AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`genspc`=ECps1.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' ISA ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '4' // key exp: gengen;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"gengen\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Gen` AS src, ECps1.`Conid` AS tgt
                                 FROM `nssharedGen` AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`gengen`=ECps1.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'Order'
              , 'concept' => 'Order'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: ordername
                            , 'expSQL' =>
                                'SELECT DISTINCT `ordername` AS src, `String` AS tgt
                                 FROM `nssharedString`
                                 WHERE `ordername` IS NOT NULL AND `String` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Sign'
              , 'concept' => 'Sign'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: src;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"src\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Sign` AS src, ECps1.`Conid` AS tgt
                                 FROM `nssharedSign` AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`src`=ECps1.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ' * ')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: trg;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"trg\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Sign` AS src, ECps1.`Conid` AS tgt
                                 FROM `nssharedSign` AS ECps0,
                                      `nssharedConid` AS ECps1
                                 WHERE ECps0.`trg`=ECps1.`cptnm`' )
                    )
            )
    ,   array ( 'label' => 'ExpressionID'
              , 'concept' => 'ExpressionID'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: exprvalue
                            , 'expSQL' =>
                                'SELECT DISTINCT `ExpressionID` AS src, `exprvalue` AS tgt
                                 FROM `nssharedExpressionID`
                                 WHERE `ExpressionID` IS NOT NULL AND `exprvalue` IS NOT NULL' )
                    )
            )
    ,   array ( 'label' => 'Relation'
              , 'concept' => 'Relation'
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => '1' // key exp: relnm
                            , 'expSQL' =>
                                'SELECT DISTINCT `Relation` AS src, `relnm` AS tgt
                                 FROM `nssharedRelation`
                                 WHERE `Relation` IS NOT NULL AND `relnm` IS NOT NULL' )
                    , array ( 'segmentType' => 'Text', 'Text' => '[')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '3' // key exp: relsgn;src;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"relsgn\",\"src\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Relation` AS src, ECps2.`Conid` AS tgt
                                 FROM `nssharedRelation` AS ECps0,
                                      `nssharedSign` AS ECps1,
                                      `nssharedConid` AS ECps2
                                 WHERE ECps0.`relsgn`=ECps1.`Sign`
                                   AND ECps1.`src`=ECps2.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => '*')
                    , array ( 'segmentType' => 'Exp'
                            , 'label' => '5' // key exp: relsgn;trg;cptnm
                            , 'expSQL' =>
                                '/* case: (ECps es), with two or more elements in es.
                                    ECps [\"relsgn\",\"trg\",\"cptnm\"] */
                                 
                                 SELECT DISTINCT ECps0.`Relation` AS src, ECps2.`Conid` AS tgt
                                 FROM `nssharedRelation` AS ECps0,
                                      `nssharedSign` AS ECps1,
                                      `nssharedConid` AS ECps2
                                 WHERE ECps0.`relsgn`=ECps1.`Sign`
                                   AND ECps1.`trg`=ECps2.`cptnm`' )
                    , array ( 'segmentType' => 'Text', 'Text' => ']')
                    )
            )
    );

$allInterfaceObjects =
  array
    ( // Top-level interface Atlas (Play) for role Student:
      'Atlas (Play)' => 
      array ( 'name' => 'Atlas (Play)'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'CONTEXT'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Context'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Context]\" ] */
                                                SELECT DISTINCT 1 AS src, `Context`.`ctxnm` AS tgt
                                                FROM `nssharedConid` AS `Context`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'name'
                                        // Normalized interface expression (== expressionSQL): ctxnm
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Conid'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                                              FROM `nssharedConid`
                                                              WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'number of RULEs'
                                        // Normalized interface expression (== expressionSQL): countrules
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Int'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countrules` AS tgt
                                                              FROM `nssharedConid`
                                                              WHERE `ctxnm` IS NOT NULL AND `countrules` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'number of relations'
                                        // Normalized interface expression (== expressionSQL): countdecls
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Int'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countdecls` AS tgt
                                                              FROM `nssharedConid`
                                                              WHERE `ctxnm` IS NOT NULL AND `countdecls` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'number of concepts'
                                        // Normalized interface expression (== expressionSQL): countcpts
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Int'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countcpts` AS tgt
                                                              FROM `nssharedConid`
                                                              WHERE `ctxnm` IS NOT NULL AND `countcpts` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'PATTERNs'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Pattern` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedctxpats` AS ECps1
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'concepts'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxcs\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Concept` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedctxcs` AS ECps1
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'ISA-relations'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats;ptgns
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Gen'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\",\"ptgns\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`Gen` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedctxpats` AS ECps1,
                                                     `nssharedptgns` AS ECps2
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`
                                                  AND ECps1.`Pattern`=ECps2.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relations'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats;ptdcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\",\"ptdcs\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`Declaration` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedctxpats` AS ECps1,
                                                     `nssharedptdcs` AS ECps2
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`
                                                  AND ECps1.`Pattern`=ECps2.`Pattern`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relation'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Declaration'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Declaration` AS tgt
                                                              FROM `nssharedDeclaration`
                                                              WHERE `Declaration` IS NOT NULL AND `Declaration` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'with properties'
                                        // Normalized interface expression (== expressionSQL): decprps;declaredthrough
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Property'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"decprps\",\"declaredthrough\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`decprps` AS src, ECps1.`Property` AS tgt
                                                              FROM `nssharedADLid` AS ECps0,
                                                                   `nsshareddeclaredthrough` AS ECps1
                                                              WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'RULEs'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];ctxpats;ptrls;(I[Rule]/\\-I[PropertyRule])
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"ctxpats\",\"ptrls\",\"I[Rule]/\\\\-I[PropertyRule]\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps3.`rrnm1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedctxpats` AS ECps1,
                                                     `nssharedptrls` AS ECps2,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I[Rule]\",\"-I[PropertyRule]\"] */
                                                       SELECT DISTINCT isect0.`rrnm`, isect0.`rrnm1`
                                                       FROM 
                                                            ( /* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `rrnm`, `rrnm` AS `rrnm1`
                                                              FROM `nssharedADLid`
                                                              WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL
                                                            ) AS isect0
                                                       WHERE NOT EXISTS (SELECT * FROM 
                                                                        ( /* case: ETyp x _
                                                                             ETyp ( \"I\" ) _ */
                                                                          SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                                                          FROM `nssharedADLid`
                                                                          WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                                                        ) AS cp
                                                                   WHERE isect0.`rrnm`=cp.`PropertyRule` AND isect0.`rrnm1`=cp.`PropertyRule1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL
                                                     ) AS ECps3
                                                WHERE ECps0.`ctxnm`=ECps1.`Context`
                                                  AND ECps1.`Pattern`=ECps2.`Pattern`
                                                  AND ECps2.`Rule`=ECps3.`rrnm`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Validate for role Student:
      'Validate' => 
      array ( 'name' => 'Validate'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Click to commit and validate the next version'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];savecontext
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SaveAdlFile'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"savecontext\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`savecontext` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedConid` AS ECps1
                                                WHERE ECps0.`ctxnm`=ECps1.`ctxnm`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface CONTEXT files (Design / reload) for role Student:
      'CONTEXT files (Design / reload)' => 
      array ( 'name' => 'CONTEXT files (Design / reload)'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'loaded into Atlas'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Context'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*Context]\" ] */
                                                SELECT DISTINCT 1 AS src, `Context`.`ctxnm` AS tgt
                                                FROM `nssharedConid` AS `Context`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'CONTEXT'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'Context'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `ctxnm` AS tgt
                                                              FROM `nssharedConid`
                                                              WHERE `ctxnm` IS NOT NULL AND `ctxnm` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'source file (click to edit)'
                                        // Normalized interface expression (== expressionSQL): sourcefile \\/ includes
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'File'
                                        , 'expressionSQL' => '/* case: EUni es
                                                                 EUni [\"sourcefile\",\"includes\"] */
                                                              (SELECT DISTINCT `ctxnm` AS src, `sourcefile` AS tgt
                                                                  FROM `nssharedConid`
                                                                  WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                                              ) UNION (SELECT DISTINCT `Context` AS src, `File` AS tgt
                                                                  FROM `nssharedincludes`
                                                                  WHERE `Context` IS NOT NULL AND `File` IS NOT NULL
                                                              
                                                              )'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'operations (click to perform)'
                                        // Normalized interface expression (== expressionSQL): sourcefile;applyto~
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Context'
                                        , 'tgtConcept' => 'G'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"sourcefile\",\"applyto~\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`ctxnm` AS src, ECps1.`G` AS tgt
                                                              FROM `nssharedConid` AS ECps0,
                                                                   
                                                                   ( /* case: EFlp x. */
                                                                     SELECT DISTINCT `G`, `applyto`
                                                                     FROM `nssharedG`
                                                                     WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`sourcefile`=ECps1.`applyto`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'overview of files'
                          // Normalized interface expression (== expressionSQL): V[ONE*User]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'User'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*User]\" ] */
                                                SELECT DISTINCT 1 AS src, `User`.`User` AS tgt
                                                FROM `nssharedUser` AS `User`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'open new source file'
                                        // Normalized interface expression (== expressionSQL): newfile
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'User'
                                        , 'tgtConcept' => 'NewAdlFile'
                                        , 'expressionSQL' => 'SELECT DISTINCT `User` AS src, `newfile` AS tgt
                                                              FROM `nssharedUser`
                                                              WHERE `User` IS NOT NULL AND `newfile` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'source files'
                                        // Normalized interface expression (== expressionSQL): uploaded[User*AdlFile];I[AdlFile]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'User'
                                        , 'tgtConcept' => 'AdlFile'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"uploaded[User*AdlFile]\",\"I[AdlFile]\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`User` AS src, ECps1.`AdlFile1` AS tgt
                                                              FROM 
                                                                   ( /* case: ETyp x _
                                                                        ETyp ( \"uploaded\" ) _ */
                                                                     SELECT DISTINCT `User`, `File`
                                                                     FROM `nsshareduploaded`
                                                                     WHERE `User` IS NOT NULL AND `File` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   
                                                                   ( /* case: ETyp x _
                                                                        ETyp ( \"I\" ) _ */
                                                                     SELECT DISTINCT `AdlFile`, `AdlFile` AS `AdlFile1`
                                                                     FROM `nssharedFile`
                                                                     WHERE `AdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`File`=ECps1.`AdlFile`'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'file name (click to edit)'
                                                      // Normalized interface expression (== expressionSQL): I
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'AdlFile'
                                                      , 'tgtConcept' => 'AdlFile'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `AdlFile` AS src, `AdlFile` AS tgt
                                                                            FROM `nssharedFile`
                                                                            WHERE `AdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'created at'
                                                      // Normalized interface expression (== expressionSQL): filetime
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'File'
                                                      , 'tgtConcept' => 'CalendarTime'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filetime` AS tgt
                                                                            FROM `nssharedFile`
                                                                            WHERE `File` IS NOT NULL AND `filetime` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'operations (click to perform)'
                                                      // Normalized interface expression (== expressionSQL): applyto~
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'AdlFile'
                                                      , 'tgtConcept' => 'G'
                                                      , 'expressionSQL' => '/* case: EFlp x. */
                                                                            SELECT DISTINCT `G` AS tgt, `applyto` AS src
                                                                            FROM `nssharedG`
                                                                            WHERE `G` IS NOT NULL AND `applyto` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Extra functions for role Student:
      'Extra functions' => 
      array ( 'name' => 'Extra functions'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('FileName', 'Role')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Export POPULATIONs to...'
                          // Normalized interface expression (== expressionSQL): V[ONE*Context];savepopulation
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SavePopFile'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*Context]\",\"savepopulation\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`savepopulation` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*Context]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `Context`.`ctxnm`
                                                       FROM `nssharedConid` AS `Context`
                                                     ) AS ECps0,
                                                     `nssharedConid` AS ECps1
                                                WHERE ECps0.`ctxnm`=ECps1.`ctxnm`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'file (INCLUDE only)'
                                        // Normalized interface expression (== expressionSQL): I[SavePopFile]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SavePopFile'
                                        , 'tgtConcept' => 'SavePopFile'
                                        , 'expressionSQL' => '/* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `SavePopFile` AS src, `SavePopFile` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `SavePopFile` IS NOT NULL AND `SavePopFile` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'type a file name'
                                        // Normalized interface expression (== expressionSQL): filename
                                        , 'relation' => 'filename'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'FileName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `filename` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'User settings'
                          // Normalized interface expression (== expressionSQL): V[ONE*User]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'User'
                          , 'expressionSQL' => '/* case: ETyp x _
                                                   ETyp ( \"V\" ) _ */
                                                /* case: (ERel (V (Sign s t)))
                                                   ERel [ \"V[ONE*User]\" ] */
                                                SELECT DISTINCT 1 AS src, `User`.`User` AS tgt
                                                FROM `nssharedUser` AS `User`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'use role to load files'
                                        // Normalized interface expression (== expressionSQL): userrole
                                        , 'relation' => 'userrole'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'User'
                                        , 'tgtConcept' => 'Role'
                                        , 'expressionSQL' => 'SELECT DISTINCT `User` AS src, `userrole` AS tgt
                                                              FROM `nssharedUser`
                                                              WHERE `User` IS NOT NULL AND `userrole` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'files with only POPULATIONs'
                          // Normalized interface expression (== expressionSQL): V[ONE*User];uploaded;(I[File]/\\-I[AdlFile])
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'File'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*User]\",\"uploaded\",\"I[File]/\\\\-I[AdlFile]\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`File1` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*User]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `User`.`User`
                                                       FROM `nssharedUser` AS `User`
                                                     ) AS ECps0,
                                                     `nsshareduploaded` AS ECps1,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I[File]\",\"-I[AdlFile]\"] */
                                                       SELECT DISTINCT isect0.`File`, isect0.`File1`
                                                       FROM 
                                                            ( /* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `File`, `File` AS `File1`
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `File` IS NOT NULL
                                                            ) AS isect0
                                                       WHERE NOT EXISTS (SELECT * FROM 
                                                                        ( /* case: ETyp x _
                                                                             ETyp ( \"I\" ) _ */
                                                                          SELECT DISTINCT `AdlFile`, `AdlFile` AS `AdlFile1`
                                                                          FROM `nssharedFile`
                                                                          WHERE `AdlFile` IS NOT NULL AND `AdlFile` IS NOT NULL
                                                                        ) AS cp
                                                                   WHERE isect0.`File`=cp.`AdlFile` AND isect0.`File1`=cp.`AdlFile1`) AND isect0.`File` IS NOT NULL AND isect0.`File1` IS NOT NULL
                                                     ) AS ECps2
                                                WHERE ECps0.`User`=ECps1.`User`
                                                  AND ECps1.`File`=ECps2.`File`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'file name'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'File'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `File` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `File` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'created at'
                                        // Normalized interface expression (== expressionSQL): filetime
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'CalendarTime'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filetime` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `filetime` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Relation with theory (Manual) for role Student:
      'Relation with theory (Manual)' => 
      array ( 'name' => 'Relation with theory (Manual)'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'introduction'
                          // Normalized interface expression (== expressionSQL): V[ONE*MetaInformation];rapdescr
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*MetaInformation]\",\"rapdescr\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps1.`Blob` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*MetaInformation]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `MetaInformation`.`MetaInformation`
                                                       FROM `nssharedMetaInformation` AS `MetaInformation`
                                                     ) AS ECps0,
                                                     `nssharedrapdescr` AS ECps1
                                                WHERE ECps0.`MetaInformation`=ECps1.`MetaInformation`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'rule based process management'
                          // Normalized interface expression (== expressionSQL): V[ONE*MetaInformation];engineimage;engineimage~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'MetaInformation'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*MetaInformation]\",\"engineimage\",\"engineimage~\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`MetaInformation` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*MetaInformation]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `MetaInformation`.`MetaInformation`
                                                       FROM `nssharedMetaInformation` AS `MetaInformation`
                                                     ) AS ECps0,
                                                     `nssharedengineimage` AS ECps1,
                                                     
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `MetaInformation`, `Image`
                                                       FROM `nssharedengineimage`
                                                       WHERE `MetaInformation` IS NOT NULL AND `Image` IS NOT NULL
                                                     ) AS ECps2
                                                WHERE ECps0.`MetaInformation`=ECps1.`MetaInformation`
                                                  AND ECps1.`Image`=ECps2.`Image`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'explanation'
                                        // Normalized interface expression (== expressionSQL): engineexpl
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'MetaInformation'
                                        , 'tgtConcept' => 'Blob'
                                        , 'expressionSQL' => 'SELECT DISTINCT `MetaInformation` AS src, `Blob` AS tgt
                                                              FROM `nssharedengineexpl`
                                                              WHERE `MetaInformation` IS NOT NULL AND `Blob` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'diagram'
                                        // Normalized interface expression (== expressionSQL): engineimage
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'MetaInformation'
                                        , 'tgtConcept' => 'Image'
                                        , 'expressionSQL' => 'SELECT DISTINCT `MetaInformation` AS src, `Image` AS tgt
                                                              FROM `nssharedengineimage`
                                                              WHERE `MetaInformation` IS NOT NULL AND `Image` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'generate design artifacts'
                          // Normalized interface expression (== expressionSQL): V[ONE*MetaInformation];genimage;genimage~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'MetaInformation'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"V[ONE*MetaInformation]\",\"genimage\",\"genimage~\"] */
                                                
                                                SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`MetaInformation` AS tgt
                                                FROM 
                                                     ( /* case: ETyp x _
                                                          ETyp ( \"V\" ) _ */
                                                       /* case: (ERel (V (Sign s t)))
                                                          ERel [ \"V[ONE*MetaInformation]\" ] */
                                                       SELECT DISTINCT 1 AS `I[ONE]`, `MetaInformation`.`MetaInformation`
                                                       FROM `nssharedMetaInformation` AS `MetaInformation`
                                                     ) AS ECps0,
                                                     `nssharedgenimage` AS ECps1,
                                                     
                                                     ( /* case: EFlp x. */
                                                       SELECT DISTINCT `MetaInformation`, `Image`
                                                       FROM `nssharedgenimage`
                                                       WHERE `MetaInformation` IS NOT NULL AND `Image` IS NOT NULL
                                                     ) AS ECps2
                                                WHERE ECps0.`MetaInformation`=ECps1.`MetaInformation`
                                                  AND ECps1.`Image`=ECps2.`Image`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'explanation'
                                        // Normalized interface expression (== expressionSQL): genexpl
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'MetaInformation'
                                        , 'tgtConcept' => 'Blob'
                                        , 'expressionSQL' => 'SELECT DISTINCT `MetaInformation` AS src, `Blob` AS tgt
                                                              FROM `nssharedgenexpl`
                                                              WHERE `MetaInformation` IS NOT NULL AND `Blob` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'diagram'
                                        // Normalized interface expression (== expressionSQL): genimage
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'MetaInformation'
                                        , 'tgtConcept' => 'Image'
                                        , 'expressionSQL' => 'SELECT DISTINCT `MetaInformation` AS src, `Image` AS tgt
                                                              FROM `nssharedgenimage`
                                                              WHERE `MetaInformation` IS NOT NULL AND `Image` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface CONTEXT for role Student:
      'CONTEXT' => 
      array ( 'name' => 'CONTEXT'
            // Normalized interface expression (== expressionSQL): I[Context]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Context'
            , 'tgtConcept' => 'Context'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `ctxnm` AS src, `ctxnm` AS tgt
                                  FROM `nssharedConid`
                                  WHERE `ctxnm` IS NOT NULL AND `ctxnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'name'
                          // Normalized interface expression (== expressionSQL): ctxnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Conid'
                          , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                                FROM `nssharedConid`
                                                WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'PATTERNs'
                          // Normalized interface expression (== expressionSQL): ctxpats
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => 'SELECT DISTINCT `Context` AS src, `Pattern` AS tgt
                                                FROM `nssharedctxpats`
                                                WHERE `Context` IS NOT NULL AND `Pattern` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'concepts'
                          // Normalized interface expression (== expressionSQL): ctxcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => 'SELECT DISTINCT `Context` AS src, `Concept` AS tgt
                                                FROM `nssharedctxcs`
                                                WHERE `Context` IS NOT NULL AND `Concept` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'ISA-relations'
                          // Normalized interface expression (== expressionSQL): ctxpats;ptgns
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Gen'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ctxpats\",\"ptgns\"] */
                                                
                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`Gen` AS tgt
                                                FROM `nssharedctxpats` AS ECps0,
                                                     `nssharedptgns` AS ECps1
                                                WHERE ECps0.`Pattern`=ECps1.`Pattern`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relations'
                          // Normalized interface expression (== expressionSQL): ctxpats;ptdcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ctxpats\",\"ptdcs\"] */
                                                
                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`Declaration` AS tgt
                                                FROM `nssharedctxpats` AS ECps0,
                                                     `nssharedptdcs` AS ECps1
                                                WHERE ECps0.`Pattern`=ECps1.`Pattern`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relation'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Declaration'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Declaration` AS tgt
                                                              FROM `nssharedDeclaration`
                                                              WHERE `Declaration` IS NOT NULL AND `Declaration` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'with properties'
                                        // Normalized interface expression (== expressionSQL): decprps;declaredthrough
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Property'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"decprps\",\"declaredthrough\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`decprps` AS src, ECps1.`Property` AS tgt
                                                              FROM `nssharedADLid` AS ECps0,
                                                                   `nsshareddeclaredthrough` AS ECps1
                                                              WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'RULEs'
                          // Normalized interface expression (== expressionSQL): ctxpats;ptrls;(I[Rule]/\\-I[PropertyRule])
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Context'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ctxpats\",\"ptrls\",\"I[Rule]/\\\\-I[PropertyRule]\"] */
                                                
                                                SELECT DISTINCT ECps0.`Context` AS src, ECps2.`rrnm1` AS tgt
                                                FROM `nssharedctxpats` AS ECps0,
                                                     `nssharedptrls` AS ECps1,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I[Rule]\",\"-I[PropertyRule]\"] */
                                                       SELECT DISTINCT isect0.`rrnm`, isect0.`rrnm1`
                                                       FROM 
                                                            ( /* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `rrnm`, `rrnm` AS `rrnm1`
                                                              FROM `nssharedADLid`
                                                              WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL
                                                            ) AS isect0
                                                       WHERE NOT EXISTS (SELECT * FROM 
                                                                        ( /* case: ETyp x _
                                                                             ETyp ( \"I\" ) _ */
                                                                          SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                                                          FROM `nssharedADLid`
                                                                          WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                                                        ) AS cp
                                                                   WHERE isect0.`rrnm`=cp.`PropertyRule` AND isect0.`rrnm1`=cp.`PropertyRule1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL
                                                     ) AS ECps2
                                                WHERE ECps0.`Pattern`=ECps1.`Pattern`
                                                  AND ECps1.`Rule`=ECps2.`rrnm`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface PATTERN for role Student:
      'PATTERN' => 
      array ( 'name' => 'PATTERN'
            // Normalized interface expression (== expressionSQL): I[Pattern]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Pattern'
            , 'tgtConcept' => 'Pattern'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `ptnm` AS src, `ptnm` AS tgt
                                  FROM `nssharedConid`
                                  WHERE `ptnm` IS NOT NULL AND `ptnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'PURPOSEs'
                          // Normalized interface expression (== expressionSQL): ptxps
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Blob` AS tgt
                                                FROM `nssharedptxps`
                                                WHERE `Pattern` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'name'
                          // Normalized interface expression (== expressionSQL): ptnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Conid'
                          , 'expressionSQL' => 'SELECT DISTINCT `ptnm` AS src, `Conid` AS tgt
                                                FROM `nssharedConid`
                                                WHERE `ptnm` IS NOT NULL AND `Conid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'RULEs'
                          // Normalized interface expression (== expressionSQL): ptrls;(I[Rule]/\\-I[PropertyRule])
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"ptrls\",\"I[Rule]/\\\\-I[PropertyRule]\"] */
                                                
                                                SELECT DISTINCT ECps0.`Pattern` AS src, ECps1.`rrnm1` AS tgt
                                                FROM `nssharedptrls` AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I[Rule]\",\"-I[PropertyRule]\"] */
                                                       SELECT DISTINCT isect0.`rrnm`, isect0.`rrnm1`
                                                       FROM 
                                                            ( /* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `rrnm`, `rrnm` AS `rrnm1`
                                                              FROM `nssharedADLid`
                                                              WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL
                                                            ) AS isect0
                                                       WHERE NOT EXISTS (SELECT * FROM 
                                                                        ( /* case: ETyp x _
                                                                             ETyp ( \"I\" ) _ */
                                                                          SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                                                          FROM `nssharedADLid`
                                                                          WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                                                        ) AS cp
                                                                   WHERE isect0.`rrnm`=cp.`PropertyRule` AND isect0.`rrnm1`=cp.`PropertyRule1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`Rule`=ECps1.`rrnm`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'relations'
                          // Normalized interface expression (== expressionSQL): ptdcs
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Declaration` AS tgt
                                                FROM `nssharedptdcs`
                                                WHERE `Pattern` IS NOT NULL AND `Declaration` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relation'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Declaration'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Declaration` AS tgt
                                                              FROM `nssharedDeclaration`
                                                              WHERE `Declaration` IS NOT NULL AND `Declaration` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'with properties'
                                        // Normalized interface expression (== expressionSQL): decprps;declaredthrough
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Declaration'
                                        , 'tgtConcept' => 'Property'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"decprps\",\"declaredthrough\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`decprps` AS src, ECps1.`Property` AS tgt
                                                              FROM `nssharedADLid` AS ECps0,
                                                                   `nsshareddeclaredthrough` AS ECps1
                                                              WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'ISA-relations'
                          // Normalized interface expression (== expressionSQL): ptgns
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Gen'
                          , 'expressionSQL' => 'SELECT DISTINCT `Pattern` AS src, `Gen` AS tgt
                                                FROM `nssharedptgns`
                                                WHERE `Pattern` IS NOT NULL AND `Gen` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'diagram'
                          // Normalized interface expression (== expressionSQL): ptpic
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Pattern'
                          , 'tgtConcept' => 'Image'
                          , 'expressionSQL' => 'SELECT DISTINCT `ptnm` AS src, `ptpic` AS tgt
                                                FROM `nssharedConid`
                                                WHERE `ptnm` IS NOT NULL AND `ptpic` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface ISA-relation for role Student:
      'ISA-relation' => 
      array ( 'name' => 'ISA-relation'
            // Normalized interface expression (== expressionSQL): I[Gen]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Gen'
            , 'tgtConcept' => 'Gen'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Gen` AS src, `Gen` AS tgt
                                  FROM `nssharedGen`
                                  WHERE `Gen` IS NOT NULL AND `Gen` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'SPEC'
                          // Normalized interface expression (== expressionSQL): genspc
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Gen'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => 'SELECT DISTINCT `Gen` AS src, `genspc` AS tgt
                                                FROM `nssharedGen`
                                                WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'ISA'
                          // Normalized interface expression (== expressionSQL): gengen
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Gen'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => 'SELECT DISTINCT `Gen` AS src, `gengen` AS tgt
                                                FROM `nssharedGen`
                                                WHERE `Gen` IS NOT NULL AND `gengen` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'in PATTERN'
                          // Normalized interface expression (== expressionSQL): ptgns~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Gen'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Pattern` AS tgt, `Gen` AS src
                                                FROM `nssharedptgns`
                                                WHERE `Pattern` IS NOT NULL AND `Gen` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Concept for role Student:
      'Concept' => 
      array ( 'name' => 'Concept'
            // Normalized interface expression (== expressionSQL): I[Concept]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('AtomID', 'Atom')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Concept'
            , 'tgtConcept' => 'Concept'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `cptnm` AS src, `cptnm` AS tgt
                                  FROM `nssharedConid`
                                  WHERE `cptnm` IS NOT NULL AND `cptnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'PURPOSEs'
                          // Normalized interface expression (== expressionSQL): cptpurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Concept` AS src, `Blob` AS tgt
                                                FROM `nssharedcptpurpose`
                                                WHERE `Concept` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'CONCEPT definition'
                          // Normalized interface expression (== expressionSQL): cptdf
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Concept` AS src, `Blob` AS tgt
                                                FROM `nssharedcptdf`
                                                WHERE `Concept` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'name'
                          // Normalized interface expression (== expressionSQL): cptnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Conid'
                          , 'expressionSQL' => 'SELECT DISTINCT `cptnm` AS src, `Conid` AS tgt
                                                FROM `nssharedConid`
                                                WHERE `cptnm` IS NOT NULL AND `Conid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'POPULATION'
                          // Normalized interface expression (== expressionSQL): cptos
                          , 'relation' => 'cptos'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'AtomID'
                          , 'expressionSQL' => 'SELECT DISTINCT `Concept` AS src, `AtomID` AS tgt
                                                FROM `nssharedcptos`
                                                WHERE `Concept` IS NOT NULL AND `AtomID` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'atom'
                                        // Normalized interface expression (== expressionSQL): atomvalue
                                        , 'relation' => 'atomvalue'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'AtomID'
                                        , 'tgtConcept' => 'Atom'
                                        , 'expressionSQL' => 'SELECT DISTINCT `AtomID` AS src, `atomvalue` AS tgt
                                                              FROM `nssharedAtomID`
                                                              WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'POPULATION (through ISA)'
                          // Normalized interface expression (== expressionSQL): (genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen)~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                /* case: EUni es
                                                   EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS tgt, ECps1.`gengen` AS src
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `nssharedGen` AS ECps1
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS tgt, ECps3.`gengen` AS src
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `nssharedGen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `nssharedGen` AS ECps3
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS tgt, ECps5.`gengen` AS src
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `nssharedGen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `nssharedGen` AS ECps3,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps4,
                                                         `nssharedGen` AS ECps5
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                      AND ECps3.`gengen`=ECps4.`genspc`
                                                      AND ECps4.`Gen`=ECps5.`Gen`
                                                
                                                
                                                )'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'more specific concept'
                                        // Normalized interface expression (== expressionSQL): I
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Concept'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => 'SELECT DISTINCT `cptnm` AS src, `cptnm` AS tgt
                                                              FROM `nssharedConid`
                                                              WHERE `cptnm` IS NOT NULL AND `cptnm` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'atom'
                                        // Normalized interface expression (== expressionSQL): cptos;atomvalue
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Concept'
                                        , 'tgtConcept' => 'Atom'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"cptos\",\"atomvalue\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Concept` AS src, ECps1.`atomvalue` AS tgt
                                                              FROM `nssharedcptos` AS ECps0,
                                                                   `nssharedAtomID` AS ECps1
                                                              WHERE ECps0.`AtomID`=ECps1.`AtomID`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'more generic concepts'
                          // Normalized interface expression (== expressionSQL): genspc~;gengen \\/ genspc~;gengen;genspc~;gengen \\/ genspc~;gengen;genspc~;gengen;genspc~;gengen
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: EUni es
                                                   EUni [\"genspc~;gengen\",\"genspc~;gengen;genspc~;gengen\",\"genspc~;gengen;genspc~;gengen;genspc~;gengen\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS src, ECps1.`gengen` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `nssharedGen` AS ECps1
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS src, ECps3.`gengen` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `nssharedGen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `nssharedGen` AS ECps3
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"genspc~\",\"gengen\",\"genspc~\",\"gengen\",\"genspc~\",\"gengen\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`genspc` AS src, ECps5.`gengen` AS tgt
                                                    FROM 
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps0,
                                                         `nssharedGen` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps2,
                                                         `nssharedGen` AS ECps3,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `Gen`, `genspc`
                                                           FROM `nssharedGen`
                                                           WHERE `Gen` IS NOT NULL AND `genspc` IS NOT NULL
                                                         ) AS ECps4,
                                                         `nssharedGen` AS ECps5
                                                    WHERE ECps0.`Gen`=ECps1.`Gen`
                                                      AND ECps1.`gengen`=ECps2.`genspc`
                                                      AND ECps2.`Gen`=ECps3.`Gen`
                                                      AND ECps3.`gengen`=ECps4.`genspc`
                                                      AND ECps4.`Gen`=ECps5.`Gen`
                                                
                                                
                                                )'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'used in relations'
                          // Normalized interface expression (== expressionSQL): (decsgn;(src \\/ trg))~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Declaration'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                /* case: (ECps es), with two or more elements in es.
                                                   ECps [\"decsgn\",\"src \\\\/ trg\"] */
                                                
                                                SELECT DISTINCT ECps0.`Declaration` AS tgt, ECps1.`src`
                                                FROM `nssharedDeclaration` AS ECps0,
                                                     
                                                     ( /* case: EUni es
                                                          EUni [\"src\",\"trg\"] */
                                                       (SELECT DISTINCT `Sign`, `src`
                                                           FROM `nssharedSign`
                                                           WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                                       ) UNION (SELECT DISTINCT `Sign`, `trg` AS `src`
                                                           FROM `nssharedSign`
                                                           WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                                       
                                                       )
                                                     ) AS ECps1
                                                WHERE ECps0.`decsgn`=ECps1.`Sign`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'used in RULEs'
                          // Normalized interface expression (== expressionSQL): (relsgn;(src \\/ trg))~;(rrexp;rels)~;(I[Rule]/\\-I[PropertyRule])
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"(relsgn;(src \\\\/ trg))~\",\"(rrexp;rels)~\",\"I[Rule]/\\\\-I[PropertyRule]\"] */
                                                
                                                SELECT DISTINCT ECps0.`src`, ECps2.`rrnm1` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"relsgn\",\"src \\\\/ trg\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`Relation`, ECps1.`src`
                                                       FROM `nssharedRelation` AS ECps0,
                                                            
                                                            ( /* case: EUni es
                                                                 EUni [\"src\",\"trg\"] */
                                                              (SELECT DISTINCT `Sign`, `src`
                                                                  FROM `nssharedSign`
                                                                  WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL
                                                              ) UNION (SELECT DISTINCT `Sign`, `trg` AS `src`
                                                                  FROM `nssharedSign`
                                                                  WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL
                                                              
                                                              )
                                                            ) AS ECps1
                                                       WHERE ECps0.`relsgn`=ECps1.`Sign`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: EFlp x. */
                                                       /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"rrexp\",\"rels\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`rrnm`, ECps1.`Relation`
                                                       FROM `nssharedADLid` AS ECps0,
                                                            `nssharedrels` AS ECps1
                                                       WHERE ECps0.`rrexp`=ECps1.`ExpressionID`
                                                     ) AS ECps1,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I[Rule]\",\"-I[PropertyRule]\"] */
                                                       SELECT DISTINCT isect0.`rrnm`, isect0.`rrnm1`
                                                       FROM 
                                                            ( /* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `rrnm`, `rrnm` AS `rrnm1`
                                                              FROM `nssharedADLid`
                                                              WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL
                                                            ) AS isect0
                                                       WHERE NOT EXISTS (SELECT * FROM 
                                                                        ( /* case: ETyp x _
                                                                             ETyp ( \"I\" ) _ */
                                                                          SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                                                          FROM `nssharedADLid`
                                                                          WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                                                        ) AS cp
                                                                   WHERE isect0.`rrnm`=cp.`PropertyRule` AND isect0.`rrnm1`=cp.`PropertyRule1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL
                                                     ) AS ECps2
                                                WHERE ECps0.`Relation`=ECps1.`Relation`
                                                  AND ECps1.`rrnm`=ECps2.`rrnm`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'diagram'
                          // Normalized interface expression (== expressionSQL): cptpic
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Concept'
                          , 'tgtConcept' => 'Image'
                          , 'expressionSQL' => 'SELECT DISTINCT `cptnm` AS src, `cptpic` AS tgt
                                                FROM `nssharedConid`
                                                WHERE `cptnm` IS NOT NULL AND `cptpic` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Atom for role Student:
      'Atom' => 
      array ( 'name' => 'Atom'
            // Normalized interface expression (== expressionSQL): I[Atom];atomvalue~
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('Concept')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Atom'
            , 'tgtConcept' => 'AtomID'
            , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                     ECps [\"I[Atom]\",\"atomvalue~\"] */
                                  
                                  SELECT DISTINCT ECps0.`Atom` AS src, ECps1.`AtomID` AS tgt
                                  FROM 
                                       ( /* case: ETyp x _
                                            ETyp ( \"I\" ) _ */
                                         SELECT DISTINCT `Atom`, `Atom` AS `Atom1`
                                         FROM `nssharedAtom`
                                         WHERE `Atom` IS NOT NULL AND `Atom` IS NOT NULL
                                       ) AS ECps0,
                                       
                                       ( /* case: EFlp x. */
                                         SELECT DISTINCT `AtomID`, `atomvalue`
                                         FROM `nssharedAtomID`
                                         WHERE `AtomID` IS NOT NULL AND `atomvalue` IS NOT NULL
                                       ) AS ECps1
                                  WHERE ECps0.`Atom1`=ECps1.`atomvalue`'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'atom'
                          // Normalized interface expression (== expressionSQL): I
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'AtomID'
                          , 'tgtConcept' => 'AtomID'
                          , 'expressionSQL' => 'SELECT DISTINCT `AtomID` AS src, `AtomID` AS tgt
                                                FROM `nssharedAtomID`
                                                WHERE `AtomID` IS NOT NULL AND `AtomID` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'in POPULATION of (click Edit to change)'
                          // Normalized interface expression (== expressionSQL): cptos~
                          , 'relation' => 'cptos'
                          , 'relationIsFlipped' => true
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'AtomID'
                          , 'tgtConcept' => 'Concept'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Concept` AS tgt, `AtomID` AS src
                                                FROM `nssharedcptos`
                                                WHERE `Concept` IS NOT NULL AND `AtomID` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Relation for role Student:
      'Relation' => 
      array ( 'name' => 'Relation'
            // Normalized interface expression (== expressionSQL): I[Declaration]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ('PairID', 'AtomID', 'AtomID')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Declaration'
            , 'tgtConcept' => 'Declaration'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `Declaration` AS src, `Declaration` AS tgt
                                  FROM `nssharedDeclaration`
                                  WHERE `Declaration` IS NOT NULL AND `Declaration` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'PURPOSEs'
                          // Normalized interface expression (== expressionSQL): decpurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Blob` AS tgt
                                                FROM `nsshareddecpurpose`
                                                WHERE `Declaration` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'MEANING'
                          // Normalized interface expression (== expressionSQL): decmean
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `Blob` AS tgt
                                                FROM `nsshareddecmean`
                                                WHERE `Declaration` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'example of basic sentence'
                          // Normalized interface expression (== expressionSQL): decexample
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'PragmaSentence'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `PragmaSentence` AS tgt
                                                FROM `nsshareddecexample`
                                                WHERE `Declaration` IS NOT NULL AND `PragmaSentence` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'name'
                          // Normalized interface expression (== expressionSQL): decnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Varid'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decnm` AS tgt
                                                FROM `nssharedDeclaration`
                                                WHERE `Declaration` IS NOT NULL AND `decnm` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'type'
                          // Normalized interface expression (== expressionSQL): decsgn
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Sign'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `decsgn` AS tgt
                                                FROM `nssharedDeclaration`
                                                WHERE `Declaration` IS NOT NULL AND `decsgn` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'source'
                                        // Normalized interface expression (== expressionSQL): src
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Sign'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Sign` AS src, `src` AS tgt
                                                              FROM `nssharedSign`
                                                              WHERE `Sign` IS NOT NULL AND `src` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'target'
                                        // Normalized interface expression (== expressionSQL): trg
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Sign'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Sign` AS src, `trg` AS tgt
                                                              FROM `nssharedSign`
                                                              WHERE `Sign` IS NOT NULL AND `trg` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'properties'
                          // Normalized interface expression (== expressionSQL): decprps;declaredthrough
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Property'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"decprps\",\"declaredthrough\"] */
                                                
                                                SELECT DISTINCT ECps0.`decprps` AS src, ECps1.`Property` AS tgt
                                                FROM `nssharedADLid` AS ECps0,
                                                     `nsshareddeclaredthrough` AS ECps1
                                                WHERE ECps0.`PropertyRule`=ECps1.`PropertyRule`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'from PATTERN'
                          // Normalized interface expression (== expressionSQL): ptdcs~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Pattern` AS tgt, `Declaration` AS src
                                                FROM `nssharedptdcs`
                                                WHERE `Pattern` IS NOT NULL AND `Declaration` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'POPULATION'
                          // Normalized interface expression (== expressionSQL): decpopu
                          , 'relation' => 'decpopu'
                          , 'relationIsFlipped' => false
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'PairID'
                          , 'expressionSQL' => 'SELECT DISTINCT `Declaration` AS src, `PairID` AS tgt
                                                FROM `nsshareddecpopu`
                                                WHERE `Declaration` IS NOT NULL AND `PairID` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'source'
                                        // Normalized interface expression (== expressionSQL): left
                                        , 'relation' => 'left'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'PairID'
                                        , 'tgtConcept' => 'AtomID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `PairID` AS src, `left` AS tgt
                                                              FROM `nssharedPairID`
                                                              WHERE `PairID` IS NOT NULL AND `left` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'target'
                                        // Normalized interface expression (== expressionSQL): right
                                        , 'relation' => 'right'
                                        , 'relationIsFlipped' => false
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'PairID'
                                        , 'tgtConcept' => 'AtomID'
                                        , 'expressionSQL' => 'SELECT DISTINCT `PairID` AS src, `right` AS tgt
                                                              FROM `nssharedPairID`
                                                              WHERE `PairID` IS NOT NULL AND `right` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'used in RULEs'
                          // Normalized interface expression (== expressionSQL): (rrexp;rels;reldcl)~;(I[Rule]/\\-I[PropertyRule])
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Declaration'
                          , 'tgtConcept' => 'Rule'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"(rrexp;rels;reldcl)~\",\"I[Rule]/\\\\-I[PropertyRule]\"] */
                                                
                                                SELECT DISTINCT ECps0.`reldcl` AS src, ECps1.`rrnm1` AS tgt
                                                FROM 
                                                     ( /* case: EFlp x. */
                                                       /* case: (ECps es), with two or more elements in es.
                                                          ECps [\"rrexp\",\"rels\",\"reldcl\"] */
                                                       
                                                       SELECT DISTINCT ECps0.`rrnm`, ECps2.`reldcl`
                                                       FROM `nssharedADLid` AS ECps0,
                                                            `nssharedrels` AS ECps1,
                                                            `nssharedRelation` AS ECps2
                                                       WHERE ECps0.`rrexp`=ECps1.`ExpressionID`
                                                         AND ECps1.`Relation`=ECps2.`Relation`
                                                     ) AS ECps0,
                                                     
                                                     ( /* case: (EIsc lst@(_:_:_))
                                                          EIsc [\"I[Rule]\",\"-I[PropertyRule]\"] */
                                                       SELECT DISTINCT isect0.`rrnm`, isect0.`rrnm1`
                                                       FROM 
                                                            ( /* case: ETyp x _
                                                                 ETyp ( \"I\" ) _ */
                                                              SELECT DISTINCT `rrnm`, `rrnm` AS `rrnm1`
                                                              FROM `nssharedADLid`
                                                              WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL
                                                            ) AS isect0
                                                       WHERE NOT EXISTS (SELECT * FROM 
                                                                        ( /* case: ETyp x _
                                                                             ETyp ( \"I\" ) _ */
                                                                          SELECT DISTINCT `PropertyRule`, `PropertyRule` AS `PropertyRule1`
                                                                          FROM `nssharedADLid`
                                                                          WHERE `PropertyRule` IS NOT NULL AND `PropertyRule` IS NOT NULL
                                                                        ) AS cp
                                                                   WHERE isect0.`rrnm`=cp.`PropertyRule` AND isect0.`rrnm1`=cp.`PropertyRule1`) AND isect0.`rrnm` IS NOT NULL AND isect0.`rrnm1` IS NOT NULL
                                                     ) AS ECps1
                                                WHERE ECps0.`rrnm`=ECps1.`rrnm`'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface RULE for role Student:
      'RULE' => 
      array ( 'name' => 'RULE'
            // Normalized interface expression (== expressionSQL): I[Rule]
            , 'interfaceRoles' => array ('Student')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Rule'
            , 'tgtConcept' => 'Rule'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  SELECT DISTINCT `rrnm` AS src, `rrnm` AS tgt
                                  FROM `nssharedADLid`
                                  WHERE `rrnm` IS NOT NULL AND `rrnm` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'PURPOSEs'
                          // Normalized interface expression (== expressionSQL): rrpurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Rule` AS src, `Blob` AS tgt
                                                FROM `nssharedrrpurpose`
                                                WHERE `Rule` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'MEANING'
                          // Normalized interface expression (== expressionSQL): rrmean
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Blob'
                          , 'expressionSQL' => 'SELECT DISTINCT `Rule` AS src, `Blob` AS tgt
                                                FROM `nssharedrrmean`
                                                WHERE `Rule` IS NOT NULL AND `Blob` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'name'
                          // Normalized interface expression (== expressionSQL): rrnm
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'ADLid'
                          , 'expressionSQL' => 'SELECT DISTINCT `rrnm` AS src, `ADLid` AS tgt
                                                FROM `nssharedADLid`
                                                WHERE `rrnm` IS NOT NULL AND `ADLid` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'assertion'
                          // Normalized interface expression (== expressionSQL): rrexp
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'ExpressionID'
                          , 'expressionSQL' => 'SELECT DISTINCT `rrnm` AS src, `rrexp` AS tgt
                                                FROM `nssharedADLid`
                                                WHERE `rrnm` IS NOT NULL AND `rrexp` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'uses'
                          // Normalized interface expression (== expressionSQL): rrexp;rels
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Relation'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   ECps [\"rrexp\",\"rels\"] */
                                                
                                                SELECT DISTINCT ECps0.`rrnm` AS src, ECps1.`Relation` AS tgt
                                                FROM `nssharedADLid` AS ECps0,
                                                     `nssharedrels` AS ECps1
                                                WHERE ECps0.`rrexp`=ECps1.`ExpressionID`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'relation'
                                        // Normalized interface expression (== expressionSQL): reldcl
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Declaration'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Relation` AS src, `reldcl` AS tgt
                                                              FROM `nssharedRelation`
                                                              WHERE `Relation` IS NOT NULL AND `reldcl` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'with properties'
                                        // Normalized interface expression (== expressionSQL): reldcl;decprps;declaredthrough
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Property'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"reldcl\",\"decprps\",\"declaredthrough\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Relation` AS src, ECps2.`Property` AS tgt
                                                              FROM `nssharedRelation` AS ECps0,
                                                                   `nssharedADLid` AS ECps1,
                                                                   `nsshareddeclaredthrough` AS ECps2
                                                              WHERE ECps0.`reldcl`=ECps1.`decprps`
                                                                AND ECps1.`PropertyRule`=ECps2.`PropertyRule`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'source'
                                        // Normalized interface expression (== expressionSQL): relsgn;src
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"relsgn\",\"src\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Relation` AS src, ECps1.`src` AS tgt
                                                              FROM `nssharedRelation` AS ECps0,
                                                                   `nssharedSign` AS ECps1
                                                              WHERE ECps0.`relsgn`=ECps1.`Sign`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'target'
                                        // Normalized interface expression (== expressionSQL): relsgn;trg
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Relation'
                                        , 'tgtConcept' => 'Concept'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 ECps [\"relsgn\",\"trg\"] */
                                                              
                                                              SELECT DISTINCT ECps0.`Relation` AS src, ECps1.`trg` AS tgt
                                                              FROM `nssharedRelation` AS ECps0,
                                                                   `nssharedSign` AS ECps1
                                                              WHERE ECps0.`relsgn`=ECps1.`Sign`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'in PATTERN'
                          // Normalized interface expression (== expressionSQL): ptrls~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Pattern'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Pattern` AS tgt, `Rule` AS src
                                                FROM `nssharedptrls`
                                                WHERE `Pattern` IS NOT NULL AND `Rule` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'diagram'
                          // Normalized interface expression (== expressionSQL): rrpic
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Rule'
                          , 'tgtConcept' => 'Image'
                          , 'expressionSQL' => 'SELECT DISTINCT `rrnm` AS src, `rrpic` AS tgt
                                                FROM `nssharedADLid`
                                                WHERE `rrnm` IS NOT NULL AND `rrpic` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Files for role Admin:
      'Files' => 
      array ( 'name' => 'Files'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ('Admin')
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* case: ETyp x _
                                     ETyp ( \"I\" ) _ */
                                  /* I[ONE] */
                                  /* case: (ERel (V (Sign s t)))
                                     ERel [ \"V[ONE]\" ] */
                                  SELECT DISTINCT 1 AS src, 1 AS tgt
                                  FROM (SELECT 1) AS csnd'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'loaded files'
                          // Normalized interface expression (== expressionSQL): V[ONE*File];sourcefile~;sourcefile \\/ V[ONE*File];parseerror;parseerror~ \\/ V[ONE*File];typeerror;typeerror~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'File'
                          , 'expressionSQL' => '/* case: EUni es
                                                   EUni [\"V[ONE*File];sourcefile~;sourcefile\",\"V[ONE*File];parseerror;parseerror~\",\"V[ONE*File];typeerror;typeerror~\"] */
                                                (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"V[ONE*File]\",\"sourcefile~\",\"sourcefile\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`sourcefile` AS tgt
                                                    FROM 
                                                         ( /* case: ETyp x _
                                                              ETyp ( \"V\" ) _ */
                                                           /* case: (ERel (V (Sign s t)))
                                                              ERel [ \"V[ONE*File]\" ] */
                                                           SELECT DISTINCT 1 AS `I[ONE]`, `File`.`File`
                                                           FROM `nssharedFile` AS `File`
                                                         ) AS ECps0,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `ctxnm`, `sourcefile`
                                                           FROM `nssharedConid`
                                                           WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL
                                                         ) AS ECps1,
                                                         `nssharedConid` AS ECps2
                                                    WHERE ECps0.`File`=ECps1.`sourcefile`
                                                      AND ECps1.`ctxnm`=ECps2.`ctxnm`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"V[ONE*File]\",\"parseerror\",\"parseerror~\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`File` AS tgt
                                                    FROM 
                                                         ( /* case: ETyp x _
                                                              ETyp ( \"V\" ) _ */
                                                           /* case: (ERel (V (Sign s t)))
                                                              ERel [ \"V[ONE*File]\" ] */
                                                           SELECT DISTINCT 1 AS `I[ONE]`, `File`.`File`
                                                           FROM `nssharedFile` AS `File`
                                                         ) AS ECps0,
                                                         `nssharedFile` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `File`, `parseerror`
                                                           FROM `nssharedFile`
                                                           WHERE `File` IS NOT NULL AND `parseerror` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`File`=ECps1.`File`
                                                      AND ECps1.`parseerror`=ECps2.`parseerror`
                                                ) UNION (/* case: (ECps es), with two or more elements in es.
                                                       ECps [\"V[ONE*File]\",\"typeerror\",\"typeerror~\"] */
                                                    
                                                    SELECT DISTINCT ECps0.`I[ONE]` AS src, ECps2.`File` AS tgt
                                                    FROM 
                                                         ( /* case: ETyp x _
                                                              ETyp ( \"V\" ) _ */
                                                           /* case: (ERel (V (Sign s t)))
                                                              ERel [ \"V[ONE*File]\" ] */
                                                           SELECT DISTINCT 1 AS `I[ONE]`, `File`.`File`
                                                           FROM `nssharedFile` AS `File`
                                                         ) AS ECps0,
                                                         `nssharedtypeerror2` AS ECps1,
                                                         
                                                         ( /* case: EFlp x. */
                                                           SELECT DISTINCT `File`, `TypeError`
                                                           FROM `nssharedtypeerror2`
                                                           WHERE `File` IS NOT NULL AND `TypeError` IS NOT NULL
                                                         ) AS ECps2
                                                    WHERE ECps0.`File`=ECps1.`File`
                                                      AND ECps1.`TypeError`=ECps2.`TypeError`
                                                
                                                
                                                )'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'name'
                                        // Normalized interface expression (== expressionSQL): filename
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'FileName'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filename` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `filename` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'dir'
                                        // Normalized interface expression (== expressionSQL): filepath
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'FilePath'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filepath` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `filepath` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'created at'
                                        // Normalized interface expression (== expressionSQL): filetime
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'CalendarTime'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `filetime` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `filetime` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'first loaded with'
                                        // Normalized interface expression (== expressionSQL): firstloadedwith
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'AdlFile'
                                        , 'tgtConcept' => 'AdlVersion'
                                        , 'expressionSQL' => 'SELECT DISTINCT `AdlFile` AS src, `firstloadedwith` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `AdlFile` IS NOT NULL AND `firstloadedwith` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'syntax error'
                                        // Normalized interface expression (== expressionSQL): parseerror
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'ParseError'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `parseerror` AS tgt
                                                              FROM `nssharedFile`
                                                              WHERE `File` IS NOT NULL AND `parseerror` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'act'
                                                      // Normalized interface expression (== expressionSQL): pe_action
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'ParseError'
                                                      , 'tgtConcept' => 'String'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ParseError` AS src, `pe_action` AS tgt
                                                                            FROM `nssharedParseError`
                                                                            WHERE `ParseError` IS NOT NULL AND `pe_action` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'pos'
                                                      // Normalized interface expression (== expressionSQL): pe_position
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'ParseError'
                                                      , 'tgtConcept' => 'String'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ParseError` AS src, `pe_position` AS tgt
                                                                            FROM `nssharedParseError`
                                                                            WHERE `ParseError` IS NOT NULL AND `pe_position` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'exp'
                                                      // Normalized interface expression (== expressionSQL): pe_expecting
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'ParseError'
                                                      , 'tgtConcept' => 'String'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ParseError` AS src, `pe_expecting` AS tgt
                                                                            FROM `nssharedParseError`
                                                                            WHERE `ParseError` IS NOT NULL AND `pe_expecting` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'type error'
                                        // Normalized interface expression (== expressionSQL): typeerror
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'File'
                                        , 'tgtConcept' => 'TypeError'
                                        , 'expressionSQL' => 'SELECT DISTINCT `File` AS src, `TypeError` AS tgt
                                                              FROM `nssharedtypeerror2`
                                                              WHERE `File` IS NOT NULL AND `TypeError` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'msg'
                                                      // Normalized interface expression (== expressionSQL): te_message
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'TypeError'
                                                      , 'tgtConcept' => 'ErrorMessage'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `TypeError` AS src, `te_message` AS tgt
                                                                            FROM `nssharedTypeError1`
                                                                            WHERE `TypeError` IS NOT NULL AND `te_message` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                , array ( 'name' => 'context'
                                        // Normalized interface expression (== expressionSQL): sourcefile~
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'AdlFile'
                                        , 'tgtConcept' => 'Context'
                                        , 'expressionSQL' => '/* case: EFlp x. */
                                                              SELECT DISTINCT `ctxnm` AS tgt, `sourcefile` AS src
                                                              FROM `nssharedConid`
                                                              WHERE `ctxnm` IS NOT NULL AND `sourcefile` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'name'
                                                      // Normalized interface expression (== expressionSQL): ctxnm
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Conid'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `Conid` AS tgt
                                                                            FROM `nssharedConid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `Conid` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'source files'
                                                      // Normalized interface expression (== expressionSQL): sourcefile;filename \\/ includes;filename
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'FileName'
                                                      , 'expressionSQL' => '/* case: EUni es
                                                                               EUni [\"sourcefile;filename\",\"includes;filename\"] */
                                                                            (/* case: (ECps es), with two or more elements in es.
                                                                                   ECps [\"sourcefile\",\"filename\"] */
                                                                                
                                                                                SELECT DISTINCT ECps0.`ctxnm` AS src, ECps1.`filename` AS tgt
                                                                                FROM `nssharedConid` AS ECps0,
                                                                                     `nssharedFile` AS ECps1
                                                                                WHERE ECps0.`sourcefile`=ECps1.`File`
                                                                            ) UNION (/* case: (ECps es), with two or more elements in es.
                                                                                   ECps [\"includes\",\"filename\"] */
                                                                                
                                                                                SELECT DISTINCT ECps0.`Context` AS src, ECps1.`filename` AS tgt
                                                                                FROM `nssharedincludes` AS ECps0,
                                                                                     `nssharedFile` AS ECps1
                                                                                WHERE ECps0.`File`=ECps1.`File`
                                                                            
                                                                            )'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'number of rules'
                                                      // Normalized interface expression (== expressionSQL): countrules
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Int'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countrules` AS tgt
                                                                            FROM `nssharedConid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `countrules` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'number of declarations'
                                                      // Normalized interface expression (== expressionSQL): countdecls
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Int'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countdecls` AS tgt
                                                                            FROM `nssharedConid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `countdecls` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'number of concepts'
                                                      // Normalized interface expression (== expressionSQL): countcpts
                                                      , 'relation' => ''
                                                      , 'relationIsFlipped' => ''
                                                      , 'srcConcept' => 'Context'
                                                      , 'tgtConcept' => 'Int'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `ctxnm` AS src, `countcpts` AS tgt
                                                                            FROM `nssharedConid`
                                                                            WHERE `ctxnm` IS NOT NULL AND `countcpts` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  )
            )
    );
?>
