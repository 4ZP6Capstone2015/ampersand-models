CONTEXT Atlas
----------------------------------------------------------------------
-- SJ/????????: Eerste versie
-- RJ/20100131: Pattern ServiceRBAC toegevoegd, alsmede her en der kommentaar
----------------------------------------------------------------------
EXPLAIN PATTERN ServiceRBAC IN DUTCH REF ""
{+ Dit pattern bestaat om het aantal services dat kan worden aangeroepen te begrenzen,
afhankelijk van de rol. +}

PATTERN ServiceRBAC -- WIJZIGER: rieks.joosten@tno.nl
-- Session stuff
sessionuser :: Session * User [UNI] PRAGMA "" " is (the context of) the communication (channel) with ".
EXPLANATION "For all sorts of compliance purposes, it is nice to know that (at most) one person is somewhere at the other end of the communications channel that the service is exchanging messages (clicks) with.".

{- Er is een mogelijkheid voor KEUZE
- ofwel we gebruiken rollen om het AANROEPEN van een service toe te staan.
  In dit geval dienen (menu)rollen er vooral toe om het menu van Buttons/Services
  uit te kunnen rekenen die vanuit een Call aangeroepen kunnen worden.
- ofwel we gebruiken rollen om het UITVOEREN van een service toe te staan.
  In dit geval dienen (exec)rollen er vooral toe om bij de aanroep van een Call
  na te kunnen gaan of (de body van) de Call wel echt uitgevoerd mag worden.
Beiden zijn relevant. Ten eerste in cloud-computing, waar een Call kan worden
gedaan naar een Service die ergens in Verwegistan zit. Maar ook is het relevant
vanuit business perspectief, als Services door verschillende Domeinen worden
beheerd, ge-owned, betaald, e.d. - Zie het PNP2008 project.
-}

performed[Call*Session]~; service |- sessionuser; assigned~; def
EXPLANATION "If a call that instantiates a given service is performed in a session, the sessionuser must be assigned a role that permits execution of said service."

Vanuit een aanroepende service kan het nuttig zijn om het aanroepen van services te begrenzen. 
-- Definetime relations for Menu roles:
definedIn :: MenuRole -> Service PRAGMA "" " is defined within ".
allows    :: MenuRole *  Button  PRAGMA "" " allows " " to be used, i.e. the service, that is associated with said button to be called".
assigned  :: MenuRole *  User    PRAGMA "" " has been assigned to ".
allows~; definedIn |- action EXPLANATION "Roles that are defined in a Service can only affect buttons that have been defined in the same Service."

-- Runtime relations for Menu roles:
menu :: Call * Button PRAGMA "Within " ", the user can click ".
menu |- service; action~ EXPLANATION "Within a service call, the menu can only consist of buttons that have been defined in the Service that the call instantiates."

  iscalledby :: Call * Call [UNI] PRAGMA "" " has been triggered/started by ".
-- RJ: onderstaande regel moet regel "click;action;service~;performed |- performed" vervangen uit pattern CompileUnits
  iscalledby; performed |- performed
  EXPLANATION "All service calls that are started from a specific service call, execute in the same session."

iscalledby |- service; action~; menu~
EXPLANATION "If call 'callee' (of type 'calleeservice') is called by call 'caller' (of type 'callerservice', then calleeservice must have appeared in the servicemenu of caller."

menu[Call*Button] = service; action~ /\ performs; sessionuser; assigned~; allows
EXPLANATION "Clicking on a  button is only allowed for users that have (at least) one role that allows for this."

ENDPATTERN
----------------------------------------------------------------------
PATTERN Concepts -- MODIFIER stef.joosten@ou.nl
CONCEPT Atom "A string literal"
CONCEPT Concept "A set of atoms"
 type :: Atom -> Concept PRAGMA "" " has " " as its type".
 type = elem;pop~
  EXPLANATION "Relation 'type' corresponds to the element-of relation in set theory. Every atom has a type, which is a concept in whose population the atom occurs."
 left  :: Pair -> Atom  PRAGMA "" " has " " as its left atom".  -- Empty Relation
 right :: Pair -> Atom  PRAGMA "" " has " " as its right atom".  -- Empty Relation

-- KEY pairs: Pair(l:left,r:right)
 src :: Pair -> Concept PRAGMA "" " has " " as its source".
 left |- src;pop;elem~
  EXPLANATION "The left atom of a pair is in the set that corresponds to the source concept of that pair."
 trg :: Pair -> Concept PRAGMA "" " has " " as its target".
 right |- trg;pop;elem~
  EXPLANATION "The right atom of a pair is in the set that corresponds to the target concept of that pair."
 left~;src = type
  EXPLANATION "The type of the left atom of a pair is the src of that pair."
 right~;trg = type
  EXPLANATION "The type of the right atom of a pair is the trg of that pair."
 pop :: Concept -> Set PRAGMA "" " has " ", which contains its population"
 {- INSCOPE Test -}
   = [ ("Atom", "Atoms")
     ; ("Concept", "Concepts")
     ; ("Context", "Contexts")
     ; ("Identifier", "Identifiers")
     ; ("Pair", "Pairs")
     ; ("Pattern", "Patterns")
     ; ("Relation", "Relations")
     ; ("Rule", "Rules")
     ; ("Set", "Sets")
     ; ("Declaration", "Declarations")
     ; ("Valuation", "Valuations")
     ].
 elem :: Atom * Set PRAGMA "Atom " " is an element of set ".
ENDPATTERN

POPULATION imports[Service * Pattern] {- INSCOPE Test -} CONTAINS
    [ ("RAP", "Sets")
    ; ("RAP", "Concepts")
    ; ("RAP", "Rules")
    ; ("RAP", "Relations")
    ; ("RAP", "Valuations")
    ; ("RAP", "Patterns")
    ]

PATTERN CompileUnit -- MODIFIER stef.joosten@ou.nl
-- RJ: EXPLANATION "The intention of CompileUnits is to regulate the 'traffic' between database and compiler. Basically, a CompileUnit is a text that (1) can be compiled and (2) may lead to an 'insert' in the repository."

 GEN Pattern ISA CompileUnit
 GEN Service ISA CompileUnit
 GEN Session ISA Call
 definedIn :: Service * Service [INJ] PRAGMA "" " is defined in ".
 definedIn :: Service * Pattern [INJ] PRAGMA "" " is defined in ".
 imports :: Service * Pattern [TOT] PRAGMA "" " imports ".

 definedIn :: Rule -> Pattern PRAGMA "" " is defined in "
  = [ ("elem;subset* -: elem", "Sets")
    ; ("isa* -: pop;subset*;pop~", "Sets")
    ; ("type = elem;pop~", "Concepts")
    ; ("right;right~/\\left;left~ = I", "Concepts")
    ; ("left -: src;pop;elem~", "Concepts")
    ; ("right -: trg;pop;elem~", "Concepts")
    ; ("appliesIn = definedIn;uses~", "Rules")
    ; ("appliesIn;specializes*~ -: appliesIn", "Rules")
    ; ("in;appliesIn -: sign[Relation*Declaration]~;in", "Rules")
    ; ("in;sign -: src;source~/\\trg;target~", "Relations")
    ; ("sign;sign~/\\in~;in = I[Relation]", "Relations")
    ; ("in;sub* -: in", "Relations")
    ; ("I = name;name~/\\source;source~/\\target;target~", "Relations")
    ; ("sub* = sign;sub*;sign~/\\in;specializes*;in~", "Relations")
    ; ("in~;val -: val;in~", "Valuations")
    ; ("in;val~;appliesIn -: in;in", "Valuations")
    ; ("definedIn = sign~;in;definedIn", "Patterns")
    ; ("I = definedIn~;definedIn[Rule*Pattern]", "Patterns")
    ; ("in~;sign[Relation*Declaration] -: uses;definedIn~", "Patterns")
    ; ("in;specializes* -: in", "Patterns")
    ; ("specializes*;uses -: uses", "Patterns")
    ; ("scope = in;specializes*", "Patterns")
    ].
 appliesIn :: Rule * Service PRAGMA "" " applies in " "".
 --appliesIn is a closure, definedIn[Service*Service] and imports are not
 appliesIn = definedIn[Rule*Pattern];imports~ \/ appliesIn;definedIn~
EXPLANATION "Rules are defined in a pattern. When that pattern is imported in a service, all rules of that pattern apply within the service and its subservices."
 definedIn -| imports;definedIn~
-- RJ: Als dezelfde naam voor meerdere relaties wordt gebruikt, komt het de leesbaarheid ten goede om her en der concepten bij te noteren. De compiler heeft dat dan misschien niet nodig, maar voor mensen die van dit soort regels chocola proberen te maken is het dan makkelijker, Waarom zouden we het elkaar niet zo eenvoudig mogelijk maken?
  EXPLANATION "A service s that is defined in a pattern, which is imported in another service s', is considered to be defined in s'."

-- RJ: Hier zou het Service/Call/Button pattern moeten beginnen 
-- RJ: Ik ben niet zo blij met de naam 'Button', omdat deze andere beelden suggereert dan die welke je met 'action', 'service', 'call' e.d. oproept.
 action :: Button -> Service PRAGMA "" " is available in "
  EXPLANATION "A service comes with a number of buttons that allow navigation to other services. So, a service may have any number of buttons.".
-- RJ: Ik vraag me af of 'click' wel TOT moet zijn. Immers, van welke Button komt de 'buitenste' Call?
 click :: Call -> Button PRAGMA "" " has been made by clicking "
  EXPLANATION "A service call is made by clicking a specific button.".
 calls  :: Button -> Service PRAGMA "" " calls "
  EXPLANATION "Each button represents a call to a specific service.".
-- RJ: Welke use-case motiveert dat in onderstaande regel een '|-' wordt gebruikt in plaats van een '='?
 click;calls |- service
  EXPLANATION "To click on a button means to call the service that is attached to that button."
-- RJ: Wat (o.a.) ontbreekt is hoe je van het Service-atoom
 performed :: Call -> Session PRAGMA "" " is performed by "
  EXPLANATION "A service call is made by clicking a specific button.".
-- RJ: Onderstaande regel is fout. Er staat namelijk dat ALLE instanties van die ene Service die door het clicken op een button wordt aangewezen, in dezelfde sessie worden uitgevoerd. Een verbeterde versie hiervan staat in pattern ServiceRBAC. Deze kan dus weg.
 click;action;service~;performed |- performed
  EXPLANATION "All actions taken in a service are performed by the same session that performs the service call by which these actions are called. Formulated differently: Any service call that is made by clicking a button from within a service s is performed by the same session as s."
-- RJ: Hier zou het Service/Call/Button pattern moeten eindigen
 service :: Call -> Service PRAGMA "" " is a call to "
  EXPLANATION "Each service call is made to a specific service.".
 ctxType :: Service -> Concept PRAGMA "" " can be called on instances of ".
 self :: Call -> Atom PRAGMA "" " has " " as its identity atom"
  EXPLANATION "Each service call operates on a particular atom.".

 RULE selfObject MAINTAINS service;ctxType |- self;type
  EXPLANATION "A service call has an atom called S (self) that has the same type as the service."
ENDPATTERN

PATTERN Relations -- MODIFIER stef.joosten@ou.nl
 source :: Relation -> Concept PRAGMA "Relation " " has " " as its source".
 target :: Relation -> Concept PRAGMA "Relation " " has " " as its target".
ENDPATTERN

PATTERN "Service Structure" -- MODIFIER stef.joosten@ou.nl and rieks.joosten@tno.nl
  root :: Service -> Concept {-PRAGMA "(Service)Calls of type " " are defined to act on atoms that are elements of" -}.
  type :: Call -> Service.
  --TODO -> how to cope with duplicate declarations and self-contained patterns
  --I cannot just ignore one, because the same signature may be coincidential, or there may be differences in population or properties. Lex prefers messages telling the user that one has been ignored even in case of differences.
  --Also defined in Patttern Concepts -> type :: Atom -> Concept PRAGMA "" " has " " as its type".
ENDPATTERN

PATTERN "Service Semantics" -- MODIFIER stef.joosten@ou.nl
  call :: Call -> Atom {- PRAGMA "" " operates based on data that is related to " -}.
  mult :: Relation -> MultProp {- PRAGMA "" " has multiplicity property "-}.
  call;type |- type;root EXPLANATION "Services are called only with atoms of the type of the service's root."
  creates :: Service * Concept PRAGMA "" " can create instances of ".
  deletes :: Service * Concept PRAGMA "" " can delete instances of ".

  creates;source~;mult; 'Tot' ;mult~;target |- creates
   EXPLANATION "If there is a total relation with source s and target t, then any service that can create instances of s can also create instances of t."
  creates;target~;mult;'Sur';mult~;source |- creates
   EXPLANATION "If there is a surjective relation with source s and target t, then any service that can create instances of t can also create instances of s."
  deletes;source~;mult;'Inj'[MultProp];mult~;target |- deletes
   EXPLANATION "If there is an injective relation with source s and target t, then any service that can delete instances of s can also delete instances of t."
  deletes;target~;mult;'Uni'[MultProp];mult~;source |- deletes
   EXPLANATION "If there is an injective relation with source s and target t, then any service that can delete instances of t can also delete instances of s."
  I[MultProp] = 'Tot' \/ 'Sur' \/ 'Inj' \/ 'Uni'
ENDPATTERN

EXPLAIN POPULATION appliesIn IN DUTCH -+ bladibla
POPULATION appliesIn[Rule * Service] CONTAINS
    [ ("elem;subset* -: elem", "RAP")
    ; ("isa* -: pop;subset*;pop~", "RAP")
    ; ("type = elem;pop~", "RAP")
    ; ("right;right~/\\left;left~ = I", "RAP")
    ; ("left -: src;pop;elem~", "RAP")
    ; ("right -: trg;pop;elem~", "RAP")
    ; ("appliesIn = definedIn;uses~", "RAP")
    ; ("appliesIn;specializes*~ -: appliesIn", "RAP")
    ; ("in;appliesIn -: sign[Relation*Declaration]~;in", "RAP")
    ; ("in;sign -: src;source~/\\trg;target~", "RAP")
    ; ("sign;sign~/\\in~;in = I[Relation]", "RAP")
    ; ("in;sub* -: in", "RAP")
    ; ("I = name;name~/\\source;source~/\\target;target~", "RAP")
    ; ("sub* = sign;sub*;sign~/\\in;specializes*;in~", "RAP")
    ; ("in~;val -: val;in~", "RAP")
    ; ("in;val~;appliesIn -: in;in", "RAP")
    ; ("definedIn = sign~;in;definedIn", "RAP")
    ; ("I = definedIn~;definedIn[Rule*Pattern]", "RAP")
    ; ("in~;sign[Relation*Declaration] -: uses;definedIn~", "RAP")
    ; ("in;specializes* -: in", "RAP")
    ; ("specializes*;uses -: uses", "RAP")
    ; ("scope = in;specializes*", "RAP")
    ]

-- Glossary
CONCEPT Call "a runtime instance of a 'Service'. Calls come into existence (a.o.) by 'clicking a Button' that references the Service that the Call will instantiate. Every call is associated with a single Atom (being an element of the single Concept associated with its Service). Also, every Call c is associated with a single Session s, such that if c was called from another call c', then s is also the session associated with c'." "RJ"

CONCEPT Service "a (definetime) specification of a coherent set of services s[i] that are called by Buttons. Any s[i] may operate on data related to elements (Atoms) of one Concept that is specific to s. Runtime instances of s (dubbed 'Calls) have the task of selecting the data related to the single 'service atom' of s that is appropriate for calling a specific s[i]. Note that operations can be Services as well." "RJ"

CONCEPT Button "a clickable widget on a user screen" "RJ"

CONCEPT Atom "an elementary data object that cannot be divided into smaller parts. E.g. \"John\", \"1\", \"440-566-4567" "Ampersand"
CONCEPT Concept "a collection of similar atoms. E.g. Person, Age, PhoneNumber" "Ampersand"
CONCEPT Pattern "a collection of rules that covers a theme, e.g. \"Security\", \"Case Management\", or \"Refugees\", that is considered relevant at the discretion of the business" "Ampersand"
CONCEPT Service "a self-contained, modular business application that has open, standards based interfaces" "Alonso"
CONCEPT Service "a set of related software functionality, together with the policies that should control their usage" "Ampersand"
CONCEPT Session "an interactive information exchange between communicating devices that is established at a certain time and torn down at a later time, which is performed on behalf of a specific user" "Ampersand"
CONCEPT CompileUnit "a body of text that contains ADL-code"
  EXPLAIN CONCEPT CompileUnit IN ENGLISH REF "Ampersand"
  -+ A compile unit is meant to compile an ADL-script to one ore more ADL-concepts. Currently, a script compiles to a context. In the near future we mean to compile patterns and services as separate compile units too"
CONCEPT "Call" "the invocation of a service by a session"
--CONCEPT "" ""

ENDCONTEXT
