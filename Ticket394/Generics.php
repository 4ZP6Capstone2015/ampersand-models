<?php
// module Generics.php generated by Generate.hs
// Prototype v3.0.2.3038, build time: 23-Apr-14 07:00:07 UTC (lib: Ampersand v3.0.2.1329, build time: 23-Apr-14 06:59:47 UTC)


$versionInfo = 'Prototype v3.0.2.3038, build time: 23-Apr-14 07:00:07 UTC (lib: Ampersand v3.0.2.1329, build time: 23-Apr-14 06:59:47 UTC)';

$dbName = 'CSA_Op';

$isDev = false;

$autoRefreshInterval = '0';

$allSpecializations =
  array
    ();

$relationTableInfo =
  array
    ( 'connectComputerToNetworkRouter' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'connectComputerToNetworkRouter')
    , 'routesToBeDiscarded' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'routesToBeDiscarded', 'srcCol'     => 'SrcRouter', 'tgtCol'     => 'TgtRouter')
    , 'computerToBeDisconnected' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Router', 'table'      => 'computerToBeDisconnected', 'srcCol'     => 'Computer', 'tgtCol'     => 'Router')
    , 'compRequiresComm' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compRequiresComm')
    , 'compHasCommWith' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table'      => 'compHasCommWith', 'srcCol'     => 'SrcComputer', 'tgtCol'     => 'TgtComputer')
    , 'compAllReqCommSatisfied' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compAllReqCommSatisfied')
    , 'compNoReqCommSatisfied' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compNoReqCommSatisfied')
    , 'routerRoutesTo' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'routerRoutesTo', 'srcCol'     => 'SrcRouter', 'tgtCol'     => 'TgtRouter')
    , 'rrtDirect' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'rrtDirect', 'srcCol'     => 'SrcRouter', 'tgtCol'     => 'TgtRouter')
    , 'rrtStar' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'rrtStar', 'srcCol'     => 'SrcRouter', 'tgtCol'     => 'TgtRouter')
    , 'routerNeedsPathTo' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'routerNeedsPathTo', 'srcCol'     => 'SrcRouter', 'tgtCol'     => 'TgtRouter')
    , 'routerAllCommReqsSatisfied' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'Router', 'srcCol'     => 'Router', 'tgtCol'     => 'routerAllCommReqsSatisfied')
    , 'routerNoCommReqsSatisfied' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Router', 'table'      => 'Router', 'srcCol'     => 'Router', 'tgtCol'     => 'routerNoCommReqsSatisfied')
    , 'nwAllCompCommReqsSatisfied' => array ( 'srcConcept' => 'Network', 'tgtConcept' => 'Network', 'table'      => 'Network', 'srcCol'     => 'Network', 'tgtCol'     => 'nwAllCompCommReqsSatisfied')
    , 'nwNoCompCommReqsSatisfied' => array ( 'srcConcept' => 'Network', 'tgtConcept' => 'Network', 'table'      => 'Network', 'srcCol'     => 'Network', 'tgtCol'     => 'nwNoCompCommReqsSatisfied')
    , 'compCmpStat' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compCmpStat')
    , 'scCmpStat' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table'      => 'SvcComponent', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'scCmpStat')
    , 'itsvcCmpStat' => array ( 'srcConcept' => 'ITService', 'tgtConcept' => 'Status', 'table'      => 'ITService', 'srcCol'     => 'ITService', 'tgtCol'     => 'itsvcCmpStat')
    , 'svcCmpStat' => array ( 'srcConcept' => 'Service', 'tgtConcept' => 'Status', 'table'      => 'Service', 'srcCol'     => 'Service', 'tgtCol'     => 'svcCmpStat')
    , 'allRequiredITAvailbleToOrgUnit' => array ( 'srcConcept' => 'OrgUnit', 'tgtConcept' => 'OrgUnit', 'table'      => 'OrgUnit', 'srcCol'     => 'OrgUnit', 'tgtCol'     => 'allRequiredITAvailbleToOrgUnit')
    , 'noRequiredITAvailbleToOrgUnit' => array ( 'srcConcept' => 'OrgUnit', 'tgtConcept' => 'OrgUnit', 'table'      => 'OrgUnit', 'srcCol'     => 'OrgUnit', 'tgtCol'     => 'noRequiredITAvailbleToOrgUnit')
    , 'ouCmpStat' => array ( 'srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table'      => 'OrgUnit', 'srcCol'     => 'OrgUnit', 'tgtCol'     => 'ouCmpStat')
    , 'actCmpStat' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actCmpStat')
    , 'resultCmpStat' => array ( 'srcConcept' => 'Result', 'tgtConcept' => 'Status', 'table'      => 'Result', 'srcCol'     => 'Result', 'tgtCol'     => 'resultCmpStat')
    , 'taskCmpStatIsRed' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Task', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskCmpStatIsRed')
    , 'taskCmpStatIsGreen' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Task', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskCmpStatIsGreen')
    , 'taskCmpStat' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Status', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskCmpStat')
    , 'purposeCmpStat' => array ( 'srcConcept' => 'Purpose', 'tgtConcept' => 'Status', 'table'      => 'Purpose', 'srcCol'     => 'Purpose', 'tgtCol'     => 'purposeCmpStat')
    , 'yesNo' => array ( 'srcConcept' => 'Yes/No answer', 'tgtConcept' => 'Yes/No answer', 'table'      => 'yesNo', 'srcCol'     => 'SrcYes/No answer', 'tgtCol'     => 'TgtYes/No answer')
    , 'purposeStatus' => array ( 'srcConcept' => 'Purpose', 'tgtConcept' => 'Status', 'table'      => 'Purpose', 'srcCol'     => 'Purpose', 'tgtCol'     => 'purposeStatus')
    , 'purposeMnlStat' => array ( 'srcConcept' => 'Purpose', 'tgtConcept' => 'Status', 'table'      => 'Purpose', 'srcCol'     => 'Purpose', 'tgtCol'     => 'purposeMnlStat')
    , 'taskStatus' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Status', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskStatus')
    , 'taskMnlStat' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Status', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskMnlStat')
    , 'taskEndTime' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Timestamp', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskEndTime')
    , 'isSubtaskOf' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Task', 'table'      => 'isSubtaskOf', 'srcCol'     => 'SrcTask', 'tgtCol'     => 'TgtTask')
    , 'taskPurpose' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Purpose', 'table'      => 'taskPurpose', 'srcCol'     => 'Task', 'tgtCol'     => 'Purpose')
    , 'taskReqsSvc' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Service', 'table'      => 'taskReqsSvc', 'srcCol'     => 'Task', 'tgtCol'     => 'Service')
    , 'taskOU' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'OrgUnit', 'table'      => 'Task', 'srcCol'     => 'Task', 'tgtCol'     => 'taskOU')
    , 'taskExpectsResult' => array ( 'srcConcept' => 'Task', 'tgtConcept' => 'Result', 'table'      => 'taskExpectsResult', 'srcCol'     => 'Task', 'tgtCol'     => 'Result')
    , 'resultStatus' => array ( 'srcConcept' => 'Result', 'tgtConcept' => 'Status', 'table'      => 'Result', 'srcCol'     => 'Result', 'tgtCol'     => 'resultStatus')
    , 'resultMnlStat' => array ( 'srcConcept' => 'Result', 'tgtConcept' => 'Status', 'table'      => 'Result', 'srcCol'     => 'Result', 'tgtCol'     => 'resultMnlStat')
    , 'resultDeadline' => array ( 'srcConcept' => 'Result', 'tgtConcept' => 'Timestamp', 'table'      => 'Result', 'srcCol'     => 'Result', 'tgtCol'     => 'resultDeadline')
    , 'svcStatus' => array ( 'srcConcept' => 'Service', 'tgtConcept' => 'Status', 'table'      => 'Service', 'srcCol'     => 'Service', 'tgtCol'     => 'svcStatus')
    , 'actStatus' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actStatus')
    , 'actMnlStat' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Status', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actMnlStat')
    , 'actResult' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Result', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actResult')
    , 'actTask' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Task', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actTask')
    , 'actExecutingOU' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'OrgUnit', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actExecutingOU')
    , 'actPlannedStartTime' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actPlannedStartTime')
    , 'actPlannedEndTime' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actPlannedEndTime')
    , 'actStartTime' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actStartTime')
    , 'actEndTime' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'Timestamp', 'table'      => 'Activity', 'srcCol'     => 'Activity', 'tgtCol'     => 'actEndTime')
    , 'actUsesITSvc' => array ( 'srcConcept' => 'Activity', 'tgtConcept' => 'ITService', 'table'      => 'actUsesITSvc', 'srcCol'     => 'Activity', 'tgtCol'     => 'ITService')
    , 'ouStatus' => array ( 'srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table'      => 'OrgUnit', 'srcCol'     => 'OrgUnit', 'tgtCol'     => 'ouStatus')
    , 'ouMnlStat' => array ( 'srcConcept' => 'OrgUnit', 'tgtConcept' => 'Status', 'table'      => 'OrgUnit', 'srcCol'     => 'OrgUnit', 'tgtCol'     => 'ouMnlStat')
    , 'isSubUnitOf' => array ( 'srcConcept' => 'OrgUnit', 'tgtConcept' => 'OrgUnit', 'table'      => 'isSubUnitOf', 'srcCol'     => 'SrcOrgUnit', 'tgtCol'     => 'TgtOrgUnit')
    , 'svcMnlStat' => array ( 'srcConcept' => 'Service', 'tgtConcept' => 'Status', 'table'      => 'Service', 'srcCol'     => 'Service', 'tgtCol'     => 'svcMnlStat')
    , 'itsvcStatus' => array ( 'srcConcept' => 'ITService', 'tgtConcept' => 'Status', 'table'      => 'ITService', 'srcCol'     => 'ITService', 'tgtCol'     => 'itsvcStatus')
    , 'itsvcMnlStat' => array ( 'srcConcept' => 'ITService', 'tgtConcept' => 'Status', 'table'      => 'ITService', 'srcCol'     => 'ITService', 'tgtCol'     => 'itsvcMnlStat')
    , 'itsvcSupports' => array ( 'srcConcept' => 'ITService', 'tgtConcept' => 'Service', 'table'      => 'itsvcSupports', 'srcCol'     => 'ITService', 'tgtCol'     => 'Service')
    , 'scStatus' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table'      => 'SvcComponent', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'scStatus')
    , 'scMnlStat' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'Status', 'table'      => 'SvcComponent', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'scMnlStat')
    , 'scImplements' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'ITService', 'table'      => 'scImplements', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'ITService')
    , 'scIsServerFor' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'ITService', 'table'      => 'scIsServerFor', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'ITService')
    , 'scIsClientFor' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'ITService', 'table'      => 'scIsClientFor', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'ITService')
    , 'scDeployedOn' => array ( 'srcConcept' => 'SvcComponent', 'tgtConcept' => 'Computer', 'table'      => 'scDeployedOn', 'srcCol'     => 'SvcComponent', 'tgtCol'     => 'Computer')
    , 'compStatus' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compStatus')
    , 'compMnlStat' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Status', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compMnlStat')
    , 'compOwner' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'OrgUnit', 'table'      => 'Computer', 'srcCol'     => 'Computer', 'tgtCol'     => 'compOwner')
    , 'compITService' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'ITService', 'table'      => 'compITService', 'srcCol'     => 'Computer', 'tgtCol'     => 'ITService')
    , 'compReqCommWith' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Computer', 'table'      => 'compReqCommWith', 'srcCol'     => 'SrcComputer', 'tgtCol'     => 'TgtComputer')
    , 'compRouter' => array ( 'srcConcept' => 'Computer', 'tgtConcept' => 'Router', 'table'      => 'compRouter', 'srcCol'     => 'Computer', 'tgtCol'     => 'Router')
    , 'routerStatus' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Status', 'table'      => 'Router', 'srcCol'     => 'Router', 'tgtCol'     => 'routerStatus')
    , 'routerSerial' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'SerialNumber', 'table'      => 'Router', 'srcCol'     => 'Router', 'tgtCol'     => 'routerSerial')
    , 'routerLocation' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Location', 'table'      => 'Router', 'srcCol'     => 'Router', 'tgtCol'     => 'routerLocation')
    , 'routerNW' => array ( 'srcConcept' => 'Router', 'tgtConcept' => 'Network', 'table'      => 'Router', 'srcCol'     => 'Router', 'tgtCol'     => 'routerNW')
    , 'nwStatus' => array ( 'srcConcept' => 'Network', 'tgtConcept' => 'Status', 'table'      => 'Network', 'srcCol'     => 'Network', 'tgtCol'     => 'nwStatus')
    );

$conceptTableInfo =
  array
    ( 'Task' => array 
          ( array ( 'table' => 'Task'
                  , 'cols' => array ('Task')
                  )
          )
    , 'Result' => array 
          ( array ( 'table' => 'Result'
                  , 'cols' => array ('Result')
                  )
          )
    , 'Computer' => array 
          ( array ( 'table' => 'Computer'
                  , 'cols' => array ('Computer')
                  )
          )
    , 'Router' => array 
          ( array ( 'table' => 'Router'
                  , 'cols' => array ('Router')
                  )
          )
    , 'Network' => array 
          ( array ( 'table' => 'Network'
                  , 'cols' => array ('Network')
                  )
          )
    , 'Activity' => array 
          ( array ( 'table' => 'Activity'
                  , 'cols' => array ('Activity')
                  )
          )
    , 'Timestamp' => array 
          ( array ( 'table' => 'Timestamp'
                  , 'cols' => array ('Timestamp')
                  )
          )
    , 'ITService' => array 
          ( array ( 'table' => 'ITService'
                  , 'cols' => array ('ITService')
                  )
          )
    , 'OrgUnit' => array 
          ( array ( 'table' => 'OrgUnit'
                  , 'cols' => array ('OrgUnit')
                  )
          )
    , 'SvcComponent' => array 
          ( array ( 'table' => 'SvcComponent'
                  , 'cols' => array ('SvcComponent')
                  )
          )
    , 'Status' => array 
          ( array ( 'table' => 'Status'
                  , 'cols' => array ('Status')
                  )
          )
    , 'Service' => array 
          ( array ( 'table' => 'Service'
                  , 'cols' => array ('Service')
                  )
          )
    , 'Purpose' => array 
          ( array ( 'table' => 'Purpose'
                  , 'cols' => array ('Purpose')
                  )
          )
    , 'Yes/No answer' => array 
          ( array ( 'table' => 'Yes/No answer'
                  , 'cols' => array ('Yes/No answer')
                  )
          )
    , 'SerialNumber' => array 
          ( array ( 'table' => 'SerialNumber'
                  , 'cols' => array ('SerialNumber')
                  )
          )
    , 'Location' => array 
          ( array ( 'table' => 'Location'
                  , 'cols' => array ('Location')
                  )
          )
    , 'ONE' => array 
          ()
    );

$tableColumnInfo =
  array
    ( 'Activity' =>
        array
          ( 'Activity' => array ( 'concept' => 'Activity', 'unique' => true, 'null' => false)
          , 'actCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'actResult' => array ( 'concept' => 'Result', 'unique' => false, 'null' => true)
          , 'actTask' => array ( 'concept' => 'Task', 'unique' => false, 'null' => true)
          , 'actExecutingOU' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => true)
          , 'actPlannedStartTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actPlannedEndTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actStartTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'actEndTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          )
    , 'Computer' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => false)
          , 'connectComputerToNetworkRouter' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compRequiresComm' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compAllReqCommSatisfied' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compNoReqCommSatisfied' => array ( 'concept' => 'Computer', 'unique' => true, 'null' => true)
          , 'compCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'compOwner' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => true)
          )
    , 'Task' =>
        array
          ( 'Task' => array ( 'concept' => 'Task', 'unique' => true, 'null' => false)
          , 'taskCmpStatIsRed' => array ( 'concept' => 'Task', 'unique' => true, 'null' => true)
          , 'taskCmpStatIsGreen' => array ( 'concept' => 'Task', 'unique' => true, 'null' => true)
          , 'taskCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'taskStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'taskMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'taskEndTime' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          , 'taskOU' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => true)
          )
    , 'Router' =>
        array
          ( 'Router' => array ( 'concept' => 'Router', 'unique' => true, 'null' => false)
          , 'routerAllCommReqsSatisfied' => array ( 'concept' => 'Router', 'unique' => true, 'null' => true)
          , 'routerNoCommReqsSatisfied' => array ( 'concept' => 'Router', 'unique' => true, 'null' => true)
          , 'routerStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'routerSerial' => array ( 'concept' => 'SerialNumber', 'unique' => false, 'null' => true)
          , 'routerLocation' => array ( 'concept' => 'Location', 'unique' => false, 'null' => true)
          , 'routerNW' => array ( 'concept' => 'Network', 'unique' => false, 'null' => true)
          )
    , 'OrgUnit' =>
        array
          ( 'OrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => true, 'null' => false)
          , 'allRequiredITAvailbleToOrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => true, 'null' => true)
          , 'noRequiredITAvailbleToOrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => true, 'null' => true)
          , 'ouCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'ouStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'ouMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Result' =>
        array
          ( 'Result' => array ( 'concept' => 'Result', 'unique' => true, 'null' => false)
          , 'resultCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'resultStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'resultMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'resultDeadline' => array ( 'concept' => 'Timestamp', 'unique' => false, 'null' => true)
          )
    , 'Purpose' =>
        array
          ( 'Purpose' => array ( 'concept' => 'Purpose', 'unique' => true, 'null' => false)
          , 'purposeCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'purposeStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'purposeMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Service' =>
        array
          ( 'Service' => array ( 'concept' => 'Service', 'unique' => true, 'null' => false)
          , 'svcCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'svcStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'svcMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'SvcComponent' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => true, 'null' => false)
          , 'scCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'scMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'ITService' =>
        array
          ( 'ITService' => array ( 'concept' => 'ITService', 'unique' => true, 'null' => false)
          , 'itsvcCmpStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'itsvcStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          , 'itsvcMnlStat' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Network' =>
        array
          ( 'Network' => array ( 'concept' => 'Network', 'unique' => true, 'null' => false)
          , 'nwAllCompCommReqsSatisfied' => array ( 'concept' => 'Network', 'unique' => true, 'null' => true)
          , 'nwNoCompCommReqsSatisfied' => array ( 'concept' => 'Network', 'unique' => true, 'null' => true)
          , 'nwStatus' => array ( 'concept' => 'Status', 'unique' => false, 'null' => true)
          )
    , 'Location' =>
        array
          ( 'Location' => array ( 'concept' => 'Location', 'unique' => true, 'null' => false)
          )
    , 'SerialNumber' =>
        array
          ( 'SerialNumber' => array ( 'concept' => 'SerialNumber', 'unique' => true, 'null' => false)
          )
    , 'Yes/No answer' =>
        array
          ( 'Yes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => true, 'null' => false)
          )
    , 'Status' =>
        array
          ( 'Status' => array ( 'concept' => 'Status', 'unique' => true, 'null' => false)
          )
    , 'Timestamp' =>
        array
          ( 'Timestamp' => array ( 'concept' => 'Timestamp', 'unique' => true, 'null' => false)
          )
    , 'routesToBeDiscarded' =>
        array
          ( 'SrcRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'TgtRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'computerToBeDisconnected' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'Router' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'compHasCommWith' =>
        array
          ( 'SrcComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'TgtComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'routerRoutesTo' =>
        array
          ( 'SrcRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'TgtRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'rrtDirect' =>
        array
          ( 'SrcRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'TgtRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'rrtStar' =>
        array
          ( 'SrcRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'TgtRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'routerNeedsPathTo' =>
        array
          ( 'SrcRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          , 'TgtRouter' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    , 'yesNo' =>
        array
          ( 'SrcYes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => false, 'null' => false)
          , 'TgtYes/No answer' => array ( 'concept' => 'Yes/No answer', 'unique' => false, 'null' => false)
          )
    , 'isSubtaskOf' =>
        array
          ( 'SrcTask' => array ( 'concept' => 'Task', 'unique' => false, 'null' => false)
          , 'TgtTask' => array ( 'concept' => 'Task', 'unique' => false, 'null' => false)
          )
    , 'taskPurpose' =>
        array
          ( 'Task' => array ( 'concept' => 'Task', 'unique' => false, 'null' => false)
          , 'Purpose' => array ( 'concept' => 'Purpose', 'unique' => false, 'null' => false)
          )
    , 'taskReqsSvc' =>
        array
          ( 'Task' => array ( 'concept' => 'Task', 'unique' => false, 'null' => false)
          , 'Service' => array ( 'concept' => 'Service', 'unique' => false, 'null' => false)
          )
    , 'taskExpectsResult' =>
        array
          ( 'Task' => array ( 'concept' => 'Task', 'unique' => false, 'null' => false)
          , 'Result' => array ( 'concept' => 'Result', 'unique' => false, 'null' => false)
          )
    , 'actUsesITSvc' =>
        array
          ( 'Activity' => array ( 'concept' => 'Activity', 'unique' => false, 'null' => false)
          , 'ITService' => array ( 'concept' => 'ITService', 'unique' => false, 'null' => false)
          )
    , 'isSubUnitOf' =>
        array
          ( 'SrcOrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          , 'TgtOrgUnit' => array ( 'concept' => 'OrgUnit', 'unique' => false, 'null' => false)
          )
    , 'itsvcSupports' =>
        array
          ( 'ITService' => array ( 'concept' => 'ITService', 'unique' => false, 'null' => false)
          , 'Service' => array ( 'concept' => 'Service', 'unique' => false, 'null' => false)
          )
    , 'scImplements' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'ITService' => array ( 'concept' => 'ITService', 'unique' => false, 'null' => false)
          )
    , 'scIsServerFor' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'ITService' => array ( 'concept' => 'ITService', 'unique' => false, 'null' => false)
          )
    , 'scIsClientFor' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'ITService' => array ( 'concept' => 'ITService', 'unique' => false, 'null' => false)
          )
    , 'scDeployedOn' =>
        array
          ( 'SvcComponent' => array ( 'concept' => 'SvcComponent', 'unique' => false, 'null' => false)
          , 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'compITService' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'ITService' => array ( 'concept' => 'ITService', 'unique' => false, 'null' => false)
          )
    , 'compReqCommWith' =>
        array
          ( 'SrcComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'TgtComputer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          )
    , 'compRouter' =>
        array
          ( 'Computer' => array ( 'concept' => 'Computer', 'unique' => false, 'null' => false)
          , 'Router' => array ( 'concept' => 'Router', 'unique' => false, 'null' => false)
          )
    );

$allRulesSql =
  array
    ( 'SUR[taskExpectsResult]' =>
        array ( 'name'          => 'SUR[taskExpectsResult]'
              , 'ruleAdl'       => 'I[Result] |- taskExpectsResult~;taskExpectsResult'
              , 'origin'        => 'line 12:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'Every Result must be expected by (at least) one Task'
              , 'message'       => ''
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Result'
              // Normalization steps:
              //     -(I[Result] |- taskExpectsResult~;taskExpectsResult)
              // <=> { remove |- }
              //     -(-I[Result] \\/ taskExpectsResult~;taskExpectsResult)
              // <=> { De Morgan }
              //     I[Result] /\\ -(taskExpectsResult~;taskExpectsResult)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Result
              //      ,ECpl (ECps (EFlp (EDcD rel_taskExpectsResultTaskResult)
              //                  ,EDcD rel_taskExpectsResultTaskResult
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Result] /\\\\ -(taskExpectsResult~;taskExpectsResult) ([Result*Result]) */
                          SELECT DISTINCT isect0.`Result` AS `src`, isect0.`Result` AS `tgt`
                          FROM ( /* Case EDcI Result */
                                 SELECT `Result` AS `Result`
                                 FROM `Result` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 taskExpectsResult~;taskExpectsResult */
                                              
                                              SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps1.`Result` AS `TgtResult`
                                              FROM `taskExpectsResult` AS ECps0,
                                                   `taskExpectsResult` AS ECps1
                                              WHERE ECps0.`Task`=ECps1.`Task`
                                            ) AS cp
                                            WHERE isect0.`Result`=cp.`SrcResult` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Result` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Result ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Result'
                            , 'expSQL' =>
                                '/* I[Result] */
                                   SELECT `Result` AS `src`, `Result` AS `tgt`
                                   FROM `Result`
                                   WHERE `Result` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be expected by some task')
                    )
              )
    , 'Connect computer to network router' =>
        array ( 'name'          => 'Connect computer to network router'
              , 'ruleAdl'       => 'I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~'
              , 'origin'        => 'line 37:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'A computer that needs to communicate with another computer must be connected to a network-router'
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compReqCommWith;compReqCommWith~) \\/ compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~)
              // <=> { De Morgan }
              //     I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compReqCommWithComputerComputer
              //                  ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                  )
              //            ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                        ,ECps (EIsc (EDcI cpt_Router
              //                                    ,ECps (EDcD rel_routerNWRouterNetwork
              //                                          ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                                          )
              //                                    )
              //                              ,EFlp (EDcD rel_compRouterComputerRouter)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                 FROM `compReqCommWith` AS ECps0,
                                      `compReqCommWith` AS ECps1
                                 WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                               ) AS isect0, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `compRouter` AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                     SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               routerNW;routerNW~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                            FROM `Router` AS ECps0,
                                                                 `Router` AS ECps1
                                                            WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                          ) AS isect0, 
                                                          ( /* Case EDcI Router */
                                                            SELECT `Router` AS `Router`
                                                            FROM `Router` ) AS isect1
                                                     WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                   ) AS ECps1,
                                                   `compRouter` AS ECps2
                                              WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                AND ECps1.`TgtRouter`=ECps2.`Router`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' must be connected to a network-router.')
                    )
              )
    , 'insconnectComputerToNetworkRouter' =>
        array ( 'name'          => 'insconnectComputerToNetworkRouter'
              , 'ruleAdl'       => '(I[Computer] /\\ compReqCommWith;compReqCommWith~) /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~) |- connectComputerToNetworkRouter'
              , 'origin'        => 'line 43:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~) |- connectComputerToNetworkRouter)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~)) \\/ connectComputerToNetworkRouter)
              // <=> { De Morgan }
              //     I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~) /\\ -connectComputerToNetworkRouter
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compReqCommWithComputerComputer
              //                  ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                  )
              //            ,EIsc (ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                              ,ECps (EIsc (EDcI cpt_Router
              //                                          ,ECps (EDcD rel_routerNWRouterNetwork
              //                                                ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                                                )
              //                                          )
              //                                    ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                    )
              //                              ))
              //                  ,ECpl (EDcD rel_connectComputerToNetworkRouterComputerComputer)
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~) /\\\\ -connectComputerToNetworkRouter ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                 FROM `compReqCommWith` AS ECps0,
                                      `compReqCommWith` AS ECps1
                                 WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                               ) AS isect0, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `compRouter` AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                     SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               routerNW;routerNW~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                            FROM `Router` AS ECps0,
                                                                 `Router` AS ECps1
                                                            WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                          ) AS isect0, 
                                                          ( /* Case EDcI Router */
                                                            SELECT `Router` AS `Router`
                                                            FROM `Router` ) AS isect1
                                                     WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                   ) AS ECps1,
                                                   `compRouter` AS ECps2
                                              WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                AND ECps1.`TgtRouter`=ECps2.`Router`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.Computer AND isect0.`TgtComputer`=cp.`connectComputerToNetworkRouter`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;connectComputerToNetworkRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'delconnectComputerToNetworkRouter' =>
        array ( 'name'          => 'delconnectComputerToNetworkRouter'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter |- (I[Computer] /\\ compReqCommWith;compReqCommWith~) /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~)'
              , 'origin'        => 'line 46:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter |- I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~))
              // <=> { remove |- }
              //     -(-connectComputerToNetworkRouter \\/ (I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~)))
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter /\\ -(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~);compRouter~))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_connectComputerToNetworkRouterComputerComputer
              //      ,ECpl (EIsc (EDcI cpt_Computer
              //                  ,EIsc (ECps (EDcD rel_compReqCommWithComputerComputer
              //                              ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                              )
              //                        ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                                    ,ECps (EIsc (EDcI cpt_Router
              //                                                ,ECps (EDcD rel_routerNWRouterNetwork
              //                                                      ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                                                      )
              //                                                )
              //                                          ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                          )
              //                                    ))
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             connectComputerToNetworkRouter /\\\\ -(I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`connectComputerToNetworkRouter` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~) ([Computer*Computer]) */
                                              SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compReqCommWith;compReqCommWith~ */
                                                     
                                                     SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                                     FROM `compReqCommWith` AS ECps0,
                                                          `compReqCommWith` AS ECps1
                                                     WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                                                   ) AS isect0, 
                                                   ( /* Case EDcI Computer */
                                                     SELECT `Computer` AS `Computer`
                                                     FROM `Computer` ) AS isect1
                                              WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     compRouter;(I[Router] /\\\\ routerNW;routerNW~);compRouter~ */
                                                                  
                                                                  SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                                  FROM `compRouter` AS ECps0,
                                                                       
                                                                       ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                            I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                                         SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                                         FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   routerNW;routerNW~ */
                                                                                
                                                                                SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                                                FROM `Router` AS ECps0,
                                                                                     `Router` AS ECps1
                                                                                WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                                              ) AS isect0, 
                                                                              ( /* Case EDcI Router */
                                                                                SELECT `Router` AS `Router`
                                                                                FROM `Router` ) AS isect1
                                                                         WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                                       ) AS ECps1,
                                                                       `compRouter` AS ECps2
                                                                  WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                    AND ECps1.`TgtRouter`=ECps2.`Router`
                                                                ) AS cp
                                                                WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Computer=cp.`SrcComputer` AND isect0.`connectComputerToNetworkRouter`=cp.`TgtComputer`) AND isect0.Computer IS NOT NULL AND isect0.`connectComputerToNetworkRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;connectComputerToNetworkRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Create router paths' =>
        array ( 'name'          => 'Create router paths'
              , 'ruleAdl'       => 'routerNeedsPathTo |- -V[Router*Router]'
              , 'origin'        => 'line 50:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'A router must have a path to another router if a computer is connected to it that has an unsatisfied communication requirement with another computer that is connected to the other router.'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNeedsPathTo |- -V[Router*Router])
              // <=> { remove |- }
              //     -(-routerNeedsPathTo \\/ -V[Router*Router])
              // <=> { De Morgan }
              //     routerNeedsPathTo /\\ V[Router*Router]
              // <=> { x/\\V = x }
              //     routerNeedsPathTo
              // 
              // Normalized complement (== violationsSQL): 
              // EDcD rel_routerNeedsPathToRouterRouter
              , 'violationsSQL' => 'SELECT DISTINCT `SrcRouter` AS `src`, `TgtRouter` AS `tgt`
                          FROM `routerNeedsPathTo`
                          WHERE `SrcRouter` IS NOT NULL AND `TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'A path must exist from router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' to ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Routes to be discarded' =>
        array ( 'name'          => 'Routes to be discarded'
              , 'ruleAdl'       => 'rrtDirect |- routerNW;V[Network*Network];routerNW~'
              , 'origin'        => 'line 55:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'Routing can only be done by routers that are part of a network.'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtDirect |- routerNW;V[Network*Network];routerNW~)
              // <=> { remove |- }
              //     -(-rrtDirect \\/ routerNW;V[Network*Network];routerNW~)
              // <=> { De Morgan }
              //     rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_rrtDirectRouterRouter
              //      ,ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                  ,ECps (EDcV (Sign cpt_Network cpt_Network)
              //                        ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             rrtDirect /\\\\ -(routerNW;V[Network*Network];routerNW~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM `rrtDirect` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case:  (e:ERel (V _) _:f:fx)
                                                 routerNW */
                                              SELECT DISTINCT fst.`Router` AS `SrcRouter`, snd.`Router` AS `TgtRouter`
                                              FROM `Router` AS fst,
                                                   `Router` AS snd
                                              WHERE fst.`Router` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Route from ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' to ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' should be removed.')
                    )
              )
    , 'insroutesToBeDiscarded' =>
        array ( 'name'          => 'insroutesToBeDiscarded'
              , 'ruleAdl'       => 'rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~) |- routesToBeDiscarded'
              , 'origin'        => 'line 60:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~) |- routesToBeDiscarded)
              // <=> { remove |- }
              //     -(-(rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~)) \\/ routesToBeDiscarded)
              // <=> { De Morgan }
              //     rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~) /\\ -routesToBeDiscarded
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_rrtDirectRouterRouter
              //      ,EIsc (ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                        ,ECps (EDcV (Sign cpt_Network cpt_Network)
              //                              ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                              )
              //                        ))
              //            ,ECpl (EDcD rel_routesToBeDiscardedRouterRouter)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             rrtDirect /\\\\ -(routerNW;V[Network*Network];routerNW~) /\\\\ -routesToBeDiscarded ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM `rrtDirect` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case:  (e:ERel (V _) _:f:fx)
                                                 routerNW */
                                              SELECT DISTINCT fst.`Router` AS `SrcRouter`, snd.`Router` AS `TgtRouter`
                                              FROM `Router` AS fst,
                                                   `Router` AS snd
                                              WHERE fst.`Router` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND NOT EXISTS (SELECT * FROM `routesToBeDiscarded` AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routesToBeDiscarded;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'delroutesToBeDiscarded' =>
        array ( 'name'          => 'delroutesToBeDiscarded'
              , 'ruleAdl'       => 'routesToBeDiscarded |- rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~)'
              , 'origin'        => 'line 63:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routesToBeDiscarded |- rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~))
              // <=> { remove |- }
              //     -(-routesToBeDiscarded \\/ (rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~)))
              // <=> { De Morgan }
              //     routesToBeDiscarded /\\ -(rrtDirect /\\ -(routerNW;V[Network*Network];routerNW~))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routesToBeDiscardedRouterRouter
              //      ,ECpl (EIsc (EDcD rel_rrtDirectRouterRouter
              //                  ,ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                              ,ECps (EDcV (Sign cpt_Network cpt_Network)
              //                                    ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                                    )
              //                              ))
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routesToBeDiscarded /\\\\ -(rrtDirect /\\\\ -(routerNW;V[Network*Network];routerNW~)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM `routesToBeDiscarded` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 rrtDirect /\\\\ -(routerNW;V[Network*Network];routerNW~) ([Router*Router]) */
                                              SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                              FROM `rrtDirect` AS isect0
                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                ( /* case:  (e:ERel (V _) _:f:fx)
                                                                     routerNW */
                                                                  SELECT DISTINCT fst.`Router` AS `SrcRouter`, snd.`Router` AS `TgtRouter`
                                                                  FROM `Router` AS fst,
                                                                       `Router` AS snd
                                                                  WHERE fst.`Router` IS NOT NULL
                                                                ) AS cp
                                                                WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routesToBeDiscarded;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Computers to be disconnected' =>
        array ( 'name'          => 'Computers to be disconnected'
              , 'ruleAdl'       => 'compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~)'
              , 'origin'        => 'line 67:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'A router to which a computer is connected must be part of a network.'
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { remove |- }
              //     -(-compRouter \\/ compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { De Morgan }
              //     compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compRouterComputerRouter
              //      ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                  ,EIsc (EDcI cpt_Router
              //                        ,ECps (EDcD rel_routerNWRouterNetwork
              //                              ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRouter /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~)) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`Router` AS `tgt`
                          FROM `compRouter` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compRouter;(I[Router] /\\\\ routerNW;routerNW~) */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`TgtRouter`
                                              FROM `compRouter` AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                     SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               routerNW;routerNW~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                            FROM `Router` AS ECps0,
                                                                 `Router` AS ECps1
                                                            WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                          ) AS isect0, 
                                                          ( /* Case EDcI Router */
                                                            SELECT `Router` AS `Router`
                                                            FROM `Router` ) AS isect1
                                                     WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Router`=cp.`TgtRouter`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Computer ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' cannot be connected to router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' as the latter is not connected to a network.')
                    )
              )
    , 'inscomputerToBeDisconnected' =>
        array ( 'name'          => 'inscomputerToBeDisconnected'
              , 'ruleAdl'       => 'compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) |- computerToBeDisconnected'
              , 'origin'        => 'line 72:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) |- computerToBeDisconnected)
              // <=> { remove |- }
              //     -(-(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))) \\/ computerToBeDisconnected)
              // <=> { De Morgan }
              //     compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)) /\\ -computerToBeDisconnected
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compRouterComputerRouter
              //      ,EIsc (ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                        ,EIsc (EDcI cpt_Router
              //                              ,ECps (EDcD rel_routerNWRouterNetwork
              //                                    ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                                    )
              //                              )
              //                        ))
              //            ,ECpl (EDcD rel_computerToBeDisconnectedComputerRouter)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRouter /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~)) /\\\\ -computerToBeDisconnected ([Computer*Router]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`Router` AS `tgt`
                          FROM `compRouter` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compRouter;(I[Router] /\\\\ routerNW;routerNW~) */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`TgtRouter`
                                              FROM `compRouter` AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                     SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               routerNW;routerNW~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                            FROM `Router` AS ECps0,
                                                                 `Router` AS ECps1
                                                            WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                          ) AS isect0, 
                                                          ( /* Case EDcI Router */
                                                            SELECT `Router` AS `Router`
                                                            FROM `Router` ) AS isect1
                                                     WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Router`=cp.`TgtRouter`) AND NOT EXISTS (SELECT * FROM `computerToBeDisconnected` AS cp
                                            WHERE isect0.`Computer`=cp.`Computer` AND isect0.`Router`=cp.`Router`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;computerToBeDisconnected;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'delcomputerToBeDisconnected' =>
        array ( 'name'          => 'delcomputerToBeDisconnected'
              , 'ruleAdl'       => 'computerToBeDisconnected |- compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))'
              , 'origin'        => 'line 75:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(computerToBeDisconnected |- compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)))
              // <=> { remove |- }
              //     -(-computerToBeDisconnected \\/ (compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))))
              // <=> { De Morgan }
              //     computerToBeDisconnected /\\ -(compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~)))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_computerToBeDisconnectedComputerRouter
              //      ,ECpl (EIsc (EDcD rel_compRouterComputerRouter
              //                  ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                              ,EIsc (EDcI cpt_Router
              //                                    ,ECps (EDcD rel_routerNWRouterNetwork
              //                                          ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                                          )
              //                                    )
              //                              ))
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             computerToBeDisconnected /\\\\ -(compRouter /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~))) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`Router` AS `tgt`
                          FROM `computerToBeDisconnected` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 compRouter /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~)) ([Computer*Router]) */
                                              SELECT DISTINCT isect0.`Computer` AS `SrcComputer`, isect0.`Router` AS `TgtRouter`
                                              FROM `compRouter` AS isect0
                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     compRouter;(I[Router] /\\\\ routerNW;routerNW~) */
                                                                  
                                                                  SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`TgtRouter`
                                                                  FROM `compRouter` AS ECps0,
                                                                       
                                                                       ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                            I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                                         SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                                         FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   routerNW;routerNW~ */
                                                                                
                                                                                SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                                                FROM `Router` AS ECps0,
                                                                                     `Router` AS ECps1
                                                                                WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                                              ) AS isect0, 
                                                                              ( /* Case EDcI Router */
                                                                                SELECT `Router` AS `Router`
                                                                                FROM `Router` ) AS isect1
                                                                         WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                                       ) AS ECps1
                                                                  WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                ) AS cp
                                                                WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Router`=cp.`TgtRouter`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Router`=cp.`TgtRouter`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;computerToBeDisconnected;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Activity termination' =>
        array ( 'name'          => 'Activity termination'
              , 'ruleAdl'       => '(I[Activity] /\\ -(actEndTime;actEndTime~));actResult;actResult~;(I[Activity] /\\ actEndTime;actEndTime~) |- -I[Activity]'
              , 'origin'        => 'line 79:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -((I[Activity] /\\ -(actEndTime;actEndTime~));actResult;actResult~;(I[Activity] /\\ actEndTime;actEndTime~) |- -I[Activity])
              // <=> { remove |- }
              //     -(-((I[Activity] /\\ -(actEndTime;actEndTime~));actResult;actResult~;(I[Activity] /\\ actEndTime;actEndTime~)) \\/ -I[Activity])
              // <=> { De Morgan }
              //     (I[Activity] /\\ -(actEndTime;actEndTime~));actResult;actResult~;(I[Activity] /\\ actEndTime;actEndTime~) /\\ I[Activity]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EIsc (EDcI cpt_Activity
              //                  ,ECpl (ECps (EDcD rel_actEndTimeActivityTimestamp
              //                              ,EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //                              ))
              //                  )
              //            ,ECps (EDcD rel_actResultActivityResult
              //                  ,ECps (EFlp (EDcD rel_actResultActivityResult)
              //                        ,EIsc (EDcI cpt_Activity
              //                              ,ECps (EDcD rel_actEndTimeActivityTimestamp
              //                                    ,EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //                                    )
              //                              )
              //                        )
              //                  )
              //            )
              //      ,EDcI cpt_Activity
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             (I[Activity] /\\\\ -(actEndTime;actEndTime~));actResult;actResult~;(I[Activity] /\\\\ actEndTime;actEndTime~) /\\\\ I[Activity] ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS `src`, isect0.`TgtActivity` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    (I[Activity] /\\\\ -(actEndTime;actEndTime~));actResult;actResult~;(I[Activity] /\\\\ actEndTime;actEndTime~) */
                                 
                                 SELECT DISTINCT ECps0.`SrcActivity`, ECps3.`TgtActivity`
                                 FROM 
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           I[Activity] /\\\\ -(actEndTime;actEndTime~) ([Activity*Activity]) */
                                        SELECT DISTINCT isect0.`Activity` AS `SrcActivity`, isect0.`Activity` AS `TgtActivity`
                                        FROM ( /* Case EDcI Activity */
                                               SELECT `Activity` AS `Activity`
                                               FROM `Activity` ) AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               actEndTime;actEndTime~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                            FROM `Activity` AS ECps0,
                                                                 `Activity` AS ECps1
                                                            WHERE ECps0.`actEndTime`=ECps1.`actEndTime`
                                                          ) AS cp
                                                          WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1,
                                      `Activity` AS ECps2,
                                      
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           I[Activity] /\\\\ actEndTime;actEndTime~ ([Activity*Activity]) */
                                        SELECT DISTINCT isect0.`SrcActivity`, isect0.`TgtActivity`
                                        FROM 
                                             ( /* case: (ECps es), with two or more elements in es.
                                                  actEndTime;actEndTime~ */
                                               
                                               SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                               FROM `Activity` AS ECps0,
                                                    `Activity` AS ECps1
                                               WHERE ECps0.`actEndTime`=ECps1.`actEndTime`
                                             ) AS isect0, 
                                             ( /* Case EDcI Activity */
                                               SELECT `Activity` AS `Activity`
                                               FROM `Activity` ) AS isect1
                                        WHERE isect0.`SrcActivity` = isect0.`TgtActivity` AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL
                                      ) AS ECps3
                                 WHERE ECps0.`TgtActivity`=ECps1.`Activity`
                                   AND ECps1.`actResult`=ECps2.`actResult`
                                   AND ECps2.`Activity`=ECps3.`SrcActivity`
                               ) AS isect0, 
                               ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect1
                          WHERE isect0.`SrcActivity` = isect0.`TgtActivity` AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} Inspair;actEndTime;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Timestamp;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Timestamp'
                            , 'expSQL' =>
                                'SELECT DISTINCT `Activity` AS `src`, `actEndTime` AS `tgt`
                                 FROM `Activity`
                                 WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL'
                            )
                    )
              )
    , 'Task completion integrity' =>
        array ( 'name'          => 'Task completion integrity'
              , 'ruleAdl'       => 'I[Task] /\\ taskEndTime;taskEndTime~ |- -taskExpectsResult!(actResult~;(I[Activity] /\\ actEndTime;actEndTime~);actTask) /\\ -isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~)'
              , 'origin'        => 'line 82:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'A task can only be marked as complete when every result that it, or one of its subtasks, expects, has been realized'
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(I[Task] /\\ taskEndTime;taskEndTime~ |- -taskExpectsResult!(actResult~;(I[Activity] /\\ actEndTime;actEndTime~);actTask) /\\ -isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~))
              // <=> { remove |- }
              //     -(-(I[Task] /\\ taskEndTime;taskEndTime~) \\/ (-taskExpectsResult!(actResult~;(I[Activity] /\\ actEndTime;actEndTime~);actTask) /\\ -isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~)))
              // <=> { De Morgan }
              //     I[Task] /\\ taskEndTime;taskEndTime~ /\\ -(-taskExpectsResult!(actResult~;(I[Activity] /\\ actEndTime;actEndTime~);actTask) /\\ -isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~))
              // <=> { -l!r = l~//rj and distribute ! over /\\ }
              //     I[Task] /\\ taskEndTime;taskEndTime~ /\\ -(taskExpectsResult~ \\ actResult~;(I[Activity] /\\ actEndTime;actEndTime~);actTask /\\ -isSubtaskOf~!I[Task] /\\ -isSubtaskOf~!(taskEndTime;taskEndTime~))
              // <=> { -l~!r = l//rj and -l~!r = l//rj }
              //     I[Task] /\\ taskEndTime;taskEndTime~ /\\ -(taskExpectsResult~ \\ actResult~;(I[Activity] /\\ actEndTime;actEndTime~);actTask /\\ isSubtaskOf \\ I[Task] /\\ isSubtaskOf \\ taskEndTime;taskEndTime~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Task
              //      ,EIsc (ECps (EDcD rel_taskEndTimeTaskTimestamp
              //                  ,EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //                  )
              //            ,ECpl (EIsc (ERrs (EFlp (EDcD rel_taskExpectsResultTaskResult)
              //                              ,ECps (EFlp (EDcD rel_actResultActivityResult)
              //                                    ,ECps (EIsc (EDcI cpt_Activity
              //                                                ,ECps (EDcD rel_actEndTimeActivityTimestamp
              //                                                      ,EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //                                                      )
              //                                                )
              //                                          ,EDcD rel_actTaskActivityTask
              //                                          )
              //                                    )
              //                              )
              //                        ,EIsc (ERrs (EDcD rel_isSubtaskOfTaskTask
              //                                    ,EDcI cpt_Task
              //                                    )
              //                              ,ERrs (EDcD rel_isSubtaskOfTaskTask
              //                                    ,ECps (EDcD rel_taskEndTimeTaskTimestamp
              //                                          ,EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //                                          )
              //                                    )
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Task] /\\\\ taskEndTime;taskEndTime~ /\\\\ -(taskExpectsResult~ \\\\ actResult~;(I[Activity] /\\\\ actEndTime;actEndTime~);actTask /\\\\ isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~) ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskEndTime;taskEndTime~ */
                                 
                                 SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`taskEndTime`=ECps1.`taskEndTime`
                               ) AS isect0, 
                               ( /* Case EDcI Task */
                                 SELECT `Task` AS `Task`
                                 FROM `Task` ) AS isect1
                          WHERE isect0.`SrcTask` = isect0.`TgtTask` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 taskExpectsResult~ \\\\ actResult~;(I[Activity] /\\\\ actEndTime;actEndTime~);actTask /\\\\ isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                              SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                              FROM 
                                                   ( /* case: ERrs (l,r)
                                                        taskExpectsResult~ \\\\ actResult~;(I[Activity] /\\\\ actEndTime;actEndTime~);actTask ([Task*Task]) */
                                                     SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                                     FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM `taskExpectsResult` AS lhs
                                                             WHERE `RResLeft`.`Task`=lhs.`Task` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    actResult~;(I[Activity] /\\\\ actEndTime;actEndTime~);actTask */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps2.`actTask` AS `TgtTask`
                                                                                 FROM `Activity` AS ECps0,
                                                                                      
                                                                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                                           I[Activity] /\\\\ actEndTime;actEndTime~ ([Activity*Activity]) */
                                                                                        SELECT DISTINCT isect0.`SrcActivity`, isect0.`TgtActivity`
                                                                                        FROM 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  actEndTime;actEndTime~ */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                                                               FROM `Activity` AS ECps0,
                                                                                                    `Activity` AS ECps1
                                                                                               WHERE ECps0.`actEndTime`=ECps1.`actEndTime`
                                                                                             ) AS isect0, 
                                                                                             ( /* Case EDcI Activity */
                                                                                               SELECT `Activity` AS `Activity`
                                                                                               FROM `Activity` ) AS isect1
                                                                                        WHERE isect0.`SrcActivity` = isect0.`TgtActivity` AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL
                                                                                      ) AS ECps1,
                                                                                      `Activity` AS ECps2
                                                                                 WHERE ECps0.`Activity`=ECps1.`SrcActivity`
                                                                                   AND ECps1.`TgtActivity`=ECps2.`Activity`
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcResult`=lhs.`Result` AND rhs.`TgtTask`=`RResRight`.`Task`
                                                                   )
                                                           )
                                                   ) AS isect0, 
                                                   
                                                   ( /* case: ERrs (l,r)
                                                        isSubtaskOf \\\\ I[Task] ([Task*Task]) */
                                                     SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                                     FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM `isSubtaskOf` AS lhs
                                                             WHERE `RResLeft`.`Task`=lhs.`TgtTask` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM ( /* Case EDcI Task */
                                                                                 SELECT `Task` AS `Task`
                                                                                 FROM `Task` ) AS rhs
                                                                     WHERE rhs.`Task`=lhs.`SrcTask` AND rhs.`Task1`=`RResRight`.`Task`
                                                                   )
                                                           )
                                                   ) AS isect1, 
                                                   
                                                   ( /* case: ERrs (l,r)
                                                        isSubtaskOf \\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                                     SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                                     FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM `isSubtaskOf` AS lhs
                                                             WHERE `RResLeft`.`Task`=lhs.`TgtTask` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    taskEndTime;taskEndTime~ */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                                 FROM `Task` AS ECps0,
                                                                                      `Task` AS ECps1
                                                                                 WHERE ECps0.`taskEndTime`=ECps1.`taskEndTime`
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcTask`=lhs.`SrcTask` AND rhs.`TgtTask`=`RResRight`.`Task`
                                                                   )
                                                           )
                                                   ) AS isect2
                                              WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtTask` = isect1.`TgtTask`) AND (isect0.`SrcTask` = isect2.`SrcTask` AND isect0.`TgtTask` = isect2.`TgtTask`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcTask`=cp.`SrcTask` AND isect0.`TgtTask`=cp.`TgtTask`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Deploying ITService' =>
        array ( 'name'          => 'Deploying ITService'
              , 'ruleAdl'       => 'actExecutingOU~;actUsesITSvc |- compOwner~;compITService'
              , 'origin'        => 'line 86:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'If an OrgUnit executes an activity that uses an ITService, then the OrgUnit must have at least one computer on which this ITService is available.'
              , 'message'       => 'ITService needs to be made available:'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(actExecutingOU~;actUsesITSvc |- compOwner~;compITService)
              // <=> { remove |- }
              //     -(-(actExecutingOU~;actUsesITSvc) \\/ compOwner~;compITService)
              // <=> { De Morgan }
              //     actExecutingOU~;actUsesITSvc /\\ -(compOwner~;compITService)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //            ,EDcD rel_actUsesITSvcActivityITService
              //            )
              //      ,ECpl (ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                  ,EDcD rel_compITServiceComputerITService
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actExecutingOU~;actUsesITSvc /\\\\ -(compOwner~;compITService) ([OrgUnit*ITService]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtITService` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;actUsesITSvc */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                 FROM `Activity` AS ECps0,
                                      `actUsesITSvc` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compOwner~;compITService */
                                              
                                              SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                              FROM `Computer` AS ECps0,
                                                   `compITService` AS ECps1
                                              WHERE ECps0.`Computer`=ECps1.`Computer`
                                            ) AS cp
                                            WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'OrgUnit ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' requires ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    )
              )
    , 'inscompITService' =>
        array ( 'name'          => 'inscompITService'
              , 'ruleAdl'       => '(scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor) \\/ scDeployedOn~;scImplements |- compITService'
              , 'origin'        => 'line 97:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -((scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor) \\/ scDeployedOn~;scImplements |- compITService)
              // <=> { remove |- }
              //     -(-((scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor) \\/ scDeployedOn~;scImplements) \\/ compITService)
              // <=> { De Morgan }
              //     -(-(scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor) /\\ -(scDeployedOn~;scImplements)) /\\ -compITService
              // <=> { De Morgan }
              //     -((-(scDeployedOn~;scIsClientFor) \\/ -((I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor)) /\\ -(scDeployedOn~;scImplements)) /\\ -compITService
              // <=> { distribute ; over \\/ }
              //     -((-(scDeployedOn~;scIsClientFor) \\/ -(I[Computer];scDeployedOn~;scIsServerFor \\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor)) /\\ -(scDeployedOn~;scImplements)) /\\ -compITService
              // <=> { I;x = x }
              //     -((-(scDeployedOn~;scIsClientFor) \\/ -(scDeployedOn~;scIsServerFor \\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor)) /\\ -(scDeployedOn~;scImplements)) /\\ -compITService
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (EUni (ECpl (ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                    ,EDcD rel_scIsClientForSvcComponentITService
              //                                    ))
              //                        ,ECpl (EUni (ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                          ,EDcD rel_scIsServerForSvcComponentITService
              //                                          )
              //                                    ,ECps (EDcD rel_compRouterComputerRouter
              //                                          ,ECps (EDcD rel_rrtStarRouterRouter
              //                                                ,ECps (EFlp (EDcD rel_compRouterComputerRouter)
              //                                                      ,ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                                            ,EDcD rel_scIsServerForSvcComponentITService
              //                                                            )
              //                                                      )
              //                                                )
              //                                          )
              //                                    ))
              //                        )
              //                  ,ECpl (ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                              ,EDcD rel_scImplementsSvcComponentITService
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_compITServiceComputerITService)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -((-(scDeployedOn~;scIsClientFor) \\\\/ -(scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor)) /\\\\ -(scDeployedOn~;scImplements)) /\\\\ -compITService ([Computer*ITService]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtITService` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"(-(scDeployedOn~;scIsClientFor) \\\\/ -(scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor)) /\\\\ -(scDeployedOn~;scImplements)\\" ) */
                                 SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`ITService` AS `TgtITService`
                                 FROM `Computer` AS cfst,
                                      `ITService` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             (-(scDeployedOn~;scIsClientFor) \\\\/ -(scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor)) /\\\\ -(scDeployedOn~;scImplements) ([Computer*ITService]) */
                                          SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtITService`
                                          FROM 
                                               ( /* case: EUni (l,r)
                                                    -(scDeployedOn~;scIsClientFor) \\\\/ -(scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor) ([Computer*ITService]) */
                                                 (/* case: ECpl e
                                                        ECpl ( \\"scDeployedOn~;scIsClientFor\\" ) */
                                                     SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`ITService` AS `TgtITService`
                                                     FROM `Computer` AS cfst,
                                                          `ITService` AS csnd
                                                     WHERE NOT EXISTS
                                                      (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 scDeployedOn~;scIsClientFor */
                                                              
                                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                              FROM `scDeployedOn` AS ECps0,
                                                                   `scIsClientFor` AS ECps1
                                                              WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                            ) AS cp
                                                       WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`ITService`=cp.`TgtITService`)
                                                 ) UNION (/* case: ECpl e
                                                        ECpl ( \\"scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor\\" ) */
                                                     SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`ITService` AS `TgtITService`
                                                     FROM `Computer` AS cfst,
                                                          `ITService` AS csnd
                                                     WHERE NOT EXISTS
                                                      (SELECT * FROM 
                                                            ( /* case: EUni (l,r)
                                                                 scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor ([Computer*ITService]) */
                                                              (/* case: (ECps es), with two or more elements in es.
                                                                     scDeployedOn~;scIsServerFor */
                                                                  
                                                                  SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                                  FROM `scDeployedOn` AS ECps0,
                                                                       `scIsServerFor` AS ECps1
                                                                  WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                              ) UNION (/* case: (ECps es), with two or more elements in es.
                                                                     compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor */
                                                                  
                                                                  SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps4.`ITService` AS `TgtITService`
                                                                  FROM `compRouter` AS ECps0,
                                                                       `rrtStar` AS ECps1,
                                                                       `compRouter` AS ECps2,
                                                                       `scDeployedOn` AS ECps3,
                                                                       `scIsServerFor` AS ECps4
                                                                  WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                    AND ECps1.`TgtRouter`=ECps2.`Router`
                                                                    AND ECps2.`Computer`=ECps3.`Computer`
                                                                    AND ECps3.`SvcComponent`=ECps4.`SvcComponent`
                                                              )
                                                            ) AS cp
                                                       WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`ITService`=cp.`TgtITService`)
                                                 )
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 scDeployedOn~;scImplements */
                                                              
                                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                              FROM `scDeployedOn` AS ECps0,
                                                                   `scImplements` AS ECps1
                                                              WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                            ) AS cp
                                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`ITService`=cp.`TgtITService`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `compITService` AS cp
                                            WHERE isect0.`SrcComputer`=cp.`Computer` AND isect0.`TgtITService`=cp.`ITService`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compITService;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    )
              )
    , 'delcompITService' =>
        array ( 'name'          => 'delcompITService'
              , 'ruleAdl'       => 'compITService |- scDeployedOn~;scImplements \\/ (scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor)'
              , 'origin'        => 'line 102:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(compITService |- scDeployedOn~;scImplements \\/ (scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor))
              // <=> { remove |- }
              //     -(-compITService \\/ scDeployedOn~;scImplements \\/ (scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor))
              // <=> { De Morgan }
              //     compITService /\\ -(scDeployedOn~;scImplements) /\\ -(scDeployedOn~;scIsClientFor /\\ (I[Computer] \\/ compRouter;rrtStar;compRouter~);scDeployedOn~;scIsServerFor)
              // <=> { distribute ; over \\/ }
              //     compITService /\\ -(scDeployedOn~;scImplements) /\\ -(scDeployedOn~;scIsClientFor /\\ (I[Computer];scDeployedOn~;scIsServerFor \\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor))
              // <=> { I;x = x }
              //     compITService /\\ -(scDeployedOn~;scImplements) /\\ -(scDeployedOn~;scIsClientFor /\\ (scDeployedOn~;scIsServerFor \\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compITServiceComputerITService
              //      ,EIsc (ECpl (ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                        ,EDcD rel_scImplementsSvcComponentITService
              //                        ))
              //            ,ECpl (EIsc (ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                              ,EDcD rel_scIsClientForSvcComponentITService
              //                              )
              //                        ,EUni (ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                    ,EDcD rel_scIsServerForSvcComponentITService
              //                                    )
              //                              ,ECps (EDcD rel_compRouterComputerRouter
              //                                    ,ECps (EDcD rel_rrtStarRouterRouter
              //                                          ,ECps (EFlp (EDcD rel_compRouterComputerRouter)
              //                                                ,ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                                      ,EDcD rel_scIsServerForSvcComponentITService
              //                                                      )
              //                                                )
              //                                          )
              //                                    )
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compITService /\\\\ -(scDeployedOn~;scImplements) /\\\\ -(scDeployedOn~;scIsClientFor /\\\\ (scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor)) ([Computer*ITService]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`ITService` AS `tgt`
                          FROM `compITService` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 scDeployedOn~;scImplements */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                              FROM `scDeployedOn` AS ECps0,
                                                   `scImplements` AS ECps1
                                              WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`ITService`=cp.`TgtITService`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 scDeployedOn~;scIsClientFor /\\\\ (scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor) ([Computer*ITService]) */
                                              SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtITService`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        scDeployedOn~;scIsClientFor */
                                                     
                                                     SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                     FROM `scDeployedOn` AS ECps0,
                                                          `scIsClientFor` AS ECps1
                                                     WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                   ) AS isect0, 
                                                   
                                                   ( /* case: EUni (l,r)
                                                        scDeployedOn~;scIsServerFor \\\\/ compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor ([Computer*ITService]) */
                                                     (/* case: (ECps es), with two or more elements in es.
                                                            scDeployedOn~;scIsServerFor */
                                                         
                                                         SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                         FROM `scDeployedOn` AS ECps0,
                                                              `scIsServerFor` AS ECps1
                                                         WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                     ) UNION (/* case: (ECps es), with two or more elements in es.
                                                            compRouter;rrtStar;compRouter~;scDeployedOn~;scIsServerFor */
                                                         
                                                         SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps4.`ITService` AS `TgtITService`
                                                         FROM `compRouter` AS ECps0,
                                                              `rrtStar` AS ECps1,
                                                              `compRouter` AS ECps2,
                                                              `scDeployedOn` AS ECps3,
                                                              `scIsServerFor` AS ECps4
                                                         WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                           AND ECps1.`TgtRouter`=ECps2.`Router`
                                                           AND ECps2.`Computer`=ECps3.`Computer`
                                                           AND ECps3.`SvcComponent`=ECps4.`SvcComponent`
                                                     )
                                                   ) AS isect1
                                              WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtITService` = isect1.`TgtITService`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`ITService`=cp.`TgtITService`) AND isect0.`Computer` IS NOT NULL AND isect0.`ITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compITService;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    )
              )
    , 'Create path within network' =>
        array ( 'name'          => 'Create path within network'
              , 'ruleAdl'       => 'routerNeedsPathTo /\\ routerNW;routerNW~ /\\ -I[Router] |- rrtStar'
              , 'origin'        => 'line 112:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'Any routes within a network, for which there is a need, must exist.'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNeedsPathTo /\\ routerNW;routerNW~ /\\ -I[Router] |- rrtStar)
              // <=> { remove |- }
              //     -(-(routerNeedsPathTo /\\ routerNW;routerNW~ /\\ -I[Router]) \\/ rrtStar)
              // <=> { De Morgan }
              //     routerNeedsPathTo /\\ routerNW;routerNW~ /\\ -I[Router] /\\ -rrtStar
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerNeedsPathToRouterRouter
              //      ,EIsc (ECps (EDcD rel_routerNWRouterNetwork
              //                  ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                  )
              //            ,EIsc (ECpl (EDcI cpt_Router)
              //                  ,ECpl (EDcD rel_rrtStarRouterRouter)
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNeedsPathTo /\\\\ routerNW;routerNW~ /\\\\ -I[Router] /\\\\ -rrtStar ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM `routerNeedsPathTo` AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect1
                          WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TgtRouter` = isect1.`TgtRouter`) AND isect0.`SrcRouter` <> isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM `rrtStar` AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;rrtDirect;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Remove routes from non-network routers' =>
        array ( 'name'          => 'Remove routes from non-network routers'
              , 'ruleAdl'       => 'rrtDirect |- routerNW;(I[Network] \\/ -I[Network]);routerNW~'
              , 'origin'        => 'line 117:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'Routes from or to a router that is not part of a network cannot exist.'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtDirect |- routerNW;(I[Network] \\/ -I[Network]);routerNW~)
              // <=> { remove |- }
              //     -(-rrtDirect \\/ routerNW;(I[Network] \\/ -I[Network]);routerNW~)
              // <=> { De Morgan }
              //     rrtDirect /\\ -(routerNW;(I[Network] \\/ -I[Network]);routerNW~)
              // <=> { distribute ; over \\/ }
              //     rrtDirect /\\ -(routerNW;(I[Network];routerNW~ \\/ -I[Network];routerNW~))
              // <=> { distribute ; over \\/ }
              //     rrtDirect /\\ -(routerNW;I[Network];routerNW~ \\/ routerNW;-I[Network];routerNW~)
              // <=> { De Morgan }
              //     rrtDirect /\\ -(routerNW;I[Network];routerNW~) /\\ -(routerNW;-I[Network];routerNW~)
              // <=> { I;x = x }
              //     rrtDirect /\\ -(routerNW;routerNW~) /\\ -(routerNW;-I[Network];routerNW~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_rrtDirectRouterRouter
              //      ,EIsc (ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                        ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                        ))
              //            ,ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                        ,ECps (ECpl (EDcI cpt_Network)
              //                              ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             rrtDirect /\\\\ -(routerNW;routerNW~) /\\\\ -(routerNW;-I[Network];routerNW~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM `rrtDirect` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNW;routerNW~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   `Router` AS ECps1
                                              WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNW;-I[Network];routerNW~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   `Router` AS ECps2
                                              WHERE ECps0.`routerNW`<>ECps2.`routerNW`
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerRoutesTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Remove computers from non-network routers' =>
        array ( 'name'          => 'Remove computers from non-network routers'
              , 'ruleAdl'       => 'compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~)'
              , 'origin'        => 'line 123:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'Computers may not be connected to routers that are not part of a network.'
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter |- compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { remove |- }
              //     -(-compRouter \\/ compRouter;(I[Router] /\\ routerNW;routerNW~))
              // <=> { De Morgan }
              //     compRouter /\\ -(compRouter;(I[Router] /\\ routerNW;routerNW~))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compRouterComputerRouter
              //      ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                  ,EIsc (EDcI cpt_Router
              //                        ,ECps (EDcD rel_routerNWRouterNetwork
              //                              ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRouter /\\\\ -(compRouter;(I[Router] /\\\\ routerNW;routerNW~)) ([Computer*Router]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`Router` AS `tgt`
                          FROM `compRouter` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compRouter;(I[Router] /\\\\ routerNW;routerNW~) */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`TgtRouter`
                                              FROM `compRouter` AS ECps0,
                                                   
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        I[Router] /\\\\ routerNW;routerNW~ ([Router*Router]) */
                                                     SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               routerNW;routerNW~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                                            FROM `Router` AS ECps0,
                                                                 `Router` AS ECps1
                                                            WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                                          ) AS isect0, 
                                                          ( /* Case EDcI Router */
                                                            SELECT `Router` AS `Router`
                                                            FROM `Router` ) AS isect1
                                                     WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                                   ) AS ECps1
                                              WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Router`=cp.`TgtRouter`) AND isect0.`Computer` IS NOT NULL AND isect0.`Router` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compRouter;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InscompReqCommWith' =>
        array ( 'name'          => 'InscompReqCommWith'
              , 'ruleAdl'       => '-I[Computer] /\\ (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn |- compReqCommWith'
              , 'origin'        => 'line 130:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(-I[Computer] /\\ (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn |- compReqCommWith)
              // <=> { remove |- }
              //     -(-(-I[Computer] /\\ (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn) \\/ compReqCommWith)
              // <=> { De Morgan }
              //     -I[Computer] /\\ (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn /\\ -compReqCommWith
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EDcI cpt_Computer)
              //      ,EIsc (ECps (EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                              ,ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                    ,EDcD rel_actUsesITSvcActivityITService
              //                                    )
              //                              )
              //                        ,ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                              ,EDcD rel_scIsClientForSvcComponentITService
              //                              )
              //                        )
              //                  ,ECps (EFlp (EDcD rel_scIsServerForSvcComponentITService)
              //                        ,EDcD rel_scDeployedOnSvcComponentComputer
              //                        )
              //                  )
              //            ,ECpl (EDcD rel_compReqCommWithComputerComputer)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -I[Computer] /\\\\ (compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn /\\\\ -compReqCommWith ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    (compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                 FROM 
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor ([Computer*ITService]) */
                                        SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtITService`
                                        FROM 
                                             ( /* case: (ECps es), with two or more elements in es.
                                                  compOwner;actExecutingOU~;actUsesITSvc */
                                               
                                               SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`ITService` AS `TgtITService`
                                               FROM `Computer` AS ECps0,
                                                    `Activity` AS ECps1,
                                                    `actUsesITSvc` AS ECps2
                                               WHERE ECps0.`compOwner`=ECps1.`actExecutingOU`
                                                 AND ECps1.`Activity`=ECps2.`Activity`
                                             ) AS isect0, 
                                             
                                             ( /* case: (ECps es), with two or more elements in es.
                                                  scDeployedOn~;scIsClientFor */
                                               
                                               SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                               FROM `scDeployedOn` AS ECps0,
                                                    `scIsClientFor` AS ECps1
                                               WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                             ) AS isect1
                                        WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtITService` = isect1.`TgtITService`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL
                                      ) AS ECps0,
                                      `scIsServerFor` AS ECps1,
                                      `scDeployedOn` AS ECps2
                                 WHERE ECps0.`TgtITService`=ECps1.`ITService`
                                   AND ECps1.`SvcComponent`=ECps2.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `compReqCommWith` AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompReqCommWith' =>
        array ( 'name'          => 'DelcompReqCommWith'
              , 'ruleAdl'       => 'compReqCommWith |- (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn \\/ ((compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn)~'
              , 'origin'        => 'line 136:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compReqCommWith |- (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn \\/ ((compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn)~)
              // <=> { remove |- }
              //     -(-compReqCommWith \\/ (compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn \\/ ((compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn)~)
              // <=> { De Morgan }
              //     compReqCommWith /\\ -((compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn) /\\ -((compOwner;actExecutingOU~;actUsesITSvc /\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn)~
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compReqCommWithComputerComputer
              //      ,EIsc (ECpl (ECps (EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                                    ,ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                          ,EDcD rel_actUsesITSvcActivityITService
              //                                          )
              //                                    )
              //                              ,ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                    ,EDcD rel_scIsClientForSvcComponentITService
              //                                    )
              //                              )
              //                        ,ECps (EFlp (EDcD rel_scIsServerForSvcComponentITService)
              //                              ,EDcD rel_scDeployedOnSvcComponentComputer
              //                              )
              //                        ))
              //            ,ECpl (EFlp (EBrk (ECps (EBrk (EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                                                      ,ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                                            ,EDcD rel_actUsesITSvcActivityITService
              //                                                            )
              //                                                      )
              //                                                ,ECps (EFlp (EDcD rel_scDeployedOnSvcComponentComputer)
              //                                                      ,EDcD rel_scIsClientForSvcComponentITService
              //                                                      )
              //                                                ))
              //                                    ,ECps (EFlp (EDcD rel_scIsServerForSvcComponentITService)
              //                                          ,EDcD rel_scDeployedOnSvcComponentComputer
              //                                          )
              //                                    ))))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compReqCommWith /\\\\ -((compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn) /\\\\ -((compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn)~ ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM `compReqCommWith` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 (compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn */
                                              
                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM 
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor ([Computer*ITService]) */
                                                     SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtITService`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               compOwner;actExecutingOU~;actUsesITSvc */
                                                            
                                                            SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`ITService` AS `TgtITService`
                                                            FROM `Computer` AS ECps0,
                                                                 `Activity` AS ECps1,
                                                                 `actUsesITSvc` AS ECps2
                                                            WHERE ECps0.`compOwner`=ECps1.`actExecutingOU`
                                                              AND ECps1.`Activity`=ECps2.`Activity`
                                                          ) AS isect0, 
                                                          
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               scDeployedOn~;scIsClientFor */
                                                            
                                                            SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                            FROM `scDeployedOn` AS ECps0,
                                                                 `scIsClientFor` AS ECps1
                                                            WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                          ) AS isect1
                                                     WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtITService` = isect1.`TgtITService`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL
                                                   ) AS ECps0,
                                                   `scIsServerFor` AS ECps1,
                                                   `scDeployedOn` AS ECps2
                                              WHERE ECps0.`TgtITService`=ECps1.`ITService`
                                                AND ECps1.`SvcComponent`=ECps2.`SvcComponent`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 (compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor);scIsServerFor~;scDeployedOn */
                                              
                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM 
                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                        compOwner;actExecutingOU~;actUsesITSvc /\\\\ scDeployedOn~;scIsClientFor ([Computer*ITService]) */
                                                     SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtITService`
                                                     FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               compOwner;actExecutingOU~;actUsesITSvc */
                                                            
                                                            SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`ITService` AS `TgtITService`
                                                            FROM `Computer` AS ECps0,
                                                                 `Activity` AS ECps1,
                                                                 `actUsesITSvc` AS ECps2
                                                            WHERE ECps0.`compOwner`=ECps1.`actExecutingOU`
                                                              AND ECps1.`Activity`=ECps2.`Activity`
                                                          ) AS isect0, 
                                                          
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               scDeployedOn~;scIsClientFor */
                                                            
                                                            SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`ITService` AS `TgtITService`
                                                            FROM `scDeployedOn` AS ECps0,
                                                                 `scIsClientFor` AS ECps1
                                                            WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                                                          ) AS isect1
                                                     WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtITService` = isect1.`TgtITService`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL
                                                   ) AS ECps0,
                                                   `scIsServerFor` AS ECps1,
                                                   `scDeployedOn` AS ECps2
                                              WHERE ECps0.`TgtITService`=ECps1.`ITService`
                                                AND ECps1.`SvcComponent`=ECps2.`SvcComponent`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`TgtComputer` AND isect0.`TgtComputer`=cp.`SrcComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compReqCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompRequiresComm' =>
        array ( 'name'          => 'InscompRequiresComm'
              , 'ruleAdl'       => 'I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRequiresComm'
              , 'origin'        => 'line 145:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compReqCommWith;compReqCommWith~ |- compRequiresComm)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compReqCommWith;compReqCommWith~) \\/ compRequiresComm)
              // <=> { De Morgan }
              //     I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compRequiresComm
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compReqCommWithComputerComputer
              //                  ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                  )
              //            ,ECpl (EDcD rel_compRequiresCommComputerComputer)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ -compRequiresComm ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                 FROM `compReqCommWith` AS ECps0,
                                      `compReqCommWith` AS ECps1
                                 WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                               ) AS isect0, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.Computer AND isect0.`TgtComputer`=cp.`compRequiresComm`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compRequiresComm;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompRequiresComm' =>
        array ( 'name'          => 'DelcompRequiresComm'
              , 'ruleAdl'       => 'compRequiresComm |- I[Computer] /\\ compReqCommWith;compReqCommWith~'
              , 'origin'        => 'line 148:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm |- I[Computer] /\\ compReqCommWith;compReqCommWith~)
              // <=> { remove |- }
              //     -(-compRequiresComm \\/ (I[Computer] /\\ compReqCommWith;compReqCommWith~))
              // <=> { De Morgan }
              //     compRequiresComm /\\ -(I[Computer] /\\ compReqCommWith;compReqCommWith~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compRequiresCommComputerComputer
              //      ,ECpl (EIsc (EDcI cpt_Computer
              //                  ,ECps (EDcD rel_compReqCommWithComputerComputer
              //                        ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRequiresComm /\\\\ -(I[Computer] /\\\\ compReqCommWith;compReqCommWith~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compRequiresComm` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Computer] /\\\\ compReqCommWith;compReqCommWith~ ([Computer*Computer]) */
                                              SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compReqCommWith;compReqCommWith~ */
                                                     
                                                     SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                                     FROM `compReqCommWith` AS ECps0,
                                                          `compReqCommWith` AS ECps1
                                                     WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                                                   ) AS isect0, 
                                                   ( /* Case EDcI Computer */
                                                     SELECT `Computer` AS `Computer`
                                                     FROM `Computer` ) AS isect1
                                              WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Computer=cp.`SrcComputer` AND isect0.`compRequiresComm`=cp.`TgtComputer`) AND isect0.Computer IS NOT NULL AND isect0.`compRequiresComm` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compRequiresComm;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompHasCommWith' =>
        array ( 'name'          => 'InscompHasCommWith'
              , 'ruleAdl'       => 'compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer] |- compHasCommWith'
              , 'origin'        => 'line 153:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer] |- compHasCommWith)
              // <=> { remove |- }
              //     -(-(compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer]) \\/ compHasCommWith)
              // <=> { De Morgan }
              //     compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer] /\\ -compHasCommWith
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compReqCommWithComputerComputer
              //      ,EIsc (ECps (EDcD rel_compRouterComputerRouter
              //                  ,ECps (EDcD rel_rrtStarRouterRouter
              //                        ,EFlp (EDcD rel_compRouterComputerRouter)
              //                        )
              //                  )
              //            ,EIsc (ECpl (EDcI cpt_Computer)
              //                  ,ECpl (EDcD rel_compHasCommWithComputerComputer)
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compReqCommWith /\\\\ compRouter;rrtStar;compRouter~ /\\\\ -I[Computer] /\\\\ -compHasCommWith ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM `compReqCommWith` AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;rrtStar;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                 FROM `compRouter` AS ECps0,
                                      `rrtStar` AS ECps1,
                                      `compRouter` AS ECps2
                                 WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                   AND ECps1.`TgtRouter`=ECps2.`Router`
                               ) AS isect1
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND isect0.`SrcComputer` <> isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compHasCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelcompHasCommWith' =>
        array ( 'name'          => 'DelcompHasCommWith'
              , 'ruleAdl'       => 'compHasCommWith |- compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer]'
              , 'origin'        => 'line 156:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compHasCommWith |- compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer])
              // <=> { remove |- }
              //     -(-compHasCommWith \\/ (compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer]))
              // <=> { De Morgan }
              //     compHasCommWith /\\ -(compReqCommWith /\\ compRouter;rrtStar;compRouter~ /\\ -I[Computer])
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compHasCommWithComputerComputer
              //      ,ECpl (EIsc (EDcD rel_compReqCommWithComputerComputer
              //                  ,EIsc (ECps (EDcD rel_compRouterComputerRouter
              //                              ,ECps (EDcD rel_rrtStarRouterRouter
              //                                    ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                    )
              //                              )
              //                        ,ECpl (EDcI cpt_Computer)
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compHasCommWith /\\\\ -(compReqCommWith /\\\\ compRouter;rrtStar;compRouter~ /\\\\ -I[Computer]) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM `compHasCommWith` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 compReqCommWith /\\\\ compRouter;rrtStar;compRouter~ /\\\\ -I[Computer] ([Computer*Computer]) */
                                              SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                              FROM `compReqCommWith` AS isect0, 
                                                   
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compRouter;rrtStar;compRouter~ */
                                                     
                                                     SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                     FROM `compRouter` AS ECps0,
                                                          `rrtStar` AS ECps1,
                                                          `compRouter` AS ECps2
                                                     WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                       AND ECps1.`TgtRouter`=ECps2.`Router`
                                                   ) AS isect1
                                              WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compHasCommWith;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompAllReqCommSatisfied' =>
        array ( 'name'          => 'InscompAllReqCommSatisfied'
              , 'ruleAdl'       => 'I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~ |- compAllReqCommSatisfied'
              , 'origin'        => 'line 161:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~ |- compAllReqCommSatisfied)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~) \\/ compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~ /\\ -compAllReqCommSatisfied
              // <=> { -l!r = l~//rj }
              //     I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ compReqCommWith~ \\ (compRouter;rrtStar;compRouter~)~ /\\ -compAllReqCommSatisfied
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compReqCommWithComputerComputer
              //                  ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                  )
              //            ,EIsc (ERrs (EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                        ,EFlp (EBrk (ECps (EDcD rel_compRouterComputerRouter
              //                                          ,ECps (EDcD rel_rrtStarRouterRouter
              //                                                ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                                )
              //                                          )))
              //                        )
              //                  ,ECpl (EDcD rel_compAllReqCommSatisfiedComputerComputer)
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ compReqCommWith~ \\\\ (compRouter;rrtStar;compRouter~)~ /\\\\ -compAllReqCommSatisfied ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compReqCommWith;compReqCommWith~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                 FROM `compReqCommWith` AS ECps0,
                                      `compReqCommWith` AS ECps1
                                 WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                               ) AS isect0, 
                               
                               ( /* case: ERrs (l,r)
                                    compReqCommWith~ \\\\ (compRouter;rrtStar;compRouter~)~ ([Computer*Computer]) */
                                 SELECT `RResLeft`.`Computer` AS `SrcComputer`, `RResRight`.`Computer` AS `TgtComputer`
                                 FROM `Computer` AS `RResLeft`, `Computer` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM `compReqCommWith` AS lhs
                                         WHERE `RResLeft`.`Computer`=lhs.`SrcComputer` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                compRouter;rrtStar;compRouter~ */
                                                             
                                                             SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                             FROM `compRouter` AS ECps0,
                                                                  `rrtStar` AS ECps1,
                                                                  `compRouter` AS ECps2
                                                             WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                               AND ECps1.`TgtRouter`=ECps2.`Router`
                                                           ) AS rhs
                                                 WHERE rhs.`TgtComputer`=lhs.`TgtComputer` AND rhs.`SrcComputer`=`RResRight`.`Computer`
                                               )
                                       )
                               ) AS isect1, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect2
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.Computer AND isect0.`TgtComputer`=cp.`compAllReqCommSatisfied`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compAllReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelCompAllReqCommSatisfied' =>
        array ( 'name'          => 'DelCompAllReqCommSatisfied'
              , 'ruleAdl'       => 'compAllReqCommSatisfied |- I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~'
              , 'origin'        => 'line 164:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied |- I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~)
              // <=> { remove |- }
              //     -(-compAllReqCommSatisfied \\/ (I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~))
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ -(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ -compReqCommWith!(compRouter;rrtStar;compRouter~)~)
              // <=> { -l!r = l~//rj }
              //     compAllReqCommSatisfied /\\ -(I[Computer] /\\ compReqCommWith;compReqCommWith~ /\\ compReqCommWith~ \\ (compRouter;rrtStar;compRouter~)~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compAllReqCommSatisfiedComputerComputer
              //      ,ECpl (EIsc (EDcI cpt_Computer
              //                  ,EIsc (ECps (EDcD rel_compReqCommWithComputerComputer
              //                              ,EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                              )
              //                        ,ERrs (EFlp (EDcD rel_compReqCommWithComputerComputer)
              //                              ,EFlp (EBrk (ECps (EDcD rel_compRouterComputerRouter
              //                                                ,ECps (EDcD rel_rrtStarRouterRouter
              //                                                      ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                                      )
              //                                                )))
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compAllReqCommSatisfied /\\\\ -(I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ compReqCommWith~ \\\\ (compRouter;rrtStar;compRouter~)~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compAllReqCommSatisfied` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Computer] /\\\\ compReqCommWith;compReqCommWith~ /\\\\ compReqCommWith~ \\\\ (compRouter;rrtStar;compRouter~)~ ([Computer*Computer]) */
                                              SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compReqCommWith;compReqCommWith~ */
                                                     
                                                     SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                                     FROM `compReqCommWith` AS ECps0,
                                                          `compReqCommWith` AS ECps1
                                                     WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                                                   ) AS isect0, 
                                                   
                                                   ( /* case: ERrs (l,r)
                                                        compReqCommWith~ \\\\ (compRouter;rrtStar;compRouter~)~ ([Computer*Computer]) */
                                                     SELECT `RResLeft`.`Computer` AS `SrcComputer`, `RResRight`.`Computer` AS `TgtComputer`
                                                     FROM `Computer` AS `RResLeft`, `Computer` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM `compReqCommWith` AS lhs
                                                             WHERE `RResLeft`.`Computer`=lhs.`SrcComputer` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    compRouter;rrtStar;compRouter~ */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                                                 FROM `compRouter` AS ECps0,
                                                                                      `rrtStar` AS ECps1,
                                                                                      `compRouter` AS ECps2
                                                                                 WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                                   AND ECps1.`TgtRouter`=ECps2.`Router`
                                                                               ) AS rhs
                                                                     WHERE rhs.`TgtComputer`=lhs.`TgtComputer` AND rhs.`SrcComputer`=`RResRight`.`Computer`
                                                                   )
                                                           )
                                                   ) AS isect1, 
                                                   ( /* Case EDcI Computer */
                                                     SELECT `Computer` AS `Computer`
                                                     FROM `Computer` ) AS isect2
                                              WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND isect0.`SrcComputer` = isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Computer=cp.`SrcComputer` AND isect0.`compAllReqCommSatisfied`=cp.`TgtComputer`) AND isect0.Computer IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compAllReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'InscompNoReqCommSatisfied' =>
        array ( 'name'          => 'InscompNoReqCommSatisfied'
              , 'ruleAdl'       => 'I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~) |- compNoReqCommSatisfied'
              , 'origin'        => 'line 169:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~) |- compNoReqCommSatisfied)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~)) \\/ compNoReqCommSatisfied)
              // <=> { De Morgan }
              //     I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~) /\\ -compNoReqCommSatisfied
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECpl (ECps (EDcD rel_compReqCommWithComputerComputer
              //                        ,EFlp (EBrk (ECps (EDcD rel_compRouterComputerRouter
              //                                          ,ECps (EDcD rel_rrtStarRouterRouter
              //                                                ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                                )
              //                                          )))
              //                        ))
              //            ,ECpl (EDcD rel_compNoReqCommSatisfiedComputerComputer)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~) /\\\\ -compNoReqCommSatisfied ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`Computer` AS `tgt`
                          FROM ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compReqCommWith;(compRouter;rrtStar;compRouter~)~ */
                                              
                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                              FROM `compReqCommWith` AS ECps0,
                                                   
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compRouter;rrtStar;compRouter~ */
                                                     
                                                     SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                     FROM `compRouter` AS ECps0,
                                                          `rrtStar` AS ECps1,
                                                          `compRouter` AS ECps2
                                                     WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                       AND ECps1.`TgtRouter`=ECps2.`Router`
                                                   ) AS ECps1
                                              WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Computer`=cp.`TgtComputer`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`Computer`=cp.Computer AND isect0.`Computer`=cp.`compNoReqCommSatisfied`) AND isect0.`Computer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compNoReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'DelCompNoReqCommSatisfied' =>
        array ( 'name'          => 'DelCompNoReqCommSatisfied'
              , 'ruleAdl'       => 'compNoReqCommSatisfied |- I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~)'
              , 'origin'        => 'line 172:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied |- I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~))
              // <=> { remove |- }
              //     -(-compNoReqCommSatisfied \\/ (I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~)))
              // <=> { De Morgan }
              //     compNoReqCommSatisfied /\\ -(I[Computer] /\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compNoReqCommSatisfiedComputerComputer
              //      ,ECpl (EIsc (EDcI cpt_Computer
              //                  ,ECpl (ECps (EDcD rel_compReqCommWithComputerComputer
              //                              ,EFlp (EBrk (ECps (EDcD rel_compRouterComputerRouter
              //                                                ,ECps (EDcD rel_rrtStarRouterRouter
              //                                                      ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                                      )
              //                                                )))
              //                              ))
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compNoReqCommSatisfied /\\\\ -(I[Computer] /\\\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~)) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compNoReqCommSatisfied` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Computer] /\\\\ -(compReqCommWith;(compRouter;rrtStar;compRouter~)~) ([Computer*Computer]) */
                                              SELECT DISTINCT isect0.`Computer` AS `SrcComputer`, isect0.`Computer` AS `TgtComputer`
                                              FROM ( /* Case EDcI Computer */
                                                     SELECT `Computer` AS `Computer`
                                                     FROM `Computer` ) AS isect0
                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     compReqCommWith;(compRouter;rrtStar;compRouter~)~ */
                                                                  
                                                                  SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`SrcComputer` AS `TgtComputer`
                                                                  FROM `compReqCommWith` AS ECps0,
                                                                       
                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                            compRouter;rrtStar;compRouter~ */
                                                                         
                                                                         SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                                         FROM `compRouter` AS ECps0,
                                                                              `rrtStar` AS ECps1,
                                                                              `compRouter` AS ECps2
                                                                         WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                           AND ECps1.`TgtRouter`=ECps2.`Router`
                                                                       ) AS ECps1
                                                                  WHERE ECps0.`TgtComputer`=ECps1.`TgtComputer`
                                                                ) AS cp
                                                                WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Computer`=cp.`TgtComputer`) AND isect0.`Computer` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Computer=cp.`SrcComputer` AND isect0.`compNoReqCommSatisfied`=cp.`TgtComputer`) AND isect0.Computer IS NOT NULL AND isect0.`compNoReqCommSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;compNoReqCommSatisfied;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'rrtCompTransitiveClosure' =>
        array ( 'name'          => 'rrtCompTransitiveClosure'
              , 'ruleAdl'       => 'routerRoutesTo = rrtDirect'
              , 'origin'        => 'line 182:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerRoutesTo = rrtDirect)
              // <=> { remove = }
              //     -((routerRoutesTo |- rrtDirect) /\\ (rrtDirect |- routerRoutesTo))
              // <=> { remove |- and remove |- }
              //     -((-routerRoutesTo \\/ rrtDirect) /\\ (-rrtDirect \\/ routerRoutesTo))
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EIsc (EUni (ECpl (EDcD rel_routerRoutesToRouterRouter)
              //                  ,EDcD rel_rrtDirectRouterRouter
              //                  )
              //            ,EUni (ECpl (EDcD rel_rrtDirectRouterRouter)
              //                  ,EDcD rel_routerRoutesToRouterRouter
              //                  )
              //            ))
              , 'violationsSQL' => '/* case: ECpl e
                             ECpl ( \\"(-routerRoutesTo \\\\/ rrtDirect) /\\\\ (-rrtDirect \\\\/ routerRoutesTo)\\" ) */
                          SELECT DISTINCT cfst.`Router` AS `src`, csnd.`Router` AS `tgt`
                          FROM `Router` AS cfst,
                               `Router` AS csnd
                          WHERE NOT EXISTS
                           (SELECT * FROM 
                                 ( /* case: (EIsc lst\\\'@(_:_:_))
                                      (-routerRoutesTo \\\\/ rrtDirect) /\\\\ (-rrtDirect \\\\/ routerRoutesTo) ([Router*Router]) */
                                   SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                   FROM 
                                        ( /* case: EUni (l,r)
                                             -routerRoutesTo \\\\/ rrtDirect ([Router*Router]) */
                                          (/* case: ECpl e
                                                 ECpl ( \\"routerRoutesTo\\" ) */
                                              SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TgtRouter`
                                              FROM `Router` AS cfst,
                                                   `Router` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM `routerRoutesTo` AS cp
                                                WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TgtRouter`)
                                          ) UNION (SELECT DISTINCT `SrcRouter`, `TgtRouter`
                                              FROM `rrtDirect`
                                              WHERE `SrcRouter` IS NOT NULL AND `TgtRouter` IS NOT NULL
                                          )
                                        ) AS isect0, 
                                        
                                        ( /* case: EUni (l,r)
                                             -rrtDirect \\\\/ routerRoutesTo ([Router*Router]) */
                                          (/* case: ECpl e
                                                 ECpl ( \\"rrtDirect\\" ) */
                                              SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TgtRouter`
                                              FROM `Router` AS cfst,
                                                   `Router` AS csnd
                                              WHERE NOT EXISTS
                                               (SELECT * FROM `rrtDirect` AS cp
                                                WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TgtRouter`)
                                          ) UNION (SELECT DISTINCT `SrcRouter`, `TgtRouter`
                                              FROM `routerRoutesTo`
                                              WHERE `SrcRouter` IS NOT NULL AND `TgtRouter` IS NOT NULL
                                          )
                                        ) AS isect1
                                   WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TgtRouter` = isect1.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                 ) AS cp
                            WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TgtRouter`)'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} TransitiveClosure;routerRoutesTo;Router;rrtDirect;rrtStar')
                    )
              )
    , 'rrtStar Transitive closure integrity' =>
        array ( 'name'          => 'rrtStar Transitive closure integrity'
              , 'ruleAdl'       => 'rrtStar;rrtStar |- rrtStar'
              , 'origin'        => 'line 187:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'Violation of this rule means that the demo is becoming more complex than was expected, and therefore may produce signals that are not correct. Please read the documentation (in the source code)'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(rrtStar;rrtStar |- rrtStar)
              // <=> { remove |- }
              //     -(-(rrtStar;rrtStar) \\/ rrtStar)
              // <=> { De Morgan }
              //     rrtStar;rrtStar /\\ -rrtStar
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_rrtStarRouterRouter
              //            ,EDcD rel_rrtStarRouterRouter
              //            )
              //      ,ECpl (EDcD rel_rrtStarRouterRouter)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             rrtStar;rrtStar /\\\\ -rrtStar ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    rrtStar;rrtStar */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`TgtRouter`
                                 FROM `rrtStar` AS ECps0,
                                      `rrtStar` AS ECps1
                                 WHERE ECps0.`TgtRouter`=ECps1.`SrcRouter`
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `rrtStar` AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'InsrouterNeedsPathTo' =>
        array ( 'name'          => 'InsrouterNeedsPathTo'
              , 'ruleAdl'       => 'compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router] |- routerNeedsPathTo'
              , 'origin'        => 'line 193:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'A router needs a path to another router if both routers are connected to computers that need to communicate but do not have a communications path to do this.'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router] |- routerNeedsPathTo)
              // <=> { remove |- }
              //     -(-(compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router]) \\/ routerNeedsPathTo)
              // <=> { De Morgan }
              //     compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router] /\\ -routerNeedsPathTo
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_compRouterComputerRouter)
              //            ,ECps (EIsc (EDcD rel_compReqCommWithComputerComputer
              //                        ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                                    ,ECps (EDcD rel_rrtStarRouterRouter
              //                                          ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                          )
              //                                    ))
              //                        )
              //                  ,EDcD rel_compRouterComputerRouter
              //                  )
              //            )
              //      ,EIsc (ECpl (EDcI cpt_Router)
              //            ,ECpl (EDcD rel_routerNeedsPathToRouterRouter)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRouter~;(compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~));compRouter /\\\\ -I[Router] /\\\\ -routerNeedsPathTo ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter~;(compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~));compRouter */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                 FROM `compRouter` AS ECps0,
                                      
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~) ([Computer*Computer]) */
                                        SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                        FROM `compReqCommWith` AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               compRouter;rrtStar;compRouter~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                            FROM `compRouter` AS ECps0,
                                                                 `rrtStar` AS ECps1,
                                                                 `compRouter` AS ECps2
                                                            WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                              AND ECps1.`TgtRouter`=ECps2.`Router`
                                                          ) AS cp
                                                          WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                      ) AS ECps1,
                                      `compRouter` AS ECps2
                                 WHERE ECps0.`Computer`=ECps1.`SrcComputer`
                                   AND ECps1.`TgtComputer`=ECps2.`Computer`
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM `routerNeedsPathTo` AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerNeedsPathTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterNeedsPathTo' =>
        array ( 'name'          => 'DelrouterNeedsPathTo'
              , 'ruleAdl'       => 'routerNeedsPathTo |- compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router]'
              , 'origin'        => 'line 197:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNeedsPathTo |- compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router])
              // <=> { remove |- }
              //     -(-routerNeedsPathTo \\/ (compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router]))
              // <=> { De Morgan }
              //     routerNeedsPathTo /\\ -(compRouter~;(compReqCommWith /\\ -(compRouter;rrtStar;compRouter~));compRouter /\\ -I[Router])
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerNeedsPathToRouterRouter
              //      ,ECpl (EIsc (ECps (EFlp (EDcD rel_compRouterComputerRouter)
              //                        ,ECps (EIsc (EDcD rel_compReqCommWithComputerComputer
              //                                    ,ECpl (ECps (EDcD rel_compRouterComputerRouter
              //                                                ,ECps (EDcD rel_rrtStarRouterRouter
              //                                                      ,EFlp (EDcD rel_compRouterComputerRouter)
              //                                                      )
              //                                                ))
              //                                    )
              //                              ,EDcD rel_compRouterComputerRouter
              //                              )
              //                        )
              //                  ,ECpl (EDcI cpt_Router)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNeedsPathTo /\\\\ -(compRouter~;(compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~));compRouter /\\\\ -I[Router]) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM `routerNeedsPathTo` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 compRouter~;(compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~));compRouter /\\\\ -I[Router] ([Router*Router]) */
                                              SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compRouter~;(compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~));compRouter */
                                                     
                                                     SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                                     FROM `compRouter` AS ECps0,
                                                          
                                                          ( /* case: (EIsc lst\\\'@(_:_:_))
                                                               compReqCommWith /\\\\ -(compRouter;rrtStar;compRouter~) ([Computer*Computer]) */
                                                            SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                                            FROM `compReqCommWith` AS isect0
                                                            WHERE NOT EXISTS (SELECT * FROM 
                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                   compRouter;rrtStar;compRouter~ */
                                                                                
                                                                                SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                                                                FROM `compRouter` AS ECps0,
                                                                                     `rrtStar` AS ECps1,
                                                                                     `compRouter` AS ECps2
                                                                                WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                                  AND ECps1.`TgtRouter`=ECps2.`Router`
                                                                              ) AS cp
                                                                              WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                                          ) AS ECps1,
                                                          `compRouter` AS ECps2
                                                     WHERE ECps0.`Computer`=ECps1.`SrcComputer`
                                                       AND ECps1.`TgtComputer`=ECps2.`Computer`
                                                   ) AS isect0
                                              WHERE isect0.`SrcRouter` <> isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerNeedsPathTo;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsrouterAllCommReqsSatisfied' =>
        array ( 'name'          => 'InsrouterAllCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~) |- routerAllCommReqsSatisfied'
              , 'origin'        => 'line 202:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~) |- routerAllCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)) \\/ routerAllCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~) /\\ -routerAllCommReqsSatisfied
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECpl (ECps (EDcD rel_routerNeedsPathToRouterRouter
              //                        ,EFlp (EDcD rel_routerNeedsPathToRouterRouter)
              //                        ))
              //            ,ECpl (EDcD rel_routerAllCommReqsSatisfiedRouterRouter)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ -(routerNeedsPathTo;routerNeedsPathTo~) /\\\\ -routerAllCommReqsSatisfied ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`Router` AS `tgt`
                          FROM ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNeedsPathTo;routerNeedsPathTo~ */
                                              
                                              SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`SrcRouter` AS `TgtRouter`
                                              FROM `routerNeedsPathTo` AS ECps0,
                                                   `routerNeedsPathTo` AS ECps1
                                              WHERE ECps0.`TgtRouter`=ECps1.`TgtRouter`
                                            ) AS cp
                                            WHERE isect0.`Router`=cp.`SrcRouter` AND isect0.`Router`=cp.`TgtRouter`) AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                            WHERE isect0.`Router`=cp.Router AND isect0.`Router`=cp.`routerAllCommReqsSatisfied`) AND isect0.`Router` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerAllCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterAllCommReqsSatisfied' =>
        array ( 'name'          => 'DelrouterAllCommReqsSatisfied'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied |- I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)'
              , 'origin'        => 'line 205:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied |- I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~))
              // <=> { remove |- }
              //     -(-routerAllCommReqsSatisfied \\/ (I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~)))
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied /\\ -(I[Router] /\\ -(routerNeedsPathTo;routerNeedsPathTo~))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //      ,ECpl (EIsc (EDcI cpt_Router
              //                  ,ECpl (ECps (EDcD rel_routerNeedsPathToRouterRouter
              //                              ,EFlp (EDcD rel_routerNeedsPathToRouterRouter)
              //                              ))
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerAllCommReqsSatisfied /\\\\ -(I[Router] /\\\\ -(routerNeedsPathTo;routerNeedsPathTo~)) ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`routerAllCommReqsSatisfied` AS `tgt`
                          FROM `Router` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Router] /\\\\ -(routerNeedsPathTo;routerNeedsPathTo~) ([Router*Router]) */
                                              SELECT DISTINCT isect0.`Router` AS `SrcRouter`, isect0.`Router` AS `TgtRouter`
                                              FROM ( /* Case EDcI Router */
                                                     SELECT `Router` AS `Router`
                                                     FROM `Router` ) AS isect0
                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     routerNeedsPathTo;routerNeedsPathTo~ */
                                                                  
                                                                  SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`SrcRouter` AS `TgtRouter`
                                                                  FROM `routerNeedsPathTo` AS ECps0,
                                                                       `routerNeedsPathTo` AS ECps1
                                                                  WHERE ECps0.`TgtRouter`=ECps1.`TgtRouter`
                                                                ) AS cp
                                                                WHERE isect0.`Router`=cp.`SrcRouter` AND isect0.`Router`=cp.`TgtRouter`) AND isect0.`Router` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Router=cp.`SrcRouter` AND isect0.`routerAllCommReqsSatisfied`=cp.`TgtRouter`) AND isect0.Router IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerAllCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsrouterNoCommReqsSatisfied' =>
        array ( 'name'          => 'InsrouterNoCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter |- routerNoCommReqsSatisfied'
              , 'origin'        => 'line 210:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter |- routerNoCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter) \\/ routerNoCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter /\\ -routerNoCommReqsSatisfied
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECps (EFlp (EDcD rel_compRouterComputerRouter)
              //                  ,ECps (EIsc (EDcI cpt_Computer
              //                              ,EIsc (EDcD rel_compReqCommWithComputerComputer
              //                                    ,ECpl (EDcD rel_compHasCommWithComputerComputer)
              //                                    )
              //                              )
              //                        ,EDcD rel_compRouterComputerRouter
              //                        )
              //                  )
              //            ,ECpl (EDcD rel_routerNoCommReqsSatisfiedRouterRouter)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ compRouter~;(I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith);compRouter /\\\\ -routerNoCommReqsSatisfied ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter~;(I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith);compRouter */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                 FROM `compRouter` AS ECps0,
                                      
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith ([Computer*Computer]) */
                                        SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                        FROM `compReqCommWith` AS isect0, 
                                             ( /* Case EDcI Computer */
                                               SELECT `Computer` AS `Computer`
                                               FROM `Computer` ) AS isect1
                                        WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                          WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                      ) AS ECps1,
                                      `compRouter` AS ECps2
                                 WHERE ECps0.`Computer`=ECps1.`SrcComputer`
                                   AND ECps1.`TgtComputer`=ECps2.`Computer`
                               ) AS isect0, 
                               ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect1
                          WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                            WHERE isect0.`SrcRouter`=cp.Router AND isect0.`TgtRouter`=cp.`routerNoCommReqsSatisfied`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerNoCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'DelrouterNoCommReqsSatisfied' =>
        array ( 'name'          => 'DelrouterNoCommReqsSatisfied'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied |- I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter'
              , 'origin'        => 'line 213:1, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied |- I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter)
              // <=> { remove |- }
              //     -(-routerNoCommReqsSatisfied \\/ (I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter))
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied /\\ -(I[Router] /\\ compRouter~;(I[Computer] /\\ compReqCommWith /\\ -compHasCommWith);compRouter)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //      ,ECpl (EIsc (EDcI cpt_Router
              //                  ,ECps (EFlp (EDcD rel_compRouterComputerRouter)
              //                        ,ECps (EIsc (EDcI cpt_Computer
              //                                    ,EIsc (EDcD rel_compReqCommWithComputerComputer
              //                                          ,ECpl (EDcD rel_compHasCommWithComputerComputer)
              //                                          )
              //                                    )
              //                              ,EDcD rel_compRouterComputerRouter
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNoCommReqsSatisfied /\\\\ -(I[Router] /\\\\ compRouter~;(I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith);compRouter) ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`routerNoCommReqsSatisfied` AS `tgt`
                          FROM `Router` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Router] /\\\\ compRouter~;(I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith);compRouter ([Router*Router]) */
                                              SELECT DISTINCT isect0.`SrcRouter`, isect0.`TgtRouter`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        compRouter~;(I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith);compRouter */
                                                     
                                                     SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                                     FROM `compRouter` AS ECps0,
                                                          
                                                          ( /* case: (EIsc lst\\\'@(_:_:_))
                                                               I[Computer] /\\\\ compReqCommWith /\\\\ -compHasCommWith ([Computer*Computer]) */
                                                            SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtComputer`
                                                            FROM `compReqCommWith` AS isect0, 
                                                                 ( /* Case EDcI Computer */
                                                                   SELECT `Computer` AS `Computer`
                                                                   FROM `Computer` ) AS isect1
                                                            WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                                              WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL
                                                          ) AS ECps1,
                                                          `compRouter` AS ECps2
                                                     WHERE ECps0.`Computer`=ECps1.`SrcComputer`
                                                       AND ECps1.`TgtComputer`=ECps2.`Computer`
                                                   ) AS isect0, 
                                                   ( /* Case EDcI Router */
                                                     SELECT `Router` AS `Router`
                                                     FROM `Router` ) AS isect1
                                              WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Router=cp.`SrcRouter` AND isect0.`routerNoCommReqsSatisfied`=cp.`TgtRouter`) AND isect0.Router IS NOT NULL AND isect0.`routerNoCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;routerNoCommReqsSatisfied;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'InsnwAllCompCommReqsSatisfied' =>
        array ( 'name'          => 'InsnwAllCompCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW) |- nwAllCompCommReqsSatisfied'
              , 'origin'        => 'line 17:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW) |- nwAllCompCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW)) \\/ nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW) /\\ -nwAllCompCommReqsSatisfied
              // <=> { -l~!r = l//rj }
              //     I[Network] /\\ routerNW \\ routerAllCommReqsSatisfied;routerNW /\\ -nwAllCompCommReqsSatisfied
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Network
              //      ,EIsc (ERrs (EDcD rel_routerNWRouterNetwork
              //                  ,ECps (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //                        ,EDcD rel_routerNWRouterNetwork
              //                        )
              //                  )
              //            ,ECpl (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Network] /\\\\ routerNW \\\\ routerAllCommReqsSatisfied;routerNW /\\\\ -nwAllCompCommReqsSatisfied ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: ERrs (l,r)
                                    routerNW \\\\ routerAllCommReqsSatisfied;routerNW ([Network*Network]) */
                                 SELECT `RResLeft`.`Network` AS `SrcNetwork`, `RResRight`.`Network` AS `TgtNetwork`
                                 FROM `Network` AS `RResLeft`, `Network` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM `Router` AS lhs
                                         WHERE `RResLeft`.`Network`=lhs.`routerNW` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                routerAllCommReqsSatisfied;routerNW */
                                                             
                                                             SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`routerNW` AS `TgtNetwork`
                                                             FROM `Router` AS ECps0,
                                                                  `Router` AS ECps1
                                                             WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.`Router`
                                                           ) AS rhs
                                                 WHERE rhs.`SrcRouter`=lhs.`Router` AND rhs.`TgtNetwork`=`RResRight`.`Network`
                                               )
                                       )
                               ) AS isect0, 
                               ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect1
                          WHERE isect0.`SrcNetwork` = isect0.`TgtNetwork` AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                            WHERE isect0.`SrcNetwork`=cp.Network AND isect0.`TgtNetwork`=cp.`nwAllCompCommReqsSatisfied`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwAllCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    )
              )
    , 'DelnwAllCompCommReqsSatisfied' =>
        array ( 'name'          => 'DelnwAllCompCommReqsSatisfied'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied |- I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW)'
              , 'origin'        => 'line 20:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied |- I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW))
              // <=> { remove |- }
              //     -(-nwAllCompCommReqsSatisfied \\/ (I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW)))
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied /\\ -(I[Network] /\\ -routerNW~!(routerAllCommReqsSatisfied;routerNW))
              // <=> { -l~!r = l//rj }
              //     nwAllCompCommReqsSatisfied /\\ -(I[Network] /\\ routerNW \\ routerAllCommReqsSatisfied;routerNW)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //      ,ECpl (EIsc (EDcI cpt_Network
              //                  ,ERrs (EDcD rel_routerNWRouterNetwork
              //                        ,ECps (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //                              ,EDcD rel_routerNWRouterNetwork
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwAllCompCommReqsSatisfied /\\\\ -(I[Network] /\\\\ routerNW \\\\ routerAllCommReqsSatisfied;routerNW) ([Network*Network]) */
                          SELECT DISTINCT isect0.`Network` AS `src`, isect0.`nwAllCompCommReqsSatisfied` AS `tgt`
                          FROM `Network` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Network] /\\\\ routerNW \\\\ routerAllCommReqsSatisfied;routerNW ([Network*Network]) */
                                              SELECT DISTINCT isect0.`SrcNetwork`, isect0.`TgtNetwork`
                                              FROM 
                                                   ( /* case: ERrs (l,r)
                                                        routerNW \\\\ routerAllCommReqsSatisfied;routerNW ([Network*Network]) */
                                                     SELECT `RResLeft`.`Network` AS `SrcNetwork`, `RResRight`.`Network` AS `TgtNetwork`
                                                     FROM `Network` AS `RResLeft`, `Network` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM `Router` AS lhs
                                                             WHERE `RResLeft`.`Network`=lhs.`routerNW` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    routerAllCommReqsSatisfied;routerNW */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`routerNW` AS `TgtNetwork`
                                                                                 FROM `Router` AS ECps0,
                                                                                      `Router` AS ECps1
                                                                                 WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.`Router`
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcRouter`=lhs.`Router` AND rhs.`TgtNetwork`=`RResRight`.`Network`
                                                                   )
                                                           )
                                                   ) AS isect0, 
                                                   ( /* Case EDcI Network */
                                                     SELECT `Network` AS `Network`
                                                     FROM `Network` ) AS isect1
                                              WHERE isect0.`SrcNetwork` = isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Network=cp.`SrcNetwork` AND isect0.`nwAllCompCommReqsSatisfied`=cp.`TgtNetwork`) AND isect0.Network IS NOT NULL AND isect0.`nwAllCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;nwAllCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    )
              )
    , 'InsnwNoCompCommReqsSatisfied' =>
        array ( 'name'          => 'InsnwNoCompCommReqsSatisfied'
              , 'ruleAdl'       => 'I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW) |- nwNoCompCommReqsSatisfied'
              , 'origin'        => 'line 25:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW) |- nwNoCompCommReqsSatisfied)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW)) \\/ nwNoCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW) /\\ -nwNoCompCommReqsSatisfied
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Network
              //      ,EIsc (ECpl (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //                        ,ECps (ECpl (EDcD rel_routerNoCommReqsSatisfiedRouterRouter)
              //                              ,EDcD rel_routerNWRouterNetwork
              //                              )
              //                        ))
              //            ,ECpl (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Network] /\\\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW) /\\\\ -nwNoCompCommReqsSatisfied ([Network*Network]) */
                          SELECT DISTINCT isect0.`Network` AS `src`, isect0.`Network` AS `tgt`
                          FROM ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNW~;-routerNoCommReqsSatisfied;routerNW */
                                              
                                              SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps2.`routerNW` AS `TgtNetwork`
                                              FROM `Router` AS ECps0,
                                                   
                                                   ( /* case: ECpl e
                                                        ECpl ( \\"routerNoCommReqsSatisfied\\" ) */
                                                     SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TgtRouter`
                                                     FROM `Router` AS cfst,
                                                          `Router` AS csnd
                                                     WHERE NOT EXISTS
                                                      (SELECT * FROM `Router` AS cp
                                                       WHERE cfst.`Router`=cp.Router AND csnd.`Router`=cp.`routerNoCommReqsSatisfied`)
                                                   ) AS ECps1,
                                                   `Router` AS ECps2
                                              WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                AND ECps1.`TgtRouter`=ECps2.`Router`
                                            ) AS cp
                                            WHERE isect0.`Network`=cp.`SrcNetwork` AND isect0.`Network`=cp.`TgtNetwork`) AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                            WHERE isect0.`Network`=cp.Network AND isect0.`Network`=cp.`nwNoCompCommReqsSatisfied`) AND isect0.`Network` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwNoCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    )
              )
    , 'DelnwNoCompCommReqsSatisfied' =>
        array ( 'name'          => 'DelnwNoCompCommReqsSatisfied'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied |- I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW)'
              , 'origin'        => 'line 28:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied |- I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW))
              // <=> { remove |- }
              //     -(-nwNoCompCommReqsSatisfied \\/ (I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW)))
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied /\\ -(I[Network] /\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //      ,ECpl (EIsc (EDcI cpt_Network
              //                  ,ECpl (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //                              ,ECps (ECpl (EDcD rel_routerNoCommReqsSatisfiedRouterRouter)
              //                                    ,EDcD rel_routerNWRouterNetwork
              //                                    )
              //                              ))
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwNoCompCommReqsSatisfied /\\\\ -(I[Network] /\\\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW)) ([Network*Network]) */
                          SELECT DISTINCT isect0.`Network` AS `src`, isect0.`nwNoCompCommReqsSatisfied` AS `tgt`
                          FROM `Network` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Network] /\\\\ -(routerNW~;-routerNoCommReqsSatisfied;routerNW) ([Network*Network]) */
                                              SELECT DISTINCT isect0.`Network` AS `SrcNetwork`, isect0.`Network` AS `TgtNetwork`
                                              FROM ( /* Case EDcI Network */
                                                     SELECT `Network` AS `Network`
                                                     FROM `Network` ) AS isect0
                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     routerNW~;-routerNoCommReqsSatisfied;routerNW */
                                                                  
                                                                  SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps2.`routerNW` AS `TgtNetwork`
                                                                  FROM `Router` AS ECps0,
                                                                       
                                                                       ( /* case: ECpl e
                                                                            ECpl ( \\"routerNoCommReqsSatisfied\\" ) */
                                                                         SELECT DISTINCT cfst.`Router` AS `SrcRouter`, csnd.`Router` AS `TgtRouter`
                                                                         FROM `Router` AS cfst,
                                                                              `Router` AS csnd
                                                                         WHERE NOT EXISTS
                                                                          (SELECT * FROM `Router` AS cp
                                                                           WHERE cfst.`Router`=cp.Router AND csnd.`Router`=cp.`routerNoCommReqsSatisfied`)
                                                                       ) AS ECps1,
                                                                       `Router` AS ECps2
                                                                  WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                                    AND ECps1.`TgtRouter`=ECps2.`Router`
                                                                ) AS cp
                                                                WHERE isect0.`Network`=cp.`SrcNetwork` AND isect0.`Network`=cp.`TgtNetwork`) AND isect0.`Network` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Network=cp.`SrcNetwork` AND isect0.`nwNoCompCommReqsSatisfied`=cp.`TgtNetwork`) AND isect0.Network IS NOT NULL AND isect0.`nwNoCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;nwNoCompCommReqsSatisfied;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    )
              )
    , 'Network status integrity check' =>
        array ( 'name'          => 'Network status integrity check'
              , 'ruleAdl'       => 'routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied |- -I[Network]'
              , 'origin'        => 'line 32:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'Network status integrity check'
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied |- -I[Network])
              // <=> { remove |- }
              //     -(-(routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied) \\/ -I[Network])
              // <=> { De Morgan }
              //     routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied /\\ I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //            ,EDcD rel_routerNWRouterNetwork
              //            )
              //      ,EIsc (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //            ,EIsc (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //                  ,EDcI cpt_Network
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNW~;routerNW /\\\\ nwAllCompCommReqsSatisfied /\\\\ nwNoCompCommReqsSatisfied /\\\\ I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps1.`routerNW` AS `TgtNetwork`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0, 
                               `Network` AS isect1, 
                               `Network` AS isect2, 
                               ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect3
                          WHERE (isect0.`SrcNetwork` = isect1.Network AND isect0.`TgtNetwork` = isect1.`nwAllCompCommReqsSatisfied`) AND (isect0.`SrcNetwork` = isect2.Network AND isect0.`TgtNetwork` = isect2.`nwNoCompCommReqsSatisfied`) AND isect0.`SrcNetwork` = isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent network properties: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    )
              )
    , 'Network status \'Green\'' =>
        array ( 'name'          => 'Network status \'Green\''
              , 'ruleAdl'       => 'I[Network] /\\ routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied |- nwStatus;\'Green\'[Status];nwStatus~'
              , 'origin'        => 'line 37:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied |- nwStatus;\'Green\'[Status];nwStatus~)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied) \\/ nwStatus;\'Green\'[Status];nwStatus~)
              // <=> { De Morgan }
              //     I[Network] /\\ routerNW~;routerNW /\\ nwAllCompCommReqsSatisfied /\\ -(nwStatus;\'Green\'[Status];nwStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Network
              //      ,EIsc (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //                  ,EDcD rel_routerNWRouterNetwork
              //                  )
              //            ,EIsc (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //                  ,ECpl (ECps (EDcD rel_nwStatusNetworkStatus
              //                              ,ECps (EMp1 "Green" cpt_Status
              //                                    ,EFlp (EDcD rel_nwStatusNetworkStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Network] /\\\\ routerNW~;routerNW /\\\\ nwAllCompCommReqsSatisfied /\\\\ -(nwStatus;\\\'Green\\\'[Status];nwStatus~) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps1.`routerNW` AS `TgtNetwork`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0, 
                               `Network` AS isect1, 
                               ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect2
                          WHERE (isect0.`SrcNetwork` = isect1.Network AND isect0.`TgtNetwork` = isect1.`nwAllCompCommReqsSatisfied`) AND isect0.`SrcNetwork` = isect0.`TgtNetwork` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 nwStatus;\\\'Green\\\'[Status];nwStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps2.`Network` AS `TgtNetwork`
                                              FROM `Network` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Network` AS ECps2
                                              WHERE ECps0.`nwStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`nwStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TgtNetwork`=cp.`TgtNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Network status \'Yellow\'' =>
        array ( 'name'          => 'Network status \'Yellow\''
              , 'ruleAdl'       => 'I[Network] /\\ routerNW~;routerNW /\\ -nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied |- nwStatus;\'Yellow\'[Status];nwStatus~'
              , 'origin'        => 'line 42:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ routerNW~;routerNW /\\ -nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied |- nwStatus;\'Yellow\'[Status];nwStatus~)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ routerNW~;routerNW /\\ -nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied) \\/ nwStatus;\'Yellow\'[Status];nwStatus~)
              // <=> { De Morgan }
              //     I[Network] /\\ routerNW~;routerNW /\\ -nwAllCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied /\\ -(nwStatus;\'Yellow\'[Status];nwStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Network
              //      ,EIsc (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //                  ,EDcD rel_routerNWRouterNetwork
              //                  )
              //            ,EIsc (ECpl (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork)
              //                  ,EIsc (ECpl (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork)
              //                        ,ECpl (ECps (EDcD rel_nwStatusNetworkStatus
              //                                    ,ECps (EMp1 "Yellow" cpt_Status
              //                                          ,EFlp (EDcD rel_nwStatusNetworkStatus)
              //                                          )
              //                                    ))
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Network] /\\\\ routerNW~;routerNW /\\\\ -nwAllCompCommReqsSatisfied /\\\\ -nwNoCompCommReqsSatisfied /\\\\ -(nwStatus;\\\'Yellow\\\'[Status];nwStatus~) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps1.`routerNW` AS `TgtNetwork`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0, 
                               ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect1
                          WHERE isect0.`SrcNetwork` = isect0.`TgtNetwork` AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                            WHERE isect0.`SrcNetwork`=cp.Network AND isect0.`TgtNetwork`=cp.`nwAllCompCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM `Network` AS cp
                                            WHERE isect0.`SrcNetwork`=cp.Network AND isect0.`TgtNetwork`=cp.`nwNoCompCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 nwStatus;\\\'Yellow\\\'[Status];nwStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps2.`Network` AS `TgtNetwork`
                                              FROM `Network` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Network` AS ECps2
                                              WHERE ECps0.`nwStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`nwStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TgtNetwork`=cp.`TgtNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Network status \'Red\'' =>
        array ( 'name'          => 'Network status \'Red\''
              , 'ruleAdl'       => 'I[Network] /\\ routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied |- nwStatus;\'Red\'[Status];nwStatus~'
              , 'origin'        => 'line 47:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied |- nwStatus;\'Red\'[Status];nwStatus~)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied) \\/ nwStatus;\'Red\'[Status];nwStatus~)
              // <=> { De Morgan }
              //     I[Network] /\\ routerNW~;routerNW /\\ nwNoCompCommReqsSatisfied /\\ -(nwStatus;\'Red\'[Status];nwStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Network
              //      ,EIsc (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //                  ,EDcD rel_routerNWRouterNetwork
              //                  )
              //            ,EIsc (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //                  ,ECpl (ECps (EDcD rel_nwStatusNetworkStatus
              //                              ,ECps (EMp1 "Red" cpt_Status
              //                                    ,EFlp (EDcD rel_nwStatusNetworkStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Network] /\\\\ routerNW~;routerNW /\\\\ nwNoCompCommReqsSatisfied /\\\\ -(nwStatus;\\\'Red\\\'[Status];nwStatus~) ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps1.`routerNW` AS `TgtNetwork`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0, 
                               `Network` AS isect1, 
                               ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect2
                          WHERE (isect0.`SrcNetwork` = isect1.Network AND isect0.`TgtNetwork` = isect1.`nwNoCompCommReqsSatisfied`) AND isect0.`SrcNetwork` = isect0.`TgtNetwork` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 nwStatus;\\\'Red\\\'[Status];nwStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps2.`Network` AS `TgtNetwork`
                                              FROM `Network` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Network` AS ECps2
                                              WHERE ECps0.`nwStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`nwStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcNetwork`=cp.`SrcNetwork` AND isect0.`TgtNetwork`=cp.`TgtNetwork`) AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Network status \'Blue\'' =>
        array ( 'name'          => 'Network status \'Blue\''
              , 'ruleAdl'       => 'I[Network] /\\ -(routerNW~;routerNW) |- nwStatus;\'Blue\'[Status];nwStatus~'
              , 'origin'        => 'line 52:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(I[Network] /\\ -(routerNW~;routerNW) |- nwStatus;\'Blue\'[Status];nwStatus~)
              // <=> { remove |- }
              //     -(-(I[Network] /\\ -(routerNW~;routerNW)) \\/ nwStatus;\'Blue\'[Status];nwStatus~)
              // <=> { De Morgan }
              //     I[Network] /\\ -(routerNW~;routerNW) /\\ -(nwStatus;\'Blue\'[Status];nwStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Network
              //      ,EIsc (ECpl (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //                        ,EDcD rel_routerNWRouterNetwork
              //                        ))
              //            ,ECpl (ECps (EDcD rel_nwStatusNetworkStatus
              //                        ,ECps (EMp1 "Blue" cpt_Status
              //                              ,EFlp (EDcD rel_nwStatusNetworkStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Network] /\\\\ -(routerNW~;routerNW) /\\\\ -(nwStatus;\\\'Blue\\\'[Status];nwStatus~) ([Network*Network]) */
                          SELECT DISTINCT isect0.`Network` AS `src`, isect0.`Network` AS `tgt`
                          FROM ( /* Case EDcI Network */
                                 SELECT `Network` AS `Network`
                                 FROM `Network` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNW~;routerNW */
                                              
                                              SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps1.`routerNW` AS `TgtNetwork`
                                              FROM `Router` AS ECps0,
                                                   `Router` AS ECps1
                                              WHERE ECps0.`Router`=ECps1.`Router`
                                            ) AS cp
                                            WHERE isect0.`Network`=cp.`SrcNetwork` AND isect0.`Network`=cp.`TgtNetwork`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 nwStatus;\\\'Blue\\\'[Status];nwStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps2.`Network` AS `TgtNetwork`
                                              FROM `Network` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Blue\' AS `SrcStatus`, \'Blue\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Network` AS ECps2
                                              WHERE ECps0.`nwStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`nwStatus`
                                            ) AS cp
                                            WHERE isect0.`Network`=cp.`SrcNetwork` AND isect0.`Network`=cp.`TgtNetwork`) AND isect0.`Network` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;nwStatus;Network;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Network'
                            , 'expSQL' =>
                                '/* I[Network] */
                                   SELECT `Network` AS `src`, `Network` AS `tgt`
                                   FROM `Network`
                                   WHERE `Network` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Router status integrity check' =>
        array ( 'name'          => 'Router status integrity check'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied |- -I[Router]'
              , 'origin'        => 'line 70:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'Router status integrity check'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied |- -I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied) \\/ -I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied /\\ routerNoCommReqsSatisfied /\\ I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //      ,EIsc (EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //            ,EDcI cpt_Router
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerAllCommReqsSatisfied /\\\\ routerNoCommReqsSatisfied /\\\\ I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`routerAllCommReqsSatisfied` AS `tgt`
                          FROM `Router` AS isect0, 
                               `Router` AS isect1, 
                               ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect2
                          WHERE (isect0.Router = isect1.Router AND isect0.`routerAllCommReqsSatisfied` = isect1.`routerNoCommReqsSatisfied`) AND isect0.Router = isect0.`routerAllCommReqsSatisfied` AND isect0.Router IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent router properties: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    )
              )
    , 'Router status \'Green\'' =>
        array ( 'name'          => 'Router status \'Green\''
              , 'ruleAdl'       => 'I[Router] /\\ routerNW;routerNW~ /\\ routerAllCommReqsSatisfied |- routerStatus;\'Green\'[Status];routerStatus~'
              , 'origin'        => 'line 75:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ routerNW;routerNW~ /\\ routerAllCommReqsSatisfied |- routerStatus;\'Green\'[Status];routerStatus~)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ routerNW;routerNW~ /\\ routerAllCommReqsSatisfied) \\/ routerStatus;\'Green\'[Status];routerStatus~)
              // <=> { De Morgan }
              //     I[Router] /\\ routerNW;routerNW~ /\\ routerAllCommReqsSatisfied /\\ -(routerStatus;\'Green\'[Status];routerStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECps (EDcD rel_routerNWRouterNetwork
              //                  ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                  )
              //            ,EIsc (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //                  ,ECpl (ECps (EDcD rel_routerStatusRouterStatus
              //                              ,ECps (EMp1 "Green" cpt_Status
              //                                    ,EFlp (EDcD rel_routerStatusRouterStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ routerNW;routerNW~ /\\\\ routerAllCommReqsSatisfied /\\\\ -(routerStatus;\\\'Green\\\'[Status];routerStatus~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect0, 
                               `Router` AS isect1, 
                               ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect2
                          WHERE (isect0.`SrcRouter` = isect1.Router AND isect0.`TgtRouter` = isect1.`routerAllCommReqsSatisfied`) AND isect0.`SrcRouter` = isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerStatus;\\\'Green\\\'[Status];routerStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Router` AS ECps2
                                              WHERE ECps0.`routerStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`routerStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Router status \'Yellow\'' =>
        array ( 'name'          => 'Router status \'Yellow\''
              , 'ruleAdl'       => 'I[Router] /\\ routerNW;routerNW~ /\\ -routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied |- routerStatus;\'Yellow\'[Status];routerStatus~'
              , 'origin'        => 'line 80:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ routerNW;routerNW~ /\\ -routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied |- routerStatus;\'Yellow\'[Status];routerStatus~)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ routerNW;routerNW~ /\\ -routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied) \\/ routerStatus;\'Yellow\'[Status];routerStatus~)
              // <=> { De Morgan }
              //     I[Router] /\\ routerNW;routerNW~ /\\ -routerAllCommReqsSatisfied /\\ -routerNoCommReqsSatisfied /\\ -(routerStatus;\'Yellow\'[Status];routerStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECps (EDcD rel_routerNWRouterNetwork
              //                  ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                  )
              //            ,EIsc (ECpl (EDcD rel_routerAllCommReqsSatisfiedRouterRouter)
              //                  ,EIsc (ECpl (EDcD rel_routerNoCommReqsSatisfiedRouterRouter)
              //                        ,ECpl (ECps (EDcD rel_routerStatusRouterStatus
              //                                    ,ECps (EMp1 "Yellow" cpt_Status
              //                                          ,EFlp (EDcD rel_routerStatusRouterStatus)
              //                                          )
              //                                    ))
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ routerNW;routerNW~ /\\\\ -routerAllCommReqsSatisfied /\\\\ -routerNoCommReqsSatisfied /\\\\ -(routerStatus;\\\'Yellow\\\'[Status];routerStatus~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect0, 
                               ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect1
                          WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                            WHERE isect0.`SrcRouter`=cp.Router AND isect0.`TgtRouter`=cp.`routerAllCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM `Router` AS cp
                                            WHERE isect0.`SrcRouter`=cp.Router AND isect0.`TgtRouter`=cp.`routerNoCommReqsSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerStatus;\\\'Yellow\\\'[Status];routerStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Router` AS ECps2
                                              WHERE ECps0.`routerStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`routerStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Router status \'Red\'' =>
        array ( 'name'          => 'Router status \'Red\''
              , 'ruleAdl'       => 'I[Router] /\\ routerNW;routerNW~ /\\ routerNoCommReqsSatisfied |- routerStatus;\'Red\'[Status];routerStatus~'
              , 'origin'        => 'line 85:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ routerNW;routerNW~ /\\ routerNoCommReqsSatisfied |- routerStatus;\'Red\'[Status];routerStatus~)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ routerNW;routerNW~ /\\ routerNoCommReqsSatisfied) \\/ routerStatus;\'Red\'[Status];routerStatus~)
              // <=> { De Morgan }
              //     I[Router] /\\ routerNW;routerNW~ /\\ routerNoCommReqsSatisfied /\\ -(routerStatus;\'Red\'[Status];routerStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECps (EDcD rel_routerNWRouterNetwork
              //                  ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                  )
              //            ,EIsc (EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //                  ,ECpl (ECps (EDcD rel_routerStatusRouterStatus
              //                              ,ECps (EMp1 "Red" cpt_Status
              //                                    ,EFlp (EDcD rel_routerStatusRouterStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ routerNW;routerNW~ /\\\\ routerNoCommReqsSatisfied /\\\\ -(routerStatus;\\\'Red\\\'[Status];routerStatus~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW;routerNW~ */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNW`=ECps1.`routerNW`
                               ) AS isect0, 
                               `Router` AS isect1, 
                               ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect2
                          WHERE (isect0.`SrcRouter` = isect1.Router AND isect0.`TgtRouter` = isect1.`routerNoCommReqsSatisfied`) AND isect0.`SrcRouter` = isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerStatus;\\\'Red\\\'[Status];routerStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Router` AS ECps2
                                              WHERE ECps0.`routerStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`routerStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'Router status \'Blue\'' =>
        array ( 'name'          => 'Router status \'Blue\''
              , 'ruleAdl'       => 'I[Router] /\\ -(routerNW;routerNW~) |- routerStatus;\'Blue\'[Status];routerStatus~'
              , 'origin'        => 'line 90:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ -(routerNW;routerNW~) |- routerStatus;\'Blue\'[Status];routerStatus~)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ -(routerNW;routerNW~)) \\/ routerStatus;\'Blue\'[Status];routerStatus~)
              // <=> { De Morgan }
              //     I[Router] /\\ -(routerNW;routerNW~) /\\ -(routerStatus;\'Blue\'[Status];routerStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                        ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                        ))
              //            ,ECpl (ECps (EDcD rel_routerStatusRouterStatus
              //                        ,ECps (EMp1 "Blue" cpt_Status
              //                              ,EFlp (EDcD rel_routerStatusRouterStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ -(routerNW;routerNW~) /\\\\ -(routerStatus;\\\'Blue\\\'[Status];routerStatus~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`Router` AS `tgt`
                          FROM ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNW;routerNW~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   `Router` AS ECps1
                                              WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                            ) AS cp
                                            WHERE isect0.`Router`=cp.`SrcRouter` AND isect0.`Router`=cp.`TgtRouter`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerStatus;\\\'Blue\\\'[Status];routerStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Blue\' AS `SrcStatus`, \'Blue\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Router` AS ECps2
                                              WHERE ECps0.`routerStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`routerStatus`
                                            ) AS cp
                                            WHERE isect0.`Router`=cp.`SrcRouter` AND isect0.`Router`=cp.`TgtRouter`) AND isect0.`Router` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;routerStatus;Router;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Computer status integrity check' =>
        array ( 'name'          => 'Computer status integrity check'
              , 'ruleAdl'       => 'compAllReqCommSatisfied /\\ compNoReqCommSatisfied |- -I[Computer]'
              , 'origin'        => 'line 111:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'Computer status integrity check'
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied /\\ compNoReqCommSatisfied |- -I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied /\\ compNoReqCommSatisfied) \\/ -I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ compNoReqCommSatisfied /\\ I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compAllReqCommSatisfiedComputerComputer
              //      ,EIsc (EDcD rel_compNoReqCommSatisfiedComputerComputer
              //            ,EDcI cpt_Computer
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compAllReqCommSatisfied /\\\\ compNoReqCommSatisfied /\\\\ I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compAllReqCommSatisfied` AS `tgt`
                          FROM `Computer` AS isect0, 
                               `Computer` AS isect1, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect2
                          WHERE (isect0.Computer = isect1.Computer AND isect0.`compAllReqCommSatisfied` = isect1.`compNoReqCommSatisfied`) AND isect0.Computer = isect0.`compAllReqCommSatisfied` AND isect0.Computer IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Inconsistent computer properties: ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    )
              )
    , 'Computer status \'Black\'' =>
        array ( 'name'          => 'Computer status \'Black\''
              , 'ruleAdl'       => 'I[Computer] /\\ -(compOwner;compOwner~) |- compStatus;\'Black\'[Status];compStatus~'
              , 'origin'        => 'line 116:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ -(compOwner;compOwner~) |- compStatus;\'Black\'[Status];compStatus~)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ -(compOwner;compOwner~)) \\/ compStatus;\'Black\'[Status];compStatus~)
              // <=> { De Morgan }
              //     I[Computer] /\\ -(compOwner;compOwner~) /\\ -(compStatus;\'Black\'[Status];compStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECpl (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                        ,EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                        ))
              //            ,ECpl (ECps (EDcD rel_compStatusComputerStatus
              //                        ,ECps (EMp1 "Black" cpt_Status
              //                              ,EFlp (EDcD rel_compStatusComputerStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ -(compOwner;compOwner~) /\\\\ -(compStatus;\\\'Black\\\'[Status];compStatus~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`Computer` AS `tgt`
                          FROM ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compOwner;compOwner~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                              FROM `Computer` AS ECps0,
                                                   `Computer` AS ECps1
                                              WHERE ECps0.`compOwner`=ECps1.`compOwner`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Computer`=cp.`TgtComputer`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compStatus;\\\'Black\\\'[Status];compStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `Computer` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Black\' AS `SrcStatus`, \'Black\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Computer` AS ECps2
                                              WHERE ECps0.`compStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`compStatus`
                                            ) AS cp
                                            WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Computer`=cp.`TgtComputer`) AND isect0.`Computer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Black')
                    )
              )
    , 'Computer status \'Blue\'' =>
        array ( 'name'          => 'Computer status \'Blue\''
              , 'ruleAdl'       => 'I[Computer] /\\ compOwner;compOwner~ /\\ -compRequiresComm |- compStatus;\'Blue\'[Status];compStatus~'
              , 'origin'        => 'line 121:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compOwner;compOwner~ /\\ -compRequiresComm |- compStatus;\'Blue\'[Status];compStatus~)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compOwner;compOwner~ /\\ -compRequiresComm) \\/ compStatus;\'Blue\'[Status];compStatus~)
              // <=> { De Morgan }
              //     I[Computer] /\\ compOwner;compOwner~ /\\ -compRequiresComm /\\ -(compStatus;\'Blue\'[Status];compStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                  ,EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                  )
              //            ,EIsc (ECpl (EDcD rel_compRequiresCommComputerComputer)
              //                  ,ECpl (ECps (EDcD rel_compStatusComputerStatus
              //                              ,ECps (EMp1 "Blue" cpt_Status
              //                                    ,EFlp (EDcD rel_compStatusComputerStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compOwner;compOwner~ /\\\\ -compRequiresComm /\\\\ -(compStatus;\\\'Blue\\\'[Status];compStatus~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compOwner;compOwner~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compOwner`=ECps1.`compOwner`
                               ) AS isect0, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect1
                          WHERE isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.Computer AND isect0.`TgtComputer`=cp.`compRequiresComm`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compStatus;\\\'Blue\\\'[Status];compStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `Computer` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Blue\' AS `SrcStatus`, \'Blue\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Computer` AS ECps2
                                              WHERE ECps0.`compStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`compStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'Computer status \'Green\'' =>
        array ( 'name'          => 'Computer status \'Green\''
              , 'ruleAdl'       => 'I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compAllReqCommSatisfied |- compStatus;\'Green\'[Status];compStatus~'
              , 'origin'        => 'line 126:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compAllReqCommSatisfied |- compStatus;\'Green\'[Status];compStatus~)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compAllReqCommSatisfied) \\/ compStatus;\'Green\'[Status];compStatus~)
              // <=> { De Morgan }
              //     I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compAllReqCommSatisfied /\\ -(compStatus;\'Green\'[Status];compStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                  ,EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                  )
              //            ,EIsc (ECps (EDcD rel_compRouterComputerRouter
              //                        ,EFlp (EDcD rel_compRouterComputerRouter)
              //                        )
              //                  ,EIsc (EDcD rel_compRequiresCommComputerComputer
              //                        ,EIsc (EDcD rel_compAllReqCommSatisfiedComputerComputer
              //                              ,ECpl (ECps (EDcD rel_compStatusComputerStatus
              //                                          ,ECps (EMp1 "Green" cpt_Status
              //                                                ,EFlp (EDcD rel_compStatusComputerStatus)
              //                                                )
              //                                          ))
              //                              )
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compOwner;compOwner~ /\\\\ compRouter;compRouter~ /\\\\ compRequiresComm /\\\\ compAllReqCommSatisfied /\\\\ -(compStatus;\\\'Green\\\'[Status];compStatus~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compOwner;compOwner~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compOwner`=ECps1.`compOwner`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `compRouter` AS ECps0,
                                      `compRouter` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1, 
                               `Computer` AS isect2, 
                               `Computer` AS isect3, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect4
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND (isect0.`SrcComputer` = isect2.Computer AND isect0.`TgtComputer` = isect2.`compRequiresComm`) AND (isect0.`SrcComputer` = isect3.Computer AND isect0.`TgtComputer` = isect3.`compAllReqCommSatisfied`) AND isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compStatus;\\\'Green\\\'[Status];compStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `Computer` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Computer` AS ECps2
                                              WHERE ECps0.`compStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`compStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'Computer status \'Yellow\'' =>
        array ( 'name'          => 'Computer status \'Yellow\''
              , 'ruleAdl'       => 'I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ -compAllReqCommSatisfied /\\ -compNoReqCommSatisfied |- compStatus;\'Yellow\'[Status];compStatus~'
              , 'origin'        => 'line 132:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ -compAllReqCommSatisfied /\\ -compNoReqCommSatisfied |- compStatus;\'Yellow\'[Status];compStatus~)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ -compAllReqCommSatisfied /\\ -compNoReqCommSatisfied) \\/ compStatus;\'Yellow\'[Status];compStatus~)
              // <=> { De Morgan }
              //     I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ -compAllReqCommSatisfied /\\ -compNoReqCommSatisfied /\\ -(compStatus;\'Yellow\'[Status];compStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                  ,EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                  )
              //            ,EIsc (ECps (EDcD rel_compRouterComputerRouter
              //                        ,EFlp (EDcD rel_compRouterComputerRouter)
              //                        )
              //                  ,EIsc (EDcD rel_compRequiresCommComputerComputer
              //                        ,EIsc (ECpl (EDcD rel_compAllReqCommSatisfiedComputerComputer)
              //                              ,EIsc (ECpl (EDcD rel_compNoReqCommSatisfiedComputerComputer)
              //                                    ,ECpl (ECps (EDcD rel_compStatusComputerStatus
              //                                                ,ECps (EMp1 "Yellow" cpt_Status
              //                                                      ,EFlp (EDcD rel_compStatusComputerStatus)
              //                                                      )
              //                                                ))
              //                                    )
              //                              )
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compOwner;compOwner~ /\\\\ compRouter;compRouter~ /\\\\ compRequiresComm /\\\\ -compAllReqCommSatisfied /\\\\ -compNoReqCommSatisfied /\\\\ -(compStatus;\\\'Yellow\\\'[Status];compStatus~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compOwner;compOwner~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compOwner`=ECps1.`compOwner`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `compRouter` AS ECps0,
                                      `compRouter` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1, 
                               `Computer` AS isect2, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect3
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND (isect0.`SrcComputer` = isect2.Computer AND isect0.`TgtComputer` = isect2.`compRequiresComm`) AND isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.Computer AND isect0.`TgtComputer`=cp.`compAllReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.Computer AND isect0.`TgtComputer`=cp.`compNoReqCommSatisfied`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compStatus;\\\'Yellow\\\'[Status];compStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `Computer` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Computer` AS ECps2
                                              WHERE ECps0.`compStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`compStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'Computer status \'Red\'' =>
        array ( 'name'          => 'Computer status \'Red\''
              , 'ruleAdl'       => 'I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compNoReqCommSatisfied |- compStatus;\'Red\'[Status];compStatus~'
              , 'origin'        => 'line 138:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compNoReqCommSatisfied |- compStatus;\'Red\'[Status];compStatus~)
              // <=> { remove |- }
              //     -(-(I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compNoReqCommSatisfied) \\/ compStatus;\'Red\'[Status];compStatus~)
              // <=> { De Morgan }
              //     I[Computer] /\\ compOwner;compOwner~ /\\ compRouter;compRouter~ /\\ compRequiresComm /\\ compNoReqCommSatisfied /\\ -(compStatus;\'Red\'[Status];compStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Computer
              //      ,EIsc (ECps (EDcD rel_compOwnerComputerOrgUnit
              //                  ,EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                  )
              //            ,EIsc (ECps (EDcD rel_compRouterComputerRouter
              //                        ,EFlp (EDcD rel_compRouterComputerRouter)
              //                        )
              //                  ,EIsc (EDcD rel_compRequiresCommComputerComputer
              //                        ,EIsc (EDcD rel_compNoReqCommSatisfiedComputerComputer
              //                              ,ECpl (ECps (EDcD rel_compStatusComputerStatus
              //                                          ,ECps (EMp1 "Red" cpt_Status
              //                                                ,EFlp (EDcD rel_compStatusComputerStatus)
              //                                                )
              //                                          ))
              //                              )
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Computer] /\\\\ compOwner;compOwner~ /\\\\ compRouter;compRouter~ /\\\\ compRequiresComm /\\\\ compNoReqCommSatisfied /\\\\ -(compStatus;\\\'Red\\\'[Status];compStatus~) ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compOwner;compOwner~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compOwner`=ECps1.`compOwner`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRouter;compRouter~ */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                 FROM `compRouter` AS ECps0,
                                      `compRouter` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect1, 
                               `Computer` AS isect2, 
                               `Computer` AS isect3, 
                               ( /* Case EDcI Computer */
                                 SELECT `Computer` AS `Computer`
                                 FROM `Computer` ) AS isect4
                          WHERE (isect0.`SrcComputer` = isect1.`SrcComputer` AND isect0.`TgtComputer` = isect1.`TgtComputer`) AND (isect0.`SrcComputer` = isect2.Computer AND isect0.`TgtComputer` = isect2.`compRequiresComm`) AND (isect0.`SrcComputer` = isect3.Computer AND isect0.`TgtComputer` = isect3.`compNoReqCommSatisfied`) AND isect0.`SrcComputer` = isect0.`TgtComputer` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 compStatus;\\\'Red\\\'[Status];compStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps2.`Computer` AS `TgtComputer`
                                              FROM `Computer` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Computer` AS ECps2
                                              WHERE ECps0.`compStatus`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`compStatus`
                                            ) AS cp
                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'InsComputerStatus' =>
        array ( 'name'          => 'InsComputerStatus'
              , 'ruleAdl'       => 'compMnlStat \\/ (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat |- compStatus'
              , 'origin'        => 'line 145:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compMnlStat \\/ (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat |- compStatus)
              // <=> { remove |- }
              //     -(-(compMnlStat \\/ (I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat) \\/ compStatus)
              // <=> { De Morgan }
              //     -(-compMnlStat /\\ -((I[Computer] /\\ -(compMnlStat;compMnlStat~));compCmpStat)) /\\ -compStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_compMnlStatComputerStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_Computer
              //                                    ,ECpl (ECps (EDcD rel_compMnlStatComputerStatus
              //                                                ,EFlp (EDcD rel_compMnlStatComputerStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_compCmpStatComputerStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_compStatusComputerStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-compMnlStat /\\\\ -((I[Computer] /\\\\ -(compMnlStat;compMnlStat~));compCmpStat)) /\\\\ -compStatus ([Computer*Status]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-compMnlStat /\\\\ -((I[Computer] /\\\\ -(compMnlStat;compMnlStat~));compCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`Status` AS `TgtStatus`
                                 FROM `Computer` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -compMnlStat /\\\\ -((I[Computer] /\\\\ -(compMnlStat;compMnlStat~));compCmpStat) ([Computer*Status]) */
                                          SELECT DISTINCT isect0.`SrcComputer`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"compMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`Computer` AS `SrcComputer`, csnd.`Status` AS `TgtStatus`
                                                 FROM `Computer` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Computer` AS cp
                                                   WHERE cfst.`Computer`=cp.`Computer` AND csnd.`Status`=cp.`compMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[Computer] /\\\\ -(compMnlStat;compMnlStat~));compCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcComputer`, ECps1.`compCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Computer] /\\\\ -(compMnlStat;compMnlStat~) ([Computer*Computer]) */
                                                                     SELECT DISTINCT isect0.`Computer` AS `SrcComputer`, isect0.`Computer` AS `TgtComputer`
                                                                     FROM ( /* Case EDcI Computer */
                                                                            SELECT `Computer` AS `Computer`
                                                                            FROM `Computer` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            compMnlStat;compMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`Computer` AS `TgtComputer`
                                                                                         FROM `Computer` AS ECps0,
                                                                                              `Computer` AS ECps1
                                                                                         WHERE ECps0.`compMnlStat`=ECps1.`compMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Computer`=cp.`SrcComputer` AND isect0.`Computer`=cp.`TgtComputer`) AND isect0.`Computer` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `Computer` AS ECps1
                                                              WHERE ECps0.`TgtComputer`=ECps1.`Computer`
                                                            ) AS cp
                                                            WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Computer`=cp.`SrcComputer` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Computer` AS cp
                                            WHERE isect0.`SrcComputer`=cp.`Computer` AND isect0.`TgtStatus`=cp.`compStatus`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;compStatus;Computer;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Computer'
                            , 'expSQL' =>
                                '/* I[Computer] */
                                   SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                   FROM `Computer`
                                   WHERE `Computer` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'InsSvcComponentStatus' =>
        array ( 'name'          => 'InsSvcComponentStatus'
              , 'ruleAdl'       => 'scMnlStat \\/ (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat |- scStatus'
              , 'origin'        => 'line 159:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scMnlStat \\/ (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat |- scStatus)
              // <=> { remove |- }
              //     -(-(scMnlStat \\/ (I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat) \\/ scStatus)
              // <=> { De Morgan }
              //     -(-scMnlStat /\\ -((I[SvcComponent] /\\ -(scMnlStat;scMnlStat~));scCmpStat)) /\\ -scStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_scMnlStatSvcComponentStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_SvcComponent
              //                                    ,ECpl (ECps (EDcD rel_scMnlStatSvcComponentStatus
              //                                                ,EFlp (EDcD rel_scMnlStatSvcComponentStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_scCmpStatSvcComponentStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_scStatusSvcComponentStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-scMnlStat /\\\\ -((I[SvcComponent] /\\\\ -(scMnlStat;scMnlStat~));scCmpStat)) /\\\\ -scStatus ([SvcComponent*Status]) */
                          SELECT DISTINCT isect0.`SrcSvcComponent` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-scMnlStat /\\\\ -((I[SvcComponent] /\\\\ -(scMnlStat;scMnlStat~));scCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Status` AS `TgtStatus`
                                 FROM `SvcComponent` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -scMnlStat /\\\\ -((I[SvcComponent] /\\\\ -(scMnlStat;scMnlStat~));scCmpStat) ([SvcComponent*Status]) */
                                          SELECT DISTINCT isect0.`SrcSvcComponent`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"scMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`SvcComponent` AS `SrcSvcComponent`, csnd.`Status` AS `TgtStatus`
                                                 FROM `SvcComponent` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `SvcComponent` AS cp
                                                   WHERE cfst.`SvcComponent`=cp.`SvcComponent` AND csnd.`Status`=cp.`scMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[SvcComponent] /\\\\ -(scMnlStat;scMnlStat~));scCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcSvcComponent`, ECps1.`scCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[SvcComponent] /\\\\ -(scMnlStat;scMnlStat~) ([SvcComponent*SvcComponent]) */
                                                                     SELECT DISTINCT isect0.`SvcComponent` AS `SrcSvcComponent`, isect0.`SvcComponent` AS `TgtSvcComponent`
                                                                     FROM ( /* Case EDcI SvcComponent */
                                                                            SELECT `SvcComponent` AS `SvcComponent`
                                                                            FROM `SvcComponent` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            scMnlStat;scMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`SvcComponent` AS `SrcSvcComponent`, ECps1.`SvcComponent` AS `TgtSvcComponent`
                                                                                         FROM `SvcComponent` AS ECps0,
                                                                                              `SvcComponent` AS ECps1
                                                                                         WHERE ECps0.`scMnlStat`=ECps1.`scMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`SvcComponent`=cp.`SrcSvcComponent` AND isect0.`SvcComponent`=cp.`TgtSvcComponent`) AND isect0.`SvcComponent` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `SvcComponent` AS ECps1
                                                              WHERE ECps0.`TgtSvcComponent`=ECps1.`SvcComponent`
                                                            ) AS cp
                                                            WHERE isect0.`SrcSvcComponent`=cp.`SrcSvcComponent` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`SvcComponent`=cp.`SrcSvcComponent` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `SvcComponent` AS cp
                                            WHERE isect0.`SrcSvcComponent`=cp.`SvcComponent` AND isect0.`TgtStatus`=cp.`scStatus`) AND isect0.`SrcSvcComponent` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                   SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultSvcComponentStatus' =>
        array ( 'name'          => 'defaultSvcComponentStatus'
              , 'ruleAdl'       => 'I[SvcComponent] |- scStatus;scStatus~'
              , 'origin'        => 'line 162:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'SvcComponent'
              , 'tgtConcept'    => 'SvcComponent'
              // Normalization steps:
              //     -(I[SvcComponent] |- scStatus;scStatus~)
              // <=> { remove |- }
              //     -(-I[SvcComponent] \\/ scStatus;scStatus~)
              // <=> { De Morgan }
              //     I[SvcComponent] /\\ -(scStatus;scStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_SvcComponent
              //      ,ECpl (ECps (EDcD rel_scStatusSvcComponentStatus
              //                  ,EFlp (EDcD rel_scStatusSvcComponentStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[SvcComponent] /\\\\ -(scStatus;scStatus~) ([SvcComponent*SvcComponent]) */
                          SELECT DISTINCT isect0.`SvcComponent` AS `src`, isect0.`SvcComponent` AS `tgt`
                          FROM ( /* Case EDcI SvcComponent */
                                 SELECT `SvcComponent` AS `SvcComponent`
                                 FROM `SvcComponent` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 scStatus;scStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`SvcComponent` AS `SrcSvcComponent`, ECps1.`SvcComponent` AS `TgtSvcComponent`
                                              FROM `SvcComponent` AS ECps0,
                                                   `SvcComponent` AS ECps1
                                              WHERE ECps0.`scStatus`=ECps1.`scStatus`
                                            ) AS cp
                                            WHERE isect0.`SvcComponent`=cp.`SrcSvcComponent` AND isect0.`SvcComponent`=cp.`TgtSvcComponent`) AND isect0.`SvcComponent` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;scStatus;SvcComponent;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'SvcComponent'
                            , 'expSQL' =>
                                '/* I[SvcComponent] */
                                   SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                   FROM `SvcComponent`
                                   WHERE `SvcComponent` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'ITService status \'Grey\'' =>
        array ( 'name'          => 'ITService status \'Grey\''
              , 'ruleAdl'       => 'I[ITService] /\\ -(itsvcSupports;itsvcSupports~) |- itsvcCmpStat;\'Grey\'[Status];itsvcCmpStat~'
              , 'origin'        => 'line 178:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(I[ITService] /\\ -(itsvcSupports;itsvcSupports~) |- itsvcCmpStat;\'Grey\'[Status];itsvcCmpStat~)
              // <=> { remove |- }
              //     -(-(I[ITService] /\\ -(itsvcSupports;itsvcSupports~)) \\/ itsvcCmpStat;\'Grey\'[Status];itsvcCmpStat~)
              // <=> { De Morgan }
              //     I[ITService] /\\ -(itsvcSupports;itsvcSupports~) /\\ -(itsvcCmpStat;\'Grey\'[Status];itsvcCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_ITService
              //      ,EIsc (ECpl (ECps (EDcD rel_itsvcSupportsITServiceService
              //                        ,EFlp (EDcD rel_itsvcSupportsITServiceService)
              //                        ))
              //            ,ECpl (ECps (EDcD rel_itsvcCmpStatITServiceStatus
              //                        ,ECps (EMp1 "Grey" cpt_Status
              //                              ,EFlp (EDcD rel_itsvcCmpStatITServiceStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[ITService] /\\\\ -(itsvcSupports;itsvcSupports~) /\\\\ -(itsvcCmpStat;\\\'Grey\\\'[Status];itsvcCmpStat~) ([ITService*ITService]) */
                          SELECT DISTINCT isect0.`ITService` AS `src`, isect0.`ITService` AS `tgt`
                          FROM ( /* Case EDcI ITService */
                                 SELECT `ITService` AS `ITService`
                                 FROM `ITService` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcSupports;itsvcSupports~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                              FROM `itsvcSupports` AS ECps0,
                                                   `itsvcSupports` AS ECps1
                                              WHERE ECps0.`Service`=ECps1.`Service`
                                            ) AS cp
                                            WHERE isect0.`ITService`=cp.`SrcITService` AND isect0.`ITService`=cp.`TgtITService`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcCmpStat;\\\'Grey\\\'[Status];itsvcCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps2.`ITService` AS `TgtITService`
                                              FROM `ITService` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Grey\' AS `SrcStatus`, \'Grey\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `ITService` AS ECps2
                                              WHERE ECps0.`itsvcCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`itsvcCmpStat`
                                            ) AS cp
                                            WHERE isect0.`ITService`=cp.`SrcITService` AND isect0.`ITService`=cp.`TgtITService`) AND isect0.`ITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcCmpStat;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Grey')
                    )
              )
    , 'ITService status \'Blue\'' =>
        array ( 'name'          => 'ITService status \'Blue\''
              , 'ruleAdl'       => 'I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ -(actUsesITSvc~;actUsesITSvc) |- itsvcCmpStat;\'Blue\'[Status];itsvcCmpStat~'
              , 'origin'        => 'line 183:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ -(actUsesITSvc~;actUsesITSvc) |- itsvcCmpStat;\'Blue\'[Status];itsvcCmpStat~)
              // <=> { remove |- }
              //     -(-(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ -(actUsesITSvc~;actUsesITSvc)) \\/ itsvcCmpStat;\'Blue\'[Status];itsvcCmpStat~)
              // <=> { De Morgan }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ -(actUsesITSvc~;actUsesITSvc) /\\ -(itsvcCmpStat;\'Blue\'[Status];itsvcCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_ITService
              //      ,EIsc (ECps (EDcD rel_itsvcSupportsITServiceService
              //                  ,EFlp (EDcD rel_itsvcSupportsITServiceService)
              //                  )
              //            ,EIsc (ECpl (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                              ,EDcD rel_actUsesITSvcActivityITService
              //                              ))
              //                  ,ECpl (ECps (EDcD rel_itsvcCmpStatITServiceStatus
              //                              ,ECps (EMp1 "Blue" cpt_Status
              //                                    ,EFlp (EDcD rel_itsvcCmpStatITServiceStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[ITService] /\\\\ itsvcSupports;itsvcSupports~ /\\\\ -(actUsesITSvc~;actUsesITSvc) /\\\\ -(itsvcCmpStat;\\\'Blue\\\'[Status];itsvcCmpStat~) ([ITService*ITService]) */
                          SELECT DISTINCT isect0.`SrcITService` AS `src`, isect0.`TgtITService` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcSupports;itsvcSupports~ */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `itsvcSupports` AS ECps0,
                                      `itsvcSupports` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0, 
                               ( /* Case EDcI ITService */
                                 SELECT `ITService` AS `ITService`
                                 FROM `ITService` ) AS isect1
                          WHERE isect0.`SrcITService` = isect0.`TgtITService` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actUsesITSvc~;actUsesITSvc */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                              FROM `actUsesITSvc` AS ECps0,
                                                   `actUsesITSvc` AS ECps1
                                              WHERE ECps0.`Activity`=ECps1.`Activity`
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcCmpStat;\\\'Blue\\\'[Status];itsvcCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps2.`ITService` AS `TgtITService`
                                              FROM `ITService` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Blue\' AS `SrcStatus`, \'Blue\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `ITService` AS ECps2
                                              WHERE ECps0.`itsvcCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`itsvcCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcCmpStat;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'ITService status \'Red\'' =>
        array ( 'name'          => 'ITService status \'Red\''
              , 'ruleAdl'       => 'I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ (I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) |- itsvcCmpStat;\'Red\'[Status];itsvcCmpStat~'
              , 'origin'        => 'line 188:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService) |- itsvcCmpStat;\'Red\'[Status];itsvcCmpStat~)
              // <=> { remove |- }
              //     -(-(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) \\/ itsvcCmpStat;\'Red\'[Status];itsvcCmpStat~)
              // <=> { De Morgan }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService) /\\ -(itsvcCmpStat;\'Red\'[Status];itsvcCmpStat~)
              // <=> { I[ITService] /\\ I[ITService] = I[ITService] }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService) /\\ -(itsvcCmpStat;\'Red\'[Status];itsvcCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_ITService
              //      ,EIsc (ECps (EDcD rel_itsvcSupportsITServiceService
              //                  ,EFlp (EDcD rel_itsvcSupportsITServiceService)
              //                  )
              //            ,EIsc (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                        ,EDcD rel_actUsesITSvcActivityITService
              //                        )
              //                  ,EIsc (ECpl (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                                    ,ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                                          ,ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                ,EDcD rel_compITServiceComputerITService
              //                                                )
              //                                          )
              //                                    ))
              //                        ,ECpl (ECps (EDcD rel_itsvcCmpStatITServiceStatus
              //                                    ,ECps (EMp1 "Red" cpt_Status
              //                                          ,EFlp (EDcD rel_itsvcCmpStatITServiceStatus)
              //                                          )
              //                                    ))
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[ITService] /\\\\ itsvcSupports;itsvcSupports~ /\\\\ actUsesITSvc~;actUsesITSvc /\\\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService) /\\\\ -(itsvcCmpStat;\\\'Red\\\'[Status];itsvcCmpStat~) ([ITService*ITService]) */
                          SELECT DISTINCT isect0.`SrcITService` AS `src`, isect0.`TgtITService` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcSupports;itsvcSupports~ */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `itsvcSupports` AS ECps0,
                                      `itsvcSupports` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc~;actUsesITSvc */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `actUsesITSvc` AS ECps0,
                                      `actUsesITSvc` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect1, 
                               ( /* Case EDcI ITService */
                                 SELECT `ITService` AS `ITService`
                                 FROM `ITService` ) AS isect2
                          WHERE (isect0.`SrcITService` = isect1.`SrcITService` AND isect0.`TgtITService` = isect1.`TgtITService`) AND isect0.`SrcITService` = isect0.`TgtITService` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actUsesITSvc~;actExecutingOU;compOwner~;compITService */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps3.`ITService` AS `TgtITService`
                                              FROM `actUsesITSvc` AS ECps0,
                                                   `Activity` AS ECps1,
                                                   `Computer` AS ECps2,
                                                   `compITService` AS ECps3
                                              WHERE ECps0.`Activity`=ECps1.`Activity`
                                                AND ECps1.`actExecutingOU`=ECps2.`compOwner`
                                                AND ECps2.`Computer`=ECps3.`Computer`
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcCmpStat;\\\'Red\\\'[Status];itsvcCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps2.`ITService` AS `TgtITService`
                                              FROM `ITService` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `ITService` AS ECps2
                                              WHERE ECps0.`itsvcCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`itsvcCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcCmpStat;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'ITService status \'Green\'' =>
        array ( 'name'          => 'ITService status \'Green\''
              , 'ruleAdl'       => 'I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ (I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService)) |- itsvcCmpStat;\'Green\'[Status];itsvcCmpStat~'
              , 'origin'        => 'line 194:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService) |- itsvcCmpStat;\'Green\'[Status];itsvcCmpStat~)
              // <=> { remove |- }
              //     -(-(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService)) \\/ itsvcCmpStat;\'Green\'[Status];itsvcCmpStat~)
              // <=> { De Morgan }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService) /\\ -(itsvcCmpStat;\'Green\'[Status];itsvcCmpStat~)
              // <=> { I[ITService] /\\ I[ITService] = I[ITService] }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService) /\\ -(itsvcCmpStat;\'Green\'[Status];itsvcCmpStat~)
              // <=> { -l!r = l~//rj }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ actExecutingOU~;actUsesITSvc \\ compOwner~;compITService /\\ -(itsvcCmpStat;\'Green\'[Status];itsvcCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_ITService
              //      ,EIsc (ECps (EDcD rel_itsvcSupportsITServiceService
              //                  ,EFlp (EDcD rel_itsvcSupportsITServiceService)
              //                  )
              //            ,EIsc (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                        ,EDcD rel_actUsesITSvcActivityITService
              //                        )
              //                  ,EIsc (ERrs (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                    ,EDcD rel_actUsesITSvcActivityITService
              //                                    )
              //                              ,ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                    ,EDcD rel_compITServiceComputerITService
              //                                    )
              //                              )
              //                        ,ECpl (ECps (EDcD rel_itsvcCmpStatITServiceStatus
              //                                    ,ECps (EMp1 "Green" cpt_Status
              //                                          ,EFlp (EDcD rel_itsvcCmpStatITServiceStatus)
              //                                          )
              //                                    ))
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[ITService] /\\\\ itsvcSupports;itsvcSupports~ /\\\\ actUsesITSvc~;actUsesITSvc /\\\\ actExecutingOU~;actUsesITSvc \\\\ compOwner~;compITService /\\\\ -(itsvcCmpStat;\\\'Green\\\'[Status];itsvcCmpStat~) ([ITService*ITService]) */
                          SELECT DISTINCT isect0.`SrcITService` AS `src`, isect0.`TgtITService` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcSupports;itsvcSupports~ */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `itsvcSupports` AS ECps0,
                                      `itsvcSupports` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc~;actUsesITSvc */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `actUsesITSvc` AS ECps0,
                                      `actUsesITSvc` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect1, 
                               
                               ( /* case: ERrs (l,r)
                                    actExecutingOU~;actUsesITSvc \\\\ compOwner~;compITService ([ITService*ITService]) */
                                 SELECT `RResLeft`.`ITService` AS `SrcITService`, `RResRight`.`ITService` AS `TgtITService`
                                 FROM `ITService` AS `RResLeft`, `ITService` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        actExecutingOU~;actUsesITSvc */
                                                     
                                                     SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                     FROM `Activity` AS ECps0,
                                                          `actUsesITSvc` AS ECps1
                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                   ) AS lhs
                                         WHERE `RResLeft`.`ITService`=lhs.`TgtITService` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                compOwner~;compITService */
                                                             
                                                             SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                             FROM `Computer` AS ECps0,
                                                                  `compITService` AS ECps1
                                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                                           ) AS rhs
                                                 WHERE rhs.`SrcOrgUnit`=lhs.`SrcOrgUnit` AND rhs.`TgtITService`=`RResRight`.`ITService`
                                               )
                                       )
                               ) AS isect2, 
                               ( /* Case EDcI ITService */
                                 SELECT `ITService` AS `ITService`
                                 FROM `ITService` ) AS isect3
                          WHERE (isect0.`SrcITService` = isect1.`SrcITService` AND isect0.`TgtITService` = isect1.`TgtITService`) AND (isect0.`SrcITService` = isect2.`SrcITService` AND isect0.`TgtITService` = isect2.`TgtITService`) AND isect0.`SrcITService` = isect0.`TgtITService` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcCmpStat;\\\'Green\\\'[Status];itsvcCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps2.`ITService` AS `TgtITService`
                                              FROM `ITService` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `ITService` AS ECps2
                                              WHERE ECps0.`itsvcCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`itsvcCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcCmpStat;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'ITService status \'Yellow\'' =>
        array ( 'name'          => 'ITService status \'Yellow\''
              , 'ruleAdl'       => 'I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService)) /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) |- itsvcCmpStat;\'Yellow\'[Status];itsvcCmpStat~'
              , 'origin'        => 'line 200:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService)) /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) |- itsvcCmpStat;\'Yellow\'[Status];itsvcCmpStat~)
              // <=> { remove |- }
              //     -(-(I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService)) /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService))) \\/ itsvcCmpStat;\'Yellow\'[Status];itsvcCmpStat~)
              // <=> { De Morgan }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU)!(compOwner~;compITService)) /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) /\\ -(itsvcCmpStat;\'Yellow\'[Status];itsvcCmpStat~)
              // <=> { -l!r = l~//rj }
              //     I[ITService] /\\ itsvcSupports;itsvcSupports~ /\\ actUsesITSvc~;actUsesITSvc /\\ -(I[ITService] /\\ actExecutingOU~;actUsesITSvc \\ compOwner~;compITService) /\\ -(I[ITService] /\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) /\\ -(itsvcCmpStat;\'Yellow\'[Status];itsvcCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_ITService
              //      ,EIsc (ECps (EDcD rel_itsvcSupportsITServiceService
              //                  ,EFlp (EDcD rel_itsvcSupportsITServiceService)
              //                  )
              //            ,EIsc (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                        ,EDcD rel_actUsesITSvcActivityITService
              //                        )
              //                  ,EIsc (ECpl (EIsc (EDcI cpt_ITService
              //                                    ,ERrs (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                                ,EDcD rel_actUsesITSvcActivityITService
              //                                                )
              //                                          ,ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                ,EDcD rel_compITServiceComputerITService
              //                                                )
              //                                          )
              //                                    ))
              //                        ,EIsc (ECpl (EIsc (EDcI cpt_ITService
              //                                          ,ECpl (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                                                      ,ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                                                            ,ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                                  ,EDcD rel_compITServiceComputerITService
              //                                                                  )
              //                                                            )
              //                                                      ))
              //                                          ))
              //                              ,ECpl (ECps (EDcD rel_itsvcCmpStatITServiceStatus
              //                                          ,ECps (EMp1 "Yellow" cpt_Status
              //                                                ,EFlp (EDcD rel_itsvcCmpStatITServiceStatus)
              //                                                )
              //                                          ))
              //                              )
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[ITService] /\\\\ itsvcSupports;itsvcSupports~ /\\\\ actUsesITSvc~;actUsesITSvc /\\\\ -(I[ITService] /\\\\ actExecutingOU~;actUsesITSvc \\\\ compOwner~;compITService) /\\\\ -(I[ITService] /\\\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService)) /\\\\ -(itsvcCmpStat;\\\'Yellow\\\'[Status];itsvcCmpStat~) ([ITService*ITService]) */
                          SELECT DISTINCT isect0.`SrcITService` AS `src`, isect0.`TgtITService` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcSupports;itsvcSupports~ */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `itsvcSupports` AS ECps0,
                                      `itsvcSupports` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc~;actUsesITSvc */
                                 
                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                 FROM `actUsesITSvc` AS ECps0,
                                      `actUsesITSvc` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect1, 
                               ( /* Case EDcI ITService */
                                 SELECT `ITService` AS `ITService`
                                 FROM `ITService` ) AS isect2
                          WHERE (isect0.`SrcITService` = isect1.`SrcITService` AND isect0.`TgtITService` = isect1.`TgtITService`) AND isect0.`SrcITService` = isect0.`TgtITService` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[ITService] /\\\\ actExecutingOU~;actUsesITSvc \\\\ compOwner~;compITService ([ITService*ITService]) */
                                              SELECT DISTINCT isect0.`SrcITService`, isect0.`TgtITService`
                                              FROM 
                                                   ( /* case: ERrs (l,r)
                                                        actExecutingOU~;actUsesITSvc \\\\ compOwner~;compITService ([ITService*ITService]) */
                                                     SELECT `RResLeft`.`ITService` AS `SrcITService`, `RResRight`.`ITService` AS `TgtITService`
                                                     FROM `ITService` AS `RResLeft`, `ITService` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM 
                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                            actExecutingOU~;actUsesITSvc */
                                                                         
                                                                         SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                         FROM `Activity` AS ECps0,
                                                                              `actUsesITSvc` AS ECps1
                                                                         WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                       ) AS lhs
                                                             WHERE `RResLeft`.`ITService`=lhs.`TgtITService` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    compOwner~;compITService */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                                 FROM `Computer` AS ECps0,
                                                                                      `compITService` AS ECps1
                                                                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcOrgUnit`=lhs.`SrcOrgUnit` AND rhs.`TgtITService`=`RResRight`.`ITService`
                                                                   )
                                                           )
                                                   ) AS isect0, 
                                                   ( /* Case EDcI ITService */
                                                     SELECT `ITService` AS `ITService`
                                                     FROM `ITService` ) AS isect1
                                              WHERE isect0.`SrcITService` = isect0.`TgtITService` AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[ITService] /\\\\ -(actUsesITSvc~;actExecutingOU;compOwner~;compITService) ([ITService*ITService]) */
                                              SELECT DISTINCT isect0.`ITService` AS `SrcITService`, isect0.`ITService` AS `TgtITService`
                                              FROM ( /* Case EDcI ITService */
                                                     SELECT `ITService` AS `ITService`
                                                     FROM `ITService` ) AS isect0
                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     actUsesITSvc~;actExecutingOU;compOwner~;compITService */
                                                                  
                                                                  SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps3.`ITService` AS `TgtITService`
                                                                  FROM `actUsesITSvc` AS ECps0,
                                                                       `Activity` AS ECps1,
                                                                       `Computer` AS ECps2,
                                                                       `compITService` AS ECps3
                                                                  WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                    AND ECps1.`actExecutingOU`=ECps2.`compOwner`
                                                                    AND ECps2.`Computer`=ECps3.`Computer`
                                                                ) AS cp
                                                                WHERE isect0.`ITService`=cp.`SrcITService` AND isect0.`ITService`=cp.`TgtITService`) AND isect0.`ITService` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcCmpStat;\\\'Yellow\\\'[Status];itsvcCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps2.`ITService` AS `TgtITService`
                                              FROM `ITService` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `ITService` AS ECps2
                                              WHERE ECps0.`itsvcCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`itsvcCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcCmpStat;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'InsITServiceStatus' =>
        array ( 'name'          => 'InsITServiceStatus'
              , 'ruleAdl'       => 'itsvcMnlStat \\/ (I[ITService] /\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat |- itsvcStatus'
              , 'origin'        => 'line 208:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(itsvcMnlStat \\/ (I[ITService] /\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat |- itsvcStatus)
              // <=> { remove |- }
              //     -(-(itsvcMnlStat \\/ (I[ITService] /\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat) \\/ itsvcStatus)
              // <=> { De Morgan }
              //     -(-itsvcMnlStat /\\ -((I[ITService] /\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat)) /\\ -itsvcStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_itsvcMnlStatITServiceStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_ITService
              //                                    ,ECpl (ECps (EDcD rel_itsvcMnlStatITServiceStatus
              //                                                ,EFlp (EDcD rel_itsvcMnlStatITServiceStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_itsvcCmpStatITServiceStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_itsvcStatusITServiceStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-itsvcMnlStat /\\\\ -((I[ITService] /\\\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat)) /\\\\ -itsvcStatus ([ITService*Status]) */
                          SELECT DISTINCT isect0.`SrcITService` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-itsvcMnlStat /\\\\ -((I[ITService] /\\\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`ITService` AS `SrcITService`, csnd.`Status` AS `TgtStatus`
                                 FROM `ITService` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -itsvcMnlStat /\\\\ -((I[ITService] /\\\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat) ([ITService*Status]) */
                                          SELECT DISTINCT isect0.`SrcITService`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"itsvcMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`ITService` AS `SrcITService`, csnd.`Status` AS `TgtStatus`
                                                 FROM `ITService` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `ITService` AS cp
                                                   WHERE cfst.`ITService`=cp.`ITService` AND csnd.`Status`=cp.`itsvcMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[ITService] /\\\\ -(itsvcMnlStat;itsvcMnlStat~));itsvcCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcITService`, ECps1.`itsvcCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[ITService] /\\\\ -(itsvcMnlStat;itsvcMnlStat~) ([ITService*ITService]) */
                                                                     SELECT DISTINCT isect0.`ITService` AS `SrcITService`, isect0.`ITService` AS `TgtITService`
                                                                     FROM ( /* Case EDcI ITService */
                                                                            SELECT `ITService` AS `ITService`
                                                                            FROM `ITService` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            itsvcMnlStat;itsvcMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                                                                         FROM `ITService` AS ECps0,
                                                                                              `ITService` AS ECps1
                                                                                         WHERE ECps0.`itsvcMnlStat`=ECps1.`itsvcMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`ITService`=cp.`SrcITService` AND isect0.`ITService`=cp.`TgtITService`) AND isect0.`ITService` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `ITService` AS ECps1
                                                              WHERE ECps0.`TgtITService`=ECps1.`ITService`
                                                            ) AS cp
                                                            WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`ITService`=cp.`SrcITService` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `ITService` AS cp
                                            WHERE isect0.`SrcITService`=cp.`ITService` AND isect0.`TgtStatus`=cp.`itsvcStatus`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcStatus;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultITServiceStatus' =>
        array ( 'name'          => 'defaultITServiceStatus'
              , 'ruleAdl'       => 'I[ITService] |- itsvcStatus;itsvcStatus~'
              , 'origin'        => 'line 211:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'ITService'
              , 'tgtConcept'    => 'ITService'
              // Normalization steps:
              //     -(I[ITService] |- itsvcStatus;itsvcStatus~)
              // <=> { remove |- }
              //     -(-I[ITService] \\/ itsvcStatus;itsvcStatus~)
              // <=> { De Morgan }
              //     I[ITService] /\\ -(itsvcStatus;itsvcStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_ITService
              //      ,ECpl (ECps (EDcD rel_itsvcStatusITServiceStatus
              //                  ,EFlp (EDcD rel_itsvcStatusITServiceStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[ITService] /\\\\ -(itsvcStatus;itsvcStatus~) ([ITService*ITService]) */
                          SELECT DISTINCT isect0.`ITService` AS `src`, isect0.`ITService` AS `tgt`
                          FROM ( /* Case EDcI ITService */
                                 SELECT `ITService` AS `ITService`
                                 FROM `ITService` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 itsvcStatus;itsvcStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`ITService` AS `TgtITService`
                                              FROM `ITService` AS ECps0,
                                                   `ITService` AS ECps1
                                              WHERE ECps0.`itsvcStatus`=ECps1.`itsvcStatus`
                                            ) AS cp
                                            WHERE isect0.`ITService`=cp.`SrcITService` AND isect0.`ITService`=cp.`TgtITService`) AND isect0.`ITService` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;itsvcStatus;ITService;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'ITService'
                            , 'expSQL' =>
                                '/* I[ITService] */
                                   SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                   FROM `ITService`
                                   WHERE `ITService` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'InsServiceStatus' =>
        array ( 'name'          => 'InsServiceStatus'
              , 'ruleAdl'       => 'svcMnlStat \\/ (I[Service] /\\ -(svcMnlStat;svcMnlStat~));svcCmpStat |- svcStatus'
              , 'origin'        => 'line 225:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(svcMnlStat \\/ (I[Service] /\\ -(svcMnlStat;svcMnlStat~));svcCmpStat |- svcStatus)
              // <=> { remove |- }
              //     -(-(svcMnlStat \\/ (I[Service] /\\ -(svcMnlStat;svcMnlStat~));svcCmpStat) \\/ svcStatus)
              // <=> { De Morgan }
              //     -(-svcMnlStat /\\ -((I[Service] /\\ -(svcMnlStat;svcMnlStat~));svcCmpStat)) /\\ -svcStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_svcMnlStatServiceStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_Service
              //                                    ,ECpl (ECps (EDcD rel_svcMnlStatServiceStatus
              //                                                ,EFlp (EDcD rel_svcMnlStatServiceStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_svcCmpStatServiceStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_svcStatusServiceStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-svcMnlStat /\\\\ -((I[Service] /\\\\ -(svcMnlStat;svcMnlStat~));svcCmpStat)) /\\\\ -svcStatus ([Service*Status]) */
                          SELECT DISTINCT isect0.`SrcService` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-svcMnlStat /\\\\ -((I[Service] /\\\\ -(svcMnlStat;svcMnlStat~));svcCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`Service` AS `SrcService`, csnd.`Status` AS `TgtStatus`
                                 FROM `Service` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -svcMnlStat /\\\\ -((I[Service] /\\\\ -(svcMnlStat;svcMnlStat~));svcCmpStat) ([Service*Status]) */
                                          SELECT DISTINCT isect0.`SrcService`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"svcMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`Service` AS `SrcService`, csnd.`Status` AS `TgtStatus`
                                                 FROM `Service` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Service` AS cp
                                                   WHERE cfst.`Service`=cp.`Service` AND csnd.`Status`=cp.`svcMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[Service] /\\\\ -(svcMnlStat;svcMnlStat~));svcCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcService`, ECps1.`svcCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Service] /\\\\ -(svcMnlStat;svcMnlStat~) ([Service*Service]) */
                                                                     SELECT DISTINCT isect0.`Service` AS `SrcService`, isect0.`Service` AS `TgtService`
                                                                     FROM ( /* Case EDcI Service */
                                                                            SELECT `Service` AS `Service`
                                                                            FROM `Service` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            svcMnlStat;svcMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Service` AS `SrcService`, ECps1.`Service` AS `TgtService`
                                                                                         FROM `Service` AS ECps0,
                                                                                              `Service` AS ECps1
                                                                                         WHERE ECps0.`svcMnlStat`=ECps1.`svcMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Service`=cp.`SrcService` AND isect0.`Service`=cp.`TgtService`) AND isect0.`Service` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `Service` AS ECps1
                                                              WHERE ECps0.`TgtService`=ECps1.`Service`
                                                            ) AS cp
                                                            WHERE isect0.`SrcService`=cp.`SrcService` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Service`=cp.`SrcService` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Service` AS cp
                                            WHERE isect0.`SrcService`=cp.`Service` AND isect0.`TgtStatus`=cp.`svcStatus`) AND isect0.`SrcService` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                   SELECT `Service` AS `src`, `Service` AS `tgt`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultServiceStatus' =>
        array ( 'name'          => 'defaultServiceStatus'
              , 'ruleAdl'       => 'I[Service] |- svcStatus;svcStatus~'
              , 'origin'        => 'line 228:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Service'
              , 'tgtConcept'    => 'Service'
              // Normalization steps:
              //     -(I[Service] |- svcStatus;svcStatus~)
              // <=> { remove |- }
              //     -(-I[Service] \\/ svcStatus;svcStatus~)
              // <=> { De Morgan }
              //     I[Service] /\\ -(svcStatus;svcStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Service
              //      ,ECpl (ECps (EDcD rel_svcStatusServiceStatus
              //                  ,EFlp (EDcD rel_svcStatusServiceStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Service] /\\\\ -(svcStatus;svcStatus~) ([Service*Service]) */
                          SELECT DISTINCT isect0.`Service` AS `src`, isect0.`Service` AS `tgt`
                          FROM ( /* Case EDcI Service */
                                 SELECT `Service` AS `Service`
                                 FROM `Service` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 svcStatus;svcStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Service` AS `SrcService`, ECps1.`Service` AS `TgtService`
                                              FROM `Service` AS ECps0,
                                                   `Service` AS ECps1
                                              WHERE ECps0.`svcStatus`=ECps1.`svcStatus`
                                            ) AS cp
                                            WHERE isect0.`Service`=cp.`SrcService` AND isect0.`Service`=cp.`TgtService`) AND isect0.`Service` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;svcStatus;Service;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Service'
                            , 'expSQL' =>
                                '/* I[Service] */
                                   SELECT `Service` AS `src`, `Service` AS `tgt`
                                   FROM `Service`
                                   WHERE `Service` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'insallRequiredITAvailbleToOrgUnit' =>
        array ( 'name'          => 'insallRequiredITAvailbleToOrgUnit'
              , 'ruleAdl'       => 'I[OrgUnit] /\\ (actExecutingOU~;actUsesITSvc);(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner) |- allRequiredITAvailbleToOrgUnit'
              , 'origin'        => 'line 243:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner) |- allRequiredITAvailbleToOrgUnit)
              // <=> { remove |- }
              //     -(-(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner)) \\/ allRequiredITAvailbleToOrgUnit)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner) /\\ -allRequiredITAvailbleToOrgUnit
              // <=> { -l!r = l~//rj }
              //     I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ actUsesITSvc~;actExecutingOU \\ compITService~;compOwner /\\ -allRequiredITAvailbleToOrgUnit
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_OrgUnit
              //      ,EIsc (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  ,ECps (EDcD rel_actUsesITSvcActivityITService
              //                        ,EFlp (EBrk (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                          ,EDcD rel_actUsesITSvcActivityITService
              //                                          )))
              //                        )
              //                  )
              //            ,EIsc (ERrs (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                              ,EDcD rel_actExecutingOUActivityOrgUnit
              //                              )
              //                        ,ECps (EFlp (EDcD rel_compITServiceComputerITService)
              //                              ,EDcD rel_compOwnerComputerOrgUnit
              //                              )
              //                        )
              //                  ,ECpl (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit)
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[OrgUnit] /\\\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\\\ actUsesITSvc~;actExecutingOU \\\\ compITService~;compOwner /\\\\ -allRequiredITAvailbleToOrgUnit ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps2.`SrcOrgUnit` AS `TgtOrgUnit`
                                 FROM `Activity` AS ECps0,
                                      `actUsesITSvc` AS ECps1,
                                      
                                      ( /* case: (ECps es), with two or more elements in es.
                                           actExecutingOU~;actUsesITSvc */
                                        
                                        SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                        FROM `Activity` AS ECps0,
                                             `actUsesITSvc` AS ECps1
                                        WHERE ECps0.`Activity`=ECps1.`Activity`
                                      ) AS ECps2
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                                   AND ECps1.`ITService`=ECps2.`TgtITService`
                               ) AS isect0, 
                               
                               ( /* case: ERrs (l,r)
                                    actUsesITSvc~;actExecutingOU \\\\ compITService~;compOwner ([OrgUnit*OrgUnit]) */
                                 SELECT `RResLeft`.`OrgUnit` AS `SrcOrgUnit`, `RResRight`.`OrgUnit` AS `TgtOrgUnit`
                                 FROM `OrgUnit` AS `RResLeft`, `OrgUnit` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        actUsesITSvc~;actExecutingOU */
                                                     
                                                     SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`actExecutingOU` AS `TgtOrgUnit`
                                                     FROM `actUsesITSvc` AS ECps0,
                                                          `Activity` AS ECps1
                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                   ) AS lhs
                                         WHERE `RResLeft`.`OrgUnit`=lhs.`TgtOrgUnit` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                compITService~;compOwner */
                                                             
                                                             SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`compOwner` AS `TgtOrgUnit`
                                                             FROM `compITService` AS ECps0,
                                                                  `Computer` AS ECps1
                                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                                           ) AS rhs
                                                 WHERE rhs.`SrcITService`=lhs.`SrcITService` AND rhs.`TgtOrgUnit`=`RResRight`.`OrgUnit`
                                               )
                                       )
                               ) AS isect1, 
                               ( /* Case EDcI OrgUnit */
                                 SELECT `OrgUnit` AS `OrgUnit`
                                 FROM `OrgUnit` ) AS isect2
                          WHERE (isect0.`SrcOrgUnit` = isect1.`SrcOrgUnit` AND isect0.`TgtOrgUnit` = isect1.`TgtOrgUnit`) AND isect0.`SrcOrgUnit` = isect0.`TgtOrgUnit` AND NOT EXISTS (SELECT * FROM `OrgUnit` AS cp
                                            WHERE isect0.`SrcOrgUnit`=cp.OrgUnit AND isect0.`TgtOrgUnit`=cp.`allRequiredITAvailbleToOrgUnit`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;allRequiredITAvailbleToOrgUnit;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    )
              )
    , 'delallRequiredITAvailbleToOrgUnit' =>
        array ( 'name'          => 'delallRequiredITAvailbleToOrgUnit'
              , 'ruleAdl'       => 'allRequiredITAvailbleToOrgUnit |- I[OrgUnit] /\\ (actExecutingOU~;actUsesITSvc);(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner)'
              , 'origin'        => 'line 246:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(allRequiredITAvailbleToOrgUnit |- I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner))
              // <=> { remove |- }
              //     -(-allRequiredITAvailbleToOrgUnit \\/ (I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner)))
              // <=> { De Morgan }
              //     allRequiredITAvailbleToOrgUnit /\\ -(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!(compITService~;compOwner))
              // <=> { -l!r = l~//rj }
              //     allRequiredITAvailbleToOrgUnit /\\ -(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ actUsesITSvc~;actExecutingOU \\ compITService~;compOwner)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //      ,ECpl (EIsc (EDcI cpt_OrgUnit
              //                  ,EIsc (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                              ,ECps (EDcD rel_actUsesITSvcActivityITService
              //                                    ,EFlp (EBrk (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                                      ,EDcD rel_actUsesITSvcActivityITService
              //                                                      )))
              //                                    )
              //                              )
              //                        ,ERrs (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                                    ,EDcD rel_actExecutingOUActivityOrgUnit
              //                                    )
              //                              ,ECps (EFlp (EDcD rel_compITServiceComputerITService)
              //                                    ,EDcD rel_compOwnerComputerOrgUnit
              //                                    )
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             allRequiredITAvailbleToOrgUnit /\\\\ -(I[OrgUnit] /\\\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\\\ actUsesITSvc~;actExecutingOU \\\\ compITService~;compOwner) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`allRequiredITAvailbleToOrgUnit` AS `tgt`
                          FROM `OrgUnit` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[OrgUnit] /\\\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\\\ actUsesITSvc~;actExecutingOU \\\\ compITService~;compOwner ([OrgUnit*OrgUnit]) */
                                              SELECT DISTINCT isect0.`SrcOrgUnit`, isect0.`TgtOrgUnit`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ */
                                                     
                                                     SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps2.`SrcOrgUnit` AS `TgtOrgUnit`
                                                     FROM `Activity` AS ECps0,
                                                          `actUsesITSvc` AS ECps1,
                                                          
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               actExecutingOU~;actUsesITSvc */
                                                            
                                                            SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                            FROM `Activity` AS ECps0,
                                                                 `actUsesITSvc` AS ECps1
                                                            WHERE ECps0.`Activity`=ECps1.`Activity`
                                                          ) AS ECps2
                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                       AND ECps1.`ITService`=ECps2.`TgtITService`
                                                   ) AS isect0, 
                                                   
                                                   ( /* case: ERrs (l,r)
                                                        actUsesITSvc~;actExecutingOU \\\\ compITService~;compOwner ([OrgUnit*OrgUnit]) */
                                                     SELECT `RResLeft`.`OrgUnit` AS `SrcOrgUnit`, `RResRight`.`OrgUnit` AS `TgtOrgUnit`
                                                     FROM `OrgUnit` AS `RResLeft`, `OrgUnit` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM 
                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                            actUsesITSvc~;actExecutingOU */
                                                                         
                                                                         SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`actExecutingOU` AS `TgtOrgUnit`
                                                                         FROM `actUsesITSvc` AS ECps0,
                                                                              `Activity` AS ECps1
                                                                         WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                       ) AS lhs
                                                             WHERE `RResLeft`.`OrgUnit`=lhs.`TgtOrgUnit` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                                    compITService~;compOwner */
                                                                                 
                                                                                 SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`compOwner` AS `TgtOrgUnit`
                                                                                 FROM `compITService` AS ECps0,
                                                                                      `Computer` AS ECps1
                                                                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcITService`=lhs.`SrcITService` AND rhs.`TgtOrgUnit`=`RResRight`.`OrgUnit`
                                                                   )
                                                           )
                                                   ) AS isect1, 
                                                   ( /* Case EDcI OrgUnit */
                                                     SELECT `OrgUnit` AS `OrgUnit`
                                                     FROM `OrgUnit` ) AS isect2
                                              WHERE (isect0.`SrcOrgUnit` = isect1.`SrcOrgUnit` AND isect0.`TgtOrgUnit` = isect1.`TgtOrgUnit`) AND isect0.`SrcOrgUnit` = isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.OrgUnit=cp.`SrcOrgUnit` AND isect0.`allRequiredITAvailbleToOrgUnit`=cp.`TgtOrgUnit`) AND isect0.OrgUnit IS NOT NULL AND isect0.`allRequiredITAvailbleToOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;allRequiredITAvailbleToOrgUnit;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    )
              )
    , 'insnoRequiredITAvailbleToOrgUnit' =>
        array ( 'name'          => 'insnoRequiredITAvailbleToOrgUnit'
              , 'ruleAdl'       => 'I[OrgUnit] /\\ (actExecutingOU~;actUsesITSvc);(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner) |- noRequiredITAvailbleToOrgUnit'
              , 'origin'        => 'line 251:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner) |- noRequiredITAvailbleToOrgUnit)
              // <=> { remove |- }
              //     -(-(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner)) \\/ noRequiredITAvailbleToOrgUnit)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner) /\\ -noRequiredITAvailbleToOrgUnit
              // <=> { -l!r = l~//rj }
              //     I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ actUsesITSvc~;actExecutingOU \\ -(compITService~;compOwner) /\\ -noRequiredITAvailbleToOrgUnit
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_OrgUnit
              //      ,EIsc (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  ,ECps (EDcD rel_actUsesITSvcActivityITService
              //                        ,EFlp (EBrk (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                          ,EDcD rel_actUsesITSvcActivityITService
              //                                          )))
              //                        )
              //                  )
              //            ,EIsc (ERrs (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                              ,EDcD rel_actExecutingOUActivityOrgUnit
              //                              )
              //                        ,ECpl (ECps (EFlp (EDcD rel_compITServiceComputerITService)
              //                                    ,EDcD rel_compOwnerComputerOrgUnit
              //                                    ))
              //                        )
              //                  ,ECpl (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit)
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[OrgUnit] /\\\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\\\ actUsesITSvc~;actExecutingOU \\\\ -(compITService~;compOwner) /\\\\ -noRequiredITAvailbleToOrgUnit ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps2.`SrcOrgUnit` AS `TgtOrgUnit`
                                 FROM `Activity` AS ECps0,
                                      `actUsesITSvc` AS ECps1,
                                      
                                      ( /* case: (ECps es), with two or more elements in es.
                                           actExecutingOU~;actUsesITSvc */
                                        
                                        SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                        FROM `Activity` AS ECps0,
                                             `actUsesITSvc` AS ECps1
                                        WHERE ECps0.`Activity`=ECps1.`Activity`
                                      ) AS ECps2
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                                   AND ECps1.`ITService`=ECps2.`TgtITService`
                               ) AS isect0, 
                               
                               ( /* case: ERrs (l,r)
                                    actUsesITSvc~;actExecutingOU \\\\ -(compITService~;compOwner) ([OrgUnit*OrgUnit]) */
                                 SELECT `RResLeft`.`OrgUnit` AS `SrcOrgUnit`, `RResRight`.`OrgUnit` AS `TgtOrgUnit`
                                 FROM `OrgUnit` AS `RResLeft`, `OrgUnit` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        actUsesITSvc~;actExecutingOU */
                                                     
                                                     SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`actExecutingOU` AS `TgtOrgUnit`
                                                     FROM `actUsesITSvc` AS ECps0,
                                                          `Activity` AS ECps1
                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                   ) AS lhs
                                         WHERE `RResLeft`.`OrgUnit`=lhs.`TgtOrgUnit` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: ECpl e
                                                                ECpl ( \\"compITService~;compOwner\\" ) */
                                                             SELECT DISTINCT cfst.`ITService` AS `SrcITService`, csnd.`OrgUnit` AS `TgtOrgUnit`
                                                             FROM `ITService` AS cfst,
                                                                  `OrgUnit` AS csnd
                                                             WHERE NOT EXISTS
                                                              (SELECT * FROM 
                                                                    ( /* case: (ECps es), with two or more elements in es.
                                                                         compITService~;compOwner */
                                                                      
                                                                      SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`compOwner` AS `TgtOrgUnit`
                                                                      FROM `compITService` AS ECps0,
                                                                           `Computer` AS ECps1
                                                                      WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                    ) AS cp
                                                               WHERE cfst.`ITService`=cp.`SrcITService` AND csnd.`OrgUnit`=cp.`TgtOrgUnit`)
                                                           ) AS rhs
                                                 WHERE rhs.`SrcITService`=lhs.`SrcITService` AND rhs.`TgtOrgUnit`=`RResRight`.`OrgUnit`
                                               )
                                       )
                               ) AS isect1, 
                               ( /* Case EDcI OrgUnit */
                                 SELECT `OrgUnit` AS `OrgUnit`
                                 FROM `OrgUnit` ) AS isect2
                          WHERE (isect0.`SrcOrgUnit` = isect1.`SrcOrgUnit` AND isect0.`TgtOrgUnit` = isect1.`TgtOrgUnit`) AND isect0.`SrcOrgUnit` = isect0.`TgtOrgUnit` AND NOT EXISTS (SELECT * FROM `OrgUnit` AS cp
                                            WHERE isect0.`SrcOrgUnit`=cp.OrgUnit AND isect0.`TgtOrgUnit`=cp.`noRequiredITAvailbleToOrgUnit`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;noRequiredITAvailbleToOrgUnit;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    )
              )
    , 'delnoRequiredITAvailbleToOrgUnit' =>
        array ( 'name'          => 'delnoRequiredITAvailbleToOrgUnit'
              , 'ruleAdl'       => 'noRequiredITAvailbleToOrgUnit |- I[OrgUnit] /\\ (actExecutingOU~;actUsesITSvc);(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner)'
              , 'origin'        => 'line 254:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(noRequiredITAvailbleToOrgUnit |- I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner))
              // <=> { remove |- }
              //     -(-noRequiredITAvailbleToOrgUnit \\/ (I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner)))
              // <=> { De Morgan }
              //     noRequiredITAvailbleToOrgUnit /\\ -(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ -(actExecutingOU~;actUsesITSvc)!-(compITService~;compOwner))
              // <=> { -l!r = l~//rj }
              //     noRequiredITAvailbleToOrgUnit /\\ -(I[OrgUnit] /\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\ actUsesITSvc~;actExecutingOU \\ -(compITService~;compOwner))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //      ,ECpl (EIsc (EDcI cpt_OrgUnit
              //                  ,EIsc (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                              ,ECps (EDcD rel_actUsesITSvcActivityITService
              //                                    ,EFlp (EBrk (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                                                      ,EDcD rel_actUsesITSvcActivityITService
              //                                                      )))
              //                                    )
              //                              )
              //                        ,ERrs (ECps (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                                    ,EDcD rel_actExecutingOUActivityOrgUnit
              //                                    )
              //                              ,ECpl (ECps (EFlp (EDcD rel_compITServiceComputerITService)
              //                                          ,EDcD rel_compOwnerComputerOrgUnit
              //                                          ))
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             noRequiredITAvailbleToOrgUnit /\\\\ -(I[OrgUnit] /\\\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\\\ actUsesITSvc~;actExecutingOU \\\\ -(compITService~;compOwner)) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`noRequiredITAvailbleToOrgUnit` AS `tgt`
                          FROM `OrgUnit` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[OrgUnit] /\\\\ actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ /\\\\ actUsesITSvc~;actExecutingOU \\\\ -(compITService~;compOwner) ([OrgUnit*OrgUnit]) */
                                              SELECT DISTINCT isect0.`SrcOrgUnit`, isect0.`TgtOrgUnit`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        actExecutingOU~;actUsesITSvc;(actExecutingOU~;actUsesITSvc)~ */
                                                     
                                                     SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps2.`SrcOrgUnit` AS `TgtOrgUnit`
                                                     FROM `Activity` AS ECps0,
                                                          `actUsesITSvc` AS ECps1,
                                                          
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               actExecutingOU~;actUsesITSvc */
                                                            
                                                            SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                            FROM `Activity` AS ECps0,
                                                                 `actUsesITSvc` AS ECps1
                                                            WHERE ECps0.`Activity`=ECps1.`Activity`
                                                          ) AS ECps2
                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                       AND ECps1.`ITService`=ECps2.`TgtITService`
                                                   ) AS isect0, 
                                                   
                                                   ( /* case: ERrs (l,r)
                                                        actUsesITSvc~;actExecutingOU \\\\ -(compITService~;compOwner) ([OrgUnit*OrgUnit]) */
                                                     SELECT `RResLeft`.`OrgUnit` AS `SrcOrgUnit`, `RResRight`.`OrgUnit` AS `TgtOrgUnit`
                                                     FROM `OrgUnit` AS `RResLeft`, `OrgUnit` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM 
                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                            actUsesITSvc~;actExecutingOU */
                                                                         
                                                                         SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`actExecutingOU` AS `TgtOrgUnit`
                                                                         FROM `actUsesITSvc` AS ECps0,
                                                                              `Activity` AS ECps1
                                                                         WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                       ) AS lhs
                                                             WHERE `RResLeft`.`OrgUnit`=lhs.`TgtOrgUnit` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: ECpl e
                                                                                    ECpl ( \\"compITService~;compOwner\\" ) */
                                                                                 SELECT DISTINCT cfst.`ITService` AS `SrcITService`, csnd.`OrgUnit` AS `TgtOrgUnit`
                                                                                 FROM `ITService` AS cfst,
                                                                                      `OrgUnit` AS csnd
                                                                                 WHERE NOT EXISTS
                                                                                  (SELECT * FROM 
                                                                                        ( /* case: (ECps es), with two or more elements in es.
                                                                                             compITService~;compOwner */
                                                                                          
                                                                                          SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`compOwner` AS `TgtOrgUnit`
                                                                                          FROM `compITService` AS ECps0,
                                                                                               `Computer` AS ECps1
                                                                                          WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                        ) AS cp
                                                                                   WHERE cfst.`ITService`=cp.`SrcITService` AND csnd.`OrgUnit`=cp.`TgtOrgUnit`)
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcITService`=lhs.`SrcITService` AND rhs.`TgtOrgUnit`=`RResRight`.`OrgUnit`
                                                                   )
                                                           )
                                                   ) AS isect1, 
                                                   ( /* Case EDcI OrgUnit */
                                                     SELECT `OrgUnit` AS `OrgUnit`
                                                     FROM `OrgUnit` ) AS isect2
                                              WHERE (isect0.`SrcOrgUnit` = isect1.`SrcOrgUnit` AND isect0.`TgtOrgUnit` = isect1.`TgtOrgUnit`) AND isect0.`SrcOrgUnit` = isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.OrgUnit=cp.`SrcOrgUnit` AND isect0.`noRequiredITAvailbleToOrgUnit`=cp.`TgtOrgUnit`) AND isect0.OrgUnit IS NOT NULL AND isect0.`noRequiredITAvailbleToOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;noRequiredITAvailbleToOrgUnit;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    )
              )
    , 'insouCmpStatRed' =>
        array ( 'name'          => 'insouCmpStatRed'
              , 'ruleAdl'       => 'I[OrgUnit] /\\ noRequiredITAvailbleToOrgUnit |- ouCmpStat;\'Red\'[Status];ouCmpStat~'
              , 'origin'        => 'line 258:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] /\\ noRequiredITAvailbleToOrgUnit |- ouCmpStat;\'Red\'[Status];ouCmpStat~)
              // <=> { remove |- }
              //     -(-(I[OrgUnit] /\\ noRequiredITAvailbleToOrgUnit) \\/ ouCmpStat;\'Red\'[Status];ouCmpStat~)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ noRequiredITAvailbleToOrgUnit /\\ -(ouCmpStat;\'Red\'[Status];ouCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_OrgUnit
              //      ,EIsc (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            ,ECpl (ECps (EDcD rel_ouCmpStatOrgUnitStatus
              //                        ,ECps (EMp1 "Red" cpt_Status
              //                              ,EFlp (EDcD rel_ouCmpStatOrgUnitStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[OrgUnit] /\\\\ noRequiredITAvailbleToOrgUnit /\\\\ -(ouCmpStat;\\\'Red\\\'[Status];ouCmpStat~) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`noRequiredITAvailbleToOrgUnit` AS `tgt`
                          FROM `OrgUnit` AS isect0, 
                               ( /* Case EDcI OrgUnit */
                                 SELECT `OrgUnit` AS `OrgUnit`
                                 FROM `OrgUnit` ) AS isect1
                          WHERE isect0.OrgUnit = isect0.`noRequiredITAvailbleToOrgUnit` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ouCmpStat;\\\'Red\\\'[Status];ouCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps2.`OrgUnit` AS `TgtOrgUnit`
                                              FROM `OrgUnit` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `OrgUnit` AS ECps2
                                              WHERE ECps0.`ouCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`ouCmpStat`
                                            ) AS cp
                                            WHERE isect0.OrgUnit=cp.`SrcOrgUnit` AND isect0.`noRequiredITAvailbleToOrgUnit`=cp.`TgtOrgUnit`) AND isect0.OrgUnit IS NOT NULL AND isect0.`noRequiredITAvailbleToOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouCmpStat;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'insouCmpStatGreen' =>
        array ( 'name'          => 'insouCmpStatGreen'
              , 'ruleAdl'       => 'I[OrgUnit] /\\ allRequiredITAvailbleToOrgUnit |- ouCmpStat;\'Green\'[Status];ouCmpStat~'
              , 'origin'        => 'line 263:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] /\\ allRequiredITAvailbleToOrgUnit |- ouCmpStat;\'Green\'[Status];ouCmpStat~)
              // <=> { remove |- }
              //     -(-(I[OrgUnit] /\\ allRequiredITAvailbleToOrgUnit) \\/ ouCmpStat;\'Green\'[Status];ouCmpStat~)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ allRequiredITAvailbleToOrgUnit /\\ -(ouCmpStat;\'Green\'[Status];ouCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_OrgUnit
              //      ,EIsc (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            ,ECpl (ECps (EDcD rel_ouCmpStatOrgUnitStatus
              //                        ,ECps (EMp1 "Green" cpt_Status
              //                              ,EFlp (EDcD rel_ouCmpStatOrgUnitStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[OrgUnit] /\\\\ allRequiredITAvailbleToOrgUnit /\\\\ -(ouCmpStat;\\\'Green\\\'[Status];ouCmpStat~) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`allRequiredITAvailbleToOrgUnit` AS `tgt`
                          FROM `OrgUnit` AS isect0, 
                               ( /* Case EDcI OrgUnit */
                                 SELECT `OrgUnit` AS `OrgUnit`
                                 FROM `OrgUnit` ) AS isect1
                          WHERE isect0.OrgUnit = isect0.`allRequiredITAvailbleToOrgUnit` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ouCmpStat;\\\'Green\\\'[Status];ouCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps2.`OrgUnit` AS `TgtOrgUnit`
                                              FROM `OrgUnit` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `OrgUnit` AS ECps2
                                              WHERE ECps0.`ouCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`ouCmpStat`
                                            ) AS cp
                                            WHERE isect0.OrgUnit=cp.`SrcOrgUnit` AND isect0.`allRequiredITAvailbleToOrgUnit`=cp.`TgtOrgUnit`) AND isect0.OrgUnit IS NOT NULL AND isect0.`allRequiredITAvailbleToOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouCmpStat;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'insouCmpStatYellow' =>
        array ( 'name'          => 'insouCmpStatYellow'
              , 'ruleAdl'       => 'I[OrgUnit] /\\ -noRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit |- ouCmpStat;\'Yellow\'[Status];ouCmpStat~'
              , 'origin'        => 'line 268:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] /\\ -noRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit |- ouCmpStat;\'Yellow\'[Status];ouCmpStat~)
              // <=> { remove |- }
              //     -(-(I[OrgUnit] /\\ -noRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit) \\/ ouCmpStat;\'Yellow\'[Status];ouCmpStat~)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ -noRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit /\\ -(ouCmpStat;\'Yellow\'[Status];ouCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_OrgUnit
              //      ,EIsc (ECpl (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit)
              //            ,EIsc (ECpl (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit)
              //                  ,ECpl (ECps (EDcD rel_ouCmpStatOrgUnitStatus
              //                              ,ECps (EMp1 "Yellow" cpt_Status
              //                                    ,EFlp (EDcD rel_ouCmpStatOrgUnitStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[OrgUnit] /\\\\ -noRequiredITAvailbleToOrgUnit /\\\\ -allRequiredITAvailbleToOrgUnit /\\\\ -(ouCmpStat;\\\'Yellow\\\'[Status];ouCmpStat~) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`OrgUnit` AS `tgt`
                          FROM ( /* Case EDcI OrgUnit */
                                 SELECT `OrgUnit` AS `OrgUnit`
                                 FROM `OrgUnit` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `OrgUnit` AS cp
                                            WHERE isect0.`OrgUnit`=cp.OrgUnit AND isect0.`OrgUnit`=cp.`noRequiredITAvailbleToOrgUnit`) AND NOT EXISTS (SELECT * FROM `OrgUnit` AS cp
                                            WHERE isect0.`OrgUnit`=cp.OrgUnit AND isect0.`OrgUnit`=cp.`allRequiredITAvailbleToOrgUnit`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ouCmpStat;\\\'Yellow\\\'[Status];ouCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps2.`OrgUnit` AS `TgtOrgUnit`
                                              FROM `OrgUnit` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `OrgUnit` AS ECps2
                                              WHERE ECps0.`ouCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`ouCmpStat`
                                            ) AS cp
                                            WHERE isect0.`OrgUnit`=cp.`SrcOrgUnit` AND isect0.`OrgUnit`=cp.`TgtOrgUnit`) AND isect0.`OrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouCmpStat;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'InsOrgUnitStatus' =>
        array ( 'name'          => 'InsOrgUnitStatus'
              , 'ruleAdl'       => 'ouMnlStat \\/ (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat |- ouStatus'
              , 'origin'        => 'line 274:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouMnlStat \\/ (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat |- ouStatus)
              // <=> { remove |- }
              //     -(-(ouMnlStat \\/ (I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat) \\/ ouStatus)
              // <=> { De Morgan }
              //     -(-ouMnlStat /\\ -((I[OrgUnit] /\\ -(ouMnlStat;ouMnlStat~));ouCmpStat)) /\\ -ouStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_ouMnlStatOrgUnitStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_OrgUnit
              //                                    ,ECpl (ECps (EDcD rel_ouMnlStatOrgUnitStatus
              //                                                ,EFlp (EDcD rel_ouMnlStatOrgUnitStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_ouCmpStatOrgUnitStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_ouStatusOrgUnitStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-ouMnlStat /\\\\ -((I[OrgUnit] /\\\\ -(ouMnlStat;ouMnlStat~));ouCmpStat)) /\\\\ -ouStatus ([OrgUnit*Status]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-ouMnlStat /\\\\ -((I[OrgUnit] /\\\\ -(ouMnlStat;ouMnlStat~));ouCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`Status` AS `TgtStatus`
                                 FROM `OrgUnit` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -ouMnlStat /\\\\ -((I[OrgUnit] /\\\\ -(ouMnlStat;ouMnlStat~));ouCmpStat) ([OrgUnit*Status]) */
                                          SELECT DISTINCT isect0.`SrcOrgUnit`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"ouMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`Status` AS `TgtStatus`
                                                 FROM `OrgUnit` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `OrgUnit` AS cp
                                                   WHERE cfst.`OrgUnit`=cp.`OrgUnit` AND csnd.`Status`=cp.`ouMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[OrgUnit] /\\\\ -(ouMnlStat;ouMnlStat~));ouCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcOrgUnit`, ECps1.`ouCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[OrgUnit] /\\\\ -(ouMnlStat;ouMnlStat~) ([OrgUnit*OrgUnit]) */
                                                                     SELECT DISTINCT isect0.`OrgUnit` AS `SrcOrgUnit`, isect0.`OrgUnit` AS `TgtOrgUnit`
                                                                     FROM ( /* Case EDcI OrgUnit */
                                                                            SELECT `OrgUnit` AS `OrgUnit`
                                                                            FROM `OrgUnit` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            ouMnlStat;ouMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps1.`OrgUnit` AS `TgtOrgUnit`
                                                                                         FROM `OrgUnit` AS ECps0,
                                                                                              `OrgUnit` AS ECps1
                                                                                         WHERE ECps0.`ouMnlStat`=ECps1.`ouMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`OrgUnit`=cp.`SrcOrgUnit` AND isect0.`OrgUnit`=cp.`TgtOrgUnit`) AND isect0.`OrgUnit` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `OrgUnit` AS ECps1
                                                              WHERE ECps0.`TgtOrgUnit`=ECps1.`OrgUnit`
                                                            ) AS cp
                                                            WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `OrgUnit` AS cp
                                            WHERE isect0.`SrcOrgUnit`=cp.`OrgUnit` AND isect0.`TgtStatus`=cp.`ouStatus`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouStatus;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultOrgUnitStatus' =>
        array ( 'name'          => 'defaultOrgUnitStatus'
              , 'ruleAdl'       => 'I[OrgUnit] |- ouStatus;ouStatus~'
              , 'origin'        => 'line 277:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(I[OrgUnit] |- ouStatus;ouStatus~)
              // <=> { remove |- }
              //     -(-I[OrgUnit] \\/ ouStatus;ouStatus~)
              // <=> { De Morgan }
              //     I[OrgUnit] /\\ -(ouStatus;ouStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_OrgUnit
              //      ,ECpl (ECps (EDcD rel_ouStatusOrgUnitStatus
              //                  ,EFlp (EDcD rel_ouStatusOrgUnitStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[OrgUnit] /\\\\ -(ouStatus;ouStatus~) ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`OrgUnit` AS `tgt`
                          FROM ( /* Case EDcI OrgUnit */
                                 SELECT `OrgUnit` AS `OrgUnit`
                                 FROM `OrgUnit` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 ouStatus;ouStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps1.`OrgUnit` AS `TgtOrgUnit`
                                              FROM `OrgUnit` AS ECps0,
                                                   `OrgUnit` AS ECps1
                                              WHERE ECps0.`ouStatus`=ECps1.`ouStatus`
                                            ) AS cp
                                            WHERE isect0.`OrgUnit`=cp.`SrcOrgUnit` AND isect0.`OrgUnit`=cp.`TgtOrgUnit`) AND isect0.`OrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;ouStatus;OrgUnit;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'OrgUnit'
                            , 'expSQL' =>
                                '/* I[OrgUnit] */
                                   SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                   FROM `OrgUnit`
                                   WHERE `OrgUnit` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'actCmpStatIsGrey' =>
        array ( 'name'          => 'actCmpStatIsGrey'
              , 'ruleAdl'       => 'I[Activity] /\\ -(actExecutingOU;actExecutingOU~) |- actCmpStat;\'Grey\'[Status];actCmpStat~'
              , 'origin'        => 'line 293:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ -(actExecutingOU;actExecutingOU~) |- actCmpStat;\'Grey\'[Status];actCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ -(actExecutingOU;actExecutingOU~)) \\/ actCmpStat;\'Grey\'[Status];actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actExecutingOU;actExecutingOU~) /\\ -(actCmpStat;\'Grey\'[Status];actCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,EIsc (ECpl (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                        ,EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                        ))
              //            ,ECpl (ECps (EDcD rel_actCmpStatActivityStatus
              //                        ,ECps (EMp1 "Grey" cpt_Status
              //                              ,EFlp (EDcD rel_actCmpStatActivityStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ -(actExecutingOU;actExecutingOU~) /\\\\ -(actCmpStat;\\\'Grey\\\'[Status];actCmpStat~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`Activity` AS `src`, isect0.`Activity` AS `tgt`
                          FROM ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actExecutingOU;actExecutingOU~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   `Activity` AS ECps1
                                              WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                                            ) AS cp
                                            WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actCmpStat;\\\'Grey\\\'[Status];actCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Grey\' AS `SrcStatus`, \'Grey\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Activity` AS ECps2
                                              WHERE ECps0.`actCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`actCmpStat`
                                            ) AS cp
                                            WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Grey')
                    )
              )
    , 'actCmpStatIsBlue' =>
        array ( 'name'          => 'actCmpStatIsBlue'
              , 'ruleAdl'       => 'I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ -(actUsesITSvc;actUsesITSvc~) |- actCmpStat;\'Blue\'[Status];actCmpStat~'
              , 'origin'        => 'line 298:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ -(actUsesITSvc;actUsesITSvc~) |- actCmpStat;\'Blue\'[Status];actCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ -(actUsesITSvc;actUsesITSvc~)) \\/ actCmpStat;\'Blue\'[Status];actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ -(actUsesITSvc;actUsesITSvc~) /\\ -(actCmpStat;\'Blue\'[Status];actCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,EIsc (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                  ,EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  )
              //            ,EIsc (ECpl (ECps (EDcD rel_actUsesITSvcActivityITService
              //                              ,EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                              ))
              //                  ,ECpl (ECps (EDcD rel_actCmpStatActivityStatus
              //                              ,ECps (EMp1 "Blue" cpt_Status
              //                                    ,EFlp (EDcD rel_actCmpStatActivityStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ actExecutingOU;actExecutingOU~ /\\\\ -(actUsesITSvc;actUsesITSvc~) /\\\\ -(actCmpStat;\\\'Blue\\\'[Status];actCmpStat~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS `src`, isect0.`TgtActivity` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU;actExecutingOU~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                               ) AS isect0, 
                               ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect1
                          WHERE isect0.`SrcActivity` = isect0.`TgtActivity` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actUsesITSvc;actUsesITSvc~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                              FROM `actUsesITSvc` AS ECps0,
                                                   `actUsesITSvc` AS ECps1
                                              WHERE ECps0.`ITService`=ECps1.`ITService`
                                            ) AS cp
                                            WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TgtActivity`=cp.`TgtActivity`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actCmpStat;\\\'Blue\\\'[Status];actCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Blue\' AS `SrcStatus`, \'Blue\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Activity` AS ECps2
                                              WHERE ECps0.`actCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`actCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TgtActivity`=cp.`TgtActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Blue')
                    )
              )
    , 'actCmpStatIsRed' =>
        array ( 'name'          => 'actCmpStatIsRed'
              , 'ruleAdl'       => 'I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~ |- actCmpStat;\'Red\'[Status];actCmpStat~'
              , 'origin'        => 'line 303:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~ |- actCmpStat;\'Red\'[Status];actCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~) \\/ actCmpStat;\'Red\'[Status];actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~ /\\ -(actCmpStat;\'Red\'[Status];actCmpStat~)
              // <=> { -l!r = l~//rj }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ actUsesITSvc~ \\ (actExecutingOU;-(compOwner~;compITService))~ /\\ -(actCmpStat;\'Red\'[Status];actCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,EIsc (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                  ,EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  )
              //            ,EIsc (ECps (EDcD rel_actUsesITSvcActivityITService
              //                        ,EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                        )
              //                  ,EIsc (ERrs (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                              ,EFlp (EBrk (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                                                ,ECpl (EBrk (ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                                  ,EDcD rel_compITServiceComputerITService
              //                                                                  )))
              //                                                )))
              //                              )
              //                        ,ECpl (ECps (EDcD rel_actCmpStatActivityStatus
              //                                    ,ECps (EMp1 "Red" cpt_Status
              //                                          ,EFlp (EDcD rel_actCmpStatActivityStatus)
              //                                          )
              //                                    ))
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ actExecutingOU;actExecutingOU~ /\\\\ actUsesITSvc;actUsesITSvc~ /\\\\ actUsesITSvc~ \\\\ (actExecutingOU;-(compOwner~;compITService))~ /\\\\ -(actCmpStat;\\\'Red\\\'[Status];actCmpStat~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS `src`, isect0.`TgtActivity` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU;actExecutingOU~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc;actUsesITSvc~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `actUsesITSvc` AS ECps0,
                                      `actUsesITSvc` AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`ITService`
                               ) AS isect1, 
                               
                               ( /* case: ERrs (l,r)
                                    actUsesITSvc~ \\\\ (actExecutingOU;-(compOwner~;compITService))~ ([Activity*Activity]) */
                                 SELECT `RResLeft`.`Activity` AS `SrcActivity`, `RResRight`.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS `RResLeft`, `Activity` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM `actUsesITSvc` AS lhs
                                         WHERE `RResLeft`.`Activity`=lhs.`Activity` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                actExecutingOU;-(compOwner~;compITService) */
                                                             
                                                             SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtITService`
                                                             FROM `Activity` AS ECps0,
                                                                  
                                                                  ( /* case: ECpl e
                                                                       ECpl ( \\"compOwner~;compITService\\" ) */
                                                                    SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`ITService` AS `TgtITService`
                                                                    FROM `OrgUnit` AS cfst,
                                                                         `ITService` AS csnd
                                                                    WHERE NOT EXISTS
                                                                     (SELECT * FROM 
                                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                                compOwner~;compITService */
                                                                             
                                                                             SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                             FROM `Computer` AS ECps0,
                                                                                  `compITService` AS ECps1
                                                                             WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                           ) AS cp
                                                                      WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`ITService`=cp.`TgtITService`)
                                                                  ) AS ECps1
                                                             WHERE ECps0.`actExecutingOU`=ECps1.`SrcOrgUnit`
                                                           ) AS rhs
                                                 WHERE rhs.`TgtITService`=lhs.`ITService` AND rhs.`SrcActivity`=`RResRight`.`Activity`
                                               )
                                       )
                               ) AS isect2, 
                               ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect3
                          WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TgtActivity` = isect1.`TgtActivity`) AND (isect0.`SrcActivity` = isect2.`SrcActivity` AND isect0.`TgtActivity` = isect2.`TgtActivity`) AND isect0.`SrcActivity` = isect0.`TgtActivity` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actCmpStat;\\\'Red\\\'[Status];actCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Activity` AS ECps2
                                              WHERE ECps0.`actCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`actCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TgtActivity`=cp.`TgtActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'actCmpStatIsYellow' =>
        array ( 'name'          => 'actCmpStatIsYellow'
              , 'ruleAdl'       => 'I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actPlannedStartTime;actPlannedStartTime~ /\\ -(-actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~) /\\ -(-actUsesITSvc!(actExecutingOU;compOwner~;compITService)~) |- actCmpStat;\'Yellow\'[Status];actCmpStat~'
              , 'origin'        => 'line 309:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actPlannedStartTime;actPlannedStartTime~ /\\ -(-actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~) /\\ -(-actUsesITSvc!(actExecutingOU;compOwner~;compITService)~) |- actCmpStat;\'Yellow\'[Status];actCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actPlannedStartTime;actPlannedStartTime~ /\\ -(-actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~) /\\ -(-actUsesITSvc!(actExecutingOU;compOwner~;compITService)~)) \\/ actCmpStat;\'Yellow\'[Status];actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actPlannedStartTime;actPlannedStartTime~ /\\ -(-actUsesITSvc!(actExecutingOU;-(compOwner~;compITService))~) /\\ -(-actUsesITSvc!(actExecutingOU;compOwner~;compITService)~) /\\ -(actCmpStat;\'Yellow\'[Status];actCmpStat~)
              // <=> { De Morgan and De Morgan }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actPlannedStartTime;actPlannedStartTime~ /\\ actUsesITSvc;-(actExecutingOU;-(compOwner~;compITService))~ /\\ actUsesITSvc;-(actExecutingOU;compOwner~;compITService)~ /\\ -(actCmpStat;\'Yellow\'[Status];actCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,EIsc (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                  ,EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  )
              //            ,EIsc (ECps (EDcD rel_actPlannedStartTimeActivityTimestamp
              //                        ,EFlp (EDcD rel_actPlannedStartTimeActivityTimestamp)
              //                        )
              //                  ,EIsc (ECps (EDcD rel_actUsesITSvcActivityITService
              //                              ,ECpl (EFlp (EBrk (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                                                      ,ECpl (EBrk (ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                                        ,EDcD rel_compITServiceComputerITService
              //                                                                        )))
              //                                                      ))))
              //                              )
              //                        ,EIsc (ECps (EDcD rel_actUsesITSvcActivityITService
              //                                    ,ECpl (EFlp (EBrk (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                                                            ,ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                                  ,EDcD rel_compITServiceComputerITService
              //                                                                  )
              //                                                            ))))
              //                                    )
              //                              ,ECpl (ECps (EDcD rel_actCmpStatActivityStatus
              //                                          ,ECps (EMp1 "Yellow" cpt_Status
              //                                                ,EFlp (EDcD rel_actCmpStatActivityStatus)
              //                                                )
              //                                          ))
              //                              )
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ actExecutingOU;actExecutingOU~ /\\\\ actPlannedStartTime;actPlannedStartTime~ /\\\\ actUsesITSvc;-(actExecutingOU;-(compOwner~;compITService))~ /\\\\ actUsesITSvc;-(actExecutingOU;compOwner~;compITService)~ /\\\\ -(actCmpStat;\\\'Yellow\\\'[Status];actCmpStat~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS `src`, isect0.`TgtActivity` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU;actExecutingOU~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlannedStartTime;actPlannedStartTime~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`actPlannedStartTime`=ECps1.`actPlannedStartTime`
                               ) AS isect1, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc;-(actExecutingOU;-(compOwner~;compITService))~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtActivity`
                                 FROM `actUsesITSvc` AS ECps0,
                                      
                                      ( /* case: ECpl e
                                           ECpl ( \\"(actExecutingOU;-(compOwner~;compITService))~\\" ) */
                                        SELECT DISTINCT cfst.`ITService` AS `SrcITService`, csnd.`Activity` AS `TgtActivity`
                                        FROM `ITService` AS cfst,
                                             `Activity` AS csnd
                                        WHERE NOT EXISTS
                                         (SELECT * FROM 
                                               ( /* case: (ECps es), with two or more elements in es.
                                                    actExecutingOU;-(compOwner~;compITService) */
                                                 
                                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtITService`
                                                 FROM `Activity` AS ECps0,
                                                      
                                                      ( /* case: ECpl e
                                                           ECpl ( \\"compOwner~;compITService\\" ) */
                                                        SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`ITService` AS `TgtITService`
                                                        FROM `OrgUnit` AS cfst,
                                                             `ITService` AS csnd
                                                        WHERE NOT EXISTS
                                                         (SELECT * FROM 
                                                               ( /* case: (ECps es), with two or more elements in es.
                                                                    compOwner~;compITService */
                                                                 
                                                                 SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                 FROM `Computer` AS ECps0,
                                                                      `compITService` AS ECps1
                                                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                                                               ) AS cp
                                                          WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`ITService`=cp.`TgtITService`)
                                                      ) AS ECps1
                                                 WHERE ECps0.`actExecutingOU`=ECps1.`SrcOrgUnit`
                                               ) AS cp
                                          WHERE cfst.`ITService`=cp.`TgtITService` AND csnd.`Activity`=cp.`SrcActivity`)
                                      ) AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`SrcITService`
                               ) AS isect2, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc;-(actExecutingOU;compOwner~;compITService)~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtActivity`
                                 FROM `actUsesITSvc` AS ECps0,
                                      
                                      ( /* case: ECpl e
                                           ECpl ( \\"(actExecutingOU;compOwner~;compITService)~\\" ) */
                                        SELECT DISTINCT cfst.`ITService` AS `SrcITService`, csnd.`Activity` AS `TgtActivity`
                                        FROM `ITService` AS cfst,
                                             `Activity` AS csnd
                                        WHERE NOT EXISTS
                                         (SELECT * FROM 
                                               ( /* case: (ECps es), with two or more elements in es.
                                                    actExecutingOU;compOwner~;compITService */
                                                 
                                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`ITService` AS `TgtITService`
                                                 FROM `Activity` AS ECps0,
                                                      `Computer` AS ECps1,
                                                      `compITService` AS ECps2
                                                 WHERE ECps0.`actExecutingOU`=ECps1.`compOwner`
                                                   AND ECps1.`Computer`=ECps2.`Computer`
                                               ) AS cp
                                          WHERE cfst.`ITService`=cp.`TgtITService` AND csnd.`Activity`=cp.`SrcActivity`)
                                      ) AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`SrcITService`
                               ) AS isect3, 
                               ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect4
                          WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TgtActivity` = isect1.`TgtActivity`) AND (isect0.`SrcActivity` = isect2.`SrcActivity` AND isect0.`TgtActivity` = isect2.`TgtActivity`) AND (isect0.`SrcActivity` = isect3.`SrcActivity` AND isect0.`TgtActivity` = isect3.`TgtActivity`) AND isect0.`SrcActivity` = isect0.`TgtActivity` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actCmpStat;\\\'Yellow\\\'[Status];actCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Activity` AS ECps2
                                              WHERE ECps0.`actCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`actCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TgtActivity`=cp.`TgtActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'actCmpStatIsGreen' =>
        array ( 'name'          => 'actCmpStatIsGreen'
              , 'ruleAdl'       => 'I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;compOwner~;compITService)~ |- actCmpStat;\'Green\'[Status];actCmpStat~'
              , 'origin'        => 'line 316:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;compOwner~;compITService)~ |- actCmpStat;\'Green\'[Status];actCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;compOwner~;compITService)~) \\/ actCmpStat;\'Green\'[Status];actCmpStat~)
              // <=> { De Morgan }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ -actUsesITSvc!(actExecutingOU;compOwner~;compITService)~ /\\ -(actCmpStat;\'Green\'[Status];actCmpStat~)
              // <=> { -l!r = l~ }
              //     I[Activity] /\\ actExecutingOU;actExecutingOU~ /\\ actUsesITSvc;actUsesITSvc~ /\\ actUsesITSvc~ \\ (actExecutingOU;compOwner~;compITService)~ /\\ -(actCmpStat;\'Green\'[Status];actCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,EIsc (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                  ,EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  )
              //            ,EIsc (ECps (EDcD rel_actUsesITSvcActivityITService
              //                        ,EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                        )
              //                  ,EIsc (ERrs (EFlp (EDcD rel_actUsesITSvcActivityITService)
              //                              ,EFlp (EBrk (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                                                ,ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //                                                      ,EDcD rel_compITServiceComputerITService
              //                                                      )
              //                                                )))
              //                              )
              //                        ,ECpl (ECps (EDcD rel_actCmpStatActivityStatus
              //                                    ,ECps (EMp1 "Green" cpt_Status
              //                                          ,EFlp (EDcD rel_actCmpStatActivityStatus)
              //                                          )
              //                                    ))
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ actExecutingOU;actExecutingOU~ /\\\\ actUsesITSvc;actUsesITSvc~ /\\\\ actUsesITSvc~ \\\\ (actExecutingOU;compOwner~;compITService)~ /\\\\ -(actCmpStat;\\\'Green\\\'[Status];actCmpStat~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS `src`, isect0.`TgtActivity` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU;actExecutingOU~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    actUsesITSvc;actUsesITSvc~ */
                                 
                                 SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                 FROM `actUsesITSvc` AS ECps0,
                                      `actUsesITSvc` AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`ITService`
                               ) AS isect1, 
                               
                               ( /* case: ERrs (l,r)
                                    actUsesITSvc~ \\\\ (actExecutingOU;compOwner~;compITService)~ ([Activity*Activity]) */
                                 SELECT `RResLeft`.`Activity` AS `SrcActivity`, `RResRight`.`Activity` AS `TgtActivity`
                                 FROM `Activity` AS `RResLeft`, `Activity` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM `actUsesITSvc` AS lhs
                                         WHERE `RResLeft`.`Activity`=lhs.`Activity` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                actExecutingOU;compOwner~;compITService */
                                                             
                                                             SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`ITService` AS `TgtITService`
                                                             FROM `Activity` AS ECps0,
                                                                  `Computer` AS ECps1,
                                                                  `compITService` AS ECps2
                                                             WHERE ECps0.`actExecutingOU`=ECps1.`compOwner`
                                                               AND ECps1.`Computer`=ECps2.`Computer`
                                                           ) AS rhs
                                                 WHERE rhs.`TgtITService`=lhs.`ITService` AND rhs.`SrcActivity`=`RResRight`.`Activity`
                                               )
                                       )
                               ) AS isect2, 
                               ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect3
                          WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TgtActivity` = isect1.`TgtActivity`) AND (isect0.`SrcActivity` = isect2.`SrcActivity` AND isect0.`TgtActivity` = isect2.`TgtActivity`) AND isect0.`SrcActivity` = isect0.`TgtActivity` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actCmpStat;\\\'Green\\\'[Status];actCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps2.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Activity` AS ECps2
                                              WHERE ECps0.`actCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`actCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TgtActivity`=cp.`TgtActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actCmpStat;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'InsActivityStatus' =>
        array ( 'name'          => 'InsActivityStatus'
              , 'ruleAdl'       => 'actMnlStat \\/ (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat |- actStatus'
              , 'origin'        => 'line 323:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actMnlStat \\/ (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat |- actStatus)
              // <=> { remove |- }
              //     -(-(actMnlStat \\/ (I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat) \\/ actStatus)
              // <=> { De Morgan }
              //     -(-actMnlStat /\\ -((I[Activity] /\\ -(actMnlStat;actMnlStat~));actCmpStat)) /\\ -actStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_actMnlStatActivityStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_Activity
              //                                    ,ECpl (ECps (EDcD rel_actMnlStatActivityStatus
              //                                                ,EFlp (EDcD rel_actMnlStatActivityStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_actCmpStatActivityStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_actStatusActivityStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-actMnlStat /\\\\ -((I[Activity] /\\\\ -(actMnlStat;actMnlStat~));actCmpStat)) /\\\\ -actStatus ([Activity*Status]) */
                          SELECT DISTINCT isect0.`SrcActivity` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-actMnlStat /\\\\ -((I[Activity] /\\\\ -(actMnlStat;actMnlStat~));actCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`Activity` AS `SrcActivity`, csnd.`Status` AS `TgtStatus`
                                 FROM `Activity` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -actMnlStat /\\\\ -((I[Activity] /\\\\ -(actMnlStat;actMnlStat~));actCmpStat) ([Activity*Status]) */
                                          SELECT DISTINCT isect0.`SrcActivity`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"actMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`Activity` AS `SrcActivity`, csnd.`Status` AS `TgtStatus`
                                                 FROM `Activity` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Activity` AS cp
                                                   WHERE cfst.`Activity`=cp.`Activity` AND csnd.`Status`=cp.`actMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[Activity] /\\\\ -(actMnlStat;actMnlStat~));actCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcActivity`, ECps1.`actCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Activity] /\\\\ -(actMnlStat;actMnlStat~) ([Activity*Activity]) */
                                                                     SELECT DISTINCT isect0.`Activity` AS `SrcActivity`, isect0.`Activity` AS `TgtActivity`
                                                                     FROM ( /* Case EDcI Activity */
                                                                            SELECT `Activity` AS `Activity`
                                                                            FROM `Activity` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            actMnlStat;actMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                                                         FROM `Activity` AS ECps0,
                                                                                              `Activity` AS ECps1
                                                                                         WHERE ECps0.`actMnlStat`=ECps1.`actMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `Activity` AS ECps1
                                                              WHERE ECps0.`TgtActivity`=ECps1.`Activity`
                                                            ) AS cp
                                                            WHERE isect0.`SrcActivity`=cp.`SrcActivity` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Activity`=cp.`SrcActivity` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Activity` AS cp
                                            WHERE isect0.`SrcActivity`=cp.`Activity` AND isect0.`TgtStatus`=cp.`actStatus`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actStatus;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultActivityStatus' =>
        array ( 'name'          => 'defaultActivityStatus'
              , 'ruleAdl'       => 'I[Activity] |- actStatus;actStatus~'
              , 'origin'        => 'line 326:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actStatus;actStatus~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actStatus;actStatus~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actStatus;actStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,ECpl (ECps (EDcD rel_actStatusActivityStatus
              //                  ,EFlp (EDcD rel_actStatusActivityStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ -(actStatus;actStatus~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`Activity` AS `src`, isect0.`Activity` AS `tgt`
                          FROM ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actStatus;actStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   `Activity` AS ECps1
                                              WHERE ECps0.`actStatus`=ECps1.`actStatus`
                                            ) AS cp
                                            WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;actStatus;Activity;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Activity'
                            , 'expSQL' =>
                                '/* I[Activity] */
                                   SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                   FROM `Activity`
                                   WHERE `Activity` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'resultCmpStatIsRed' =>
        array ( 'name'          => 'resultCmpStatIsRed'
              , 'ruleAdl'       => 'I[Result] /\\ -(actResult~;actResult) |- resultCmpStat;\'Red\'[Status];resultCmpStat~'
              , 'origin'        => 'line 340:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Result'
              // Normalization steps:
              //     -(I[Result] /\\ -(actResult~;actResult) |- resultCmpStat;\'Red\'[Status];resultCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Result] /\\ -(actResult~;actResult)) \\/ resultCmpStat;\'Red\'[Status];resultCmpStat~)
              // <=> { De Morgan }
              //     I[Result] /\\ -(actResult~;actResult) /\\ -(resultCmpStat;\'Red\'[Status];resultCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Result
              //      ,EIsc (ECpl (ECps (EFlp (EDcD rel_actResultActivityResult)
              //                        ,EDcD rel_actResultActivityResult
              //                        ))
              //            ,ECpl (ECps (EDcD rel_resultCmpStatResultStatus
              //                        ,ECps (EMp1 "Red" cpt_Status
              //                              ,EFlp (EDcD rel_resultCmpStatResultStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Result] /\\\\ -(actResult~;actResult) /\\\\ -(resultCmpStat;\\\'Red\\\'[Status];resultCmpStat~) ([Result*Result]) */
                          SELECT DISTINCT isect0.`Result` AS `src`, isect0.`Result` AS `tgt`
                          FROM ( /* Case EDcI Result */
                                 SELECT `Result` AS `Result`
                                 FROM `Result` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actResult~;actResult */
                                              
                                              SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps1.`actResult` AS `TgtResult`
                                              FROM `Activity` AS ECps0,
                                                   `Activity` AS ECps1
                                              WHERE ECps0.`Activity`=ECps1.`Activity`
                                            ) AS cp
                                            WHERE isect0.`Result`=cp.`SrcResult` AND isect0.`Result`=cp.`TgtResult`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 resultCmpStat;\\\'Red\\\'[Status];resultCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps2.`Result` AS `TgtResult`
                                              FROM `Result` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Result` AS ECps2
                                              WHERE ECps0.`resultCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`resultCmpStat`
                                            ) AS cp
                                            WHERE isect0.`Result`=cp.`SrcResult` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Result` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;resultCmpStat;Result;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Result'
                            , 'expSQL' =>
                                '/* I[Result] */
                                   SELECT `Result` AS `src`, `Result` AS `tgt`
                                   FROM `Result`
                                   WHERE `Result` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'resultCmpStatIsYellow' =>
        array ( 'name'          => 'resultCmpStatIsYellow'
              , 'ruleAdl'       => 'I[Result] /\\ actResult~;(I[Activity] /\\ -(actEndTime;actEndTime~));actResult |- resultCmpStat;\'Yellow\'[Status];resultCmpStat~'
              , 'origin'        => 'line 344:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Result'
              // Normalization steps:
              //     -(I[Result] /\\ actResult~;(I[Activity] /\\ -(actEndTime;actEndTime~));actResult |- resultCmpStat;\'Yellow\'[Status];resultCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Result] /\\ actResult~;(I[Activity] /\\ -(actEndTime;actEndTime~));actResult) \\/ resultCmpStat;\'Yellow\'[Status];resultCmpStat~)
              // <=> { De Morgan }
              //     I[Result] /\\ actResult~;(I[Activity] /\\ -(actEndTime;actEndTime~));actResult /\\ -(resultCmpStat;\'Yellow\'[Status];resultCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Result
              //      ,EIsc (ECps (EFlp (EDcD rel_actResultActivityResult)
              //                  ,ECps (EIsc (EDcI cpt_Activity
              //                              ,ECpl (ECps (EDcD rel_actEndTimeActivityTimestamp
              //                                          ,EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //                                          ))
              //                              )
              //                        ,EDcD rel_actResultActivityResult
              //                        )
              //                  )
              //            ,ECpl (ECps (EDcD rel_resultCmpStatResultStatus
              //                        ,ECps (EMp1 "Yellow" cpt_Status
              //                              ,EFlp (EDcD rel_resultCmpStatResultStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Result] /\\\\ actResult~;(I[Activity] /\\\\ -(actEndTime;actEndTime~));actResult /\\\\ -(resultCmpStat;\\\'Yellow\\\'[Status];resultCmpStat~) ([Result*Result]) */
                          SELECT DISTINCT isect0.`SrcResult` AS `src`, isect0.`TgtResult` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actResult~;(I[Activity] /\\\\ -(actEndTime;actEndTime~));actResult */
                                 
                                 SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps2.`actResult` AS `TgtResult`
                                 FROM `Activity` AS ECps0,
                                      
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           I[Activity] /\\\\ -(actEndTime;actEndTime~) ([Activity*Activity]) */
                                        SELECT DISTINCT isect0.`Activity` AS `SrcActivity`, isect0.`Activity` AS `TgtActivity`
                                        FROM ( /* Case EDcI Activity */
                                               SELECT `Activity` AS `Activity`
                                               FROM `Activity` ) AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               actEndTime;actEndTime~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                            FROM `Activity` AS ECps0,
                                                                 `Activity` AS ECps1
                                                            WHERE ECps0.`actEndTime`=ECps1.`actEndTime`
                                                          ) AS cp
                                                          WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL
                                      ) AS ECps1,
                                      `Activity` AS ECps2
                                 WHERE ECps0.`Activity`=ECps1.`SrcActivity`
                                   AND ECps1.`TgtActivity`=ECps2.`Activity`
                               ) AS isect0, 
                               ( /* Case EDcI Result */
                                 SELECT `Result` AS `Result`
                                 FROM `Result` ) AS isect1
                          WHERE isect0.`SrcResult` = isect0.`TgtResult` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 resultCmpStat;\\\'Yellow\\\'[Status];resultCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps2.`Result` AS `TgtResult`
                                              FROM `Result` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Result` AS ECps2
                                              WHERE ECps0.`resultCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`resultCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcResult`=cp.`SrcResult` AND isect0.`TgtResult`=cp.`TgtResult`) AND isect0.`SrcResult` IS NOT NULL AND isect0.`TgtResult` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;resultCmpStat;Result;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Result'
                            , 'expSQL' =>
                                '/* I[Result] */
                                   SELECT `Result` AS `src`, `Result` AS `tgt`
                                   FROM `Result`
                                   WHERE `Result` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'resultCmpStatIsGreen' =>
        array ( 'name'          => 'resultCmpStatIsGreen'
              , 'ruleAdl'       => 'I[Result] /\\ (actResult~;actEndTime);(actResult~;actEndTime)~ |- resultCmpStat;\'Green\'[Status];resultCmpStat~'
              , 'origin'        => 'line 348:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Result'
              // Normalization steps:
              //     -(I[Result] /\\ actResult~;actEndTime;(actResult~;actEndTime)~ |- resultCmpStat;\'Green\'[Status];resultCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Result] /\\ actResult~;actEndTime;(actResult~;actEndTime)~) \\/ resultCmpStat;\'Green\'[Status];resultCmpStat~)
              // <=> { De Morgan }
              //     I[Result] /\\ actResult~;actEndTime;(actResult~;actEndTime)~ /\\ -(resultCmpStat;\'Green\'[Status];resultCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Result
              //      ,EIsc (ECps (EFlp (EDcD rel_actResultActivityResult)
              //                  ,ECps (EDcD rel_actEndTimeActivityTimestamp
              //                        ,EFlp (EBrk (ECps (EFlp (EDcD rel_actResultActivityResult)
              //                                          ,EDcD rel_actEndTimeActivityTimestamp
              //                                          )))
              //                        )
              //                  )
              //            ,ECpl (ECps (EDcD rel_resultCmpStatResultStatus
              //                        ,ECps (EMp1 "Green" cpt_Status
              //                              ,EFlp (EDcD rel_resultCmpStatResultStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Result] /\\\\ actResult~;actEndTime;(actResult~;actEndTime)~ /\\\\ -(resultCmpStat;\\\'Green\\\'[Status];resultCmpStat~) ([Result*Result]) */
                          SELECT DISTINCT isect0.`SrcResult` AS `src`, isect0.`TgtResult` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actResult~;actEndTime;(actResult~;actEndTime)~ */
                                 
                                 SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps2.`SrcResult` AS `TgtResult`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1,
                                      
                                      ( /* case: (ECps es), with two or more elements in es.
                                           actResult~;actEndTime */
                                        
                                        SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps1.`actEndTime` AS `TgtTimestamp`
                                        FROM `Activity` AS ECps0,
                                             `Activity` AS ECps1
                                        WHERE ECps0.`Activity`=ECps1.`Activity`
                                      ) AS ECps2
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                                   AND ECps1.`actEndTime`=ECps2.`TgtTimestamp`
                               ) AS isect0, 
                               ( /* Case EDcI Result */
                                 SELECT `Result` AS `Result`
                                 FROM `Result` ) AS isect1
                          WHERE isect0.`SrcResult` = isect0.`TgtResult` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 resultCmpStat;\\\'Green\\\'[Status];resultCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps2.`Result` AS `TgtResult`
                                              FROM `Result` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Result` AS ECps2
                                              WHERE ECps0.`resultCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`resultCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcResult`=cp.`SrcResult` AND isect0.`TgtResult`=cp.`TgtResult`) AND isect0.`SrcResult` IS NOT NULL AND isect0.`TgtResult` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;resultCmpStat;Result;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Result'
                            , 'expSQL' =>
                                '/* I[Result] */
                                   SELECT `Result` AS `src`, `Result` AS `tgt`
                                   FROM `Result`
                                   WHERE `Result` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'InsResultStatus' =>
        array ( 'name'          => 'InsResultStatus'
              , 'ruleAdl'       => 'resultMnlStat \\/ (I[Result] /\\ -(resultMnlStat;resultMnlStat~));resultCmpStat |- resultStatus'
              , 'origin'        => 'line 353:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(resultMnlStat \\/ (I[Result] /\\ -(resultMnlStat;resultMnlStat~));resultCmpStat |- resultStatus)
              // <=> { remove |- }
              //     -(-(resultMnlStat \\/ (I[Result] /\\ -(resultMnlStat;resultMnlStat~));resultCmpStat) \\/ resultStatus)
              // <=> { De Morgan }
              //     -(-resultMnlStat /\\ -((I[Result] /\\ -(resultMnlStat;resultMnlStat~));resultCmpStat)) /\\ -resultStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_resultMnlStatResultStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_Result
              //                                    ,ECpl (ECps (EDcD rel_resultMnlStatResultStatus
              //                                                ,EFlp (EDcD rel_resultMnlStatResultStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_resultCmpStatResultStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_resultStatusResultStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-resultMnlStat /\\\\ -((I[Result] /\\\\ -(resultMnlStat;resultMnlStat~));resultCmpStat)) /\\\\ -resultStatus ([Result*Status]) */
                          SELECT DISTINCT isect0.`SrcResult` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-resultMnlStat /\\\\ -((I[Result] /\\\\ -(resultMnlStat;resultMnlStat~));resultCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`Result` AS `SrcResult`, csnd.`Status` AS `TgtStatus`
                                 FROM `Result` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -resultMnlStat /\\\\ -((I[Result] /\\\\ -(resultMnlStat;resultMnlStat~));resultCmpStat) ([Result*Status]) */
                                          SELECT DISTINCT isect0.`SrcResult`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"resultMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`Result` AS `SrcResult`, csnd.`Status` AS `TgtStatus`
                                                 FROM `Result` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Result` AS cp
                                                   WHERE cfst.`Result`=cp.`Result` AND csnd.`Status`=cp.`resultMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[Result] /\\\\ -(resultMnlStat;resultMnlStat~));resultCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcResult`, ECps1.`resultCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Result] /\\\\ -(resultMnlStat;resultMnlStat~) ([Result*Result]) */
                                                                     SELECT DISTINCT isect0.`Result` AS `SrcResult`, isect0.`Result` AS `TgtResult`
                                                                     FROM ( /* Case EDcI Result */
                                                                            SELECT `Result` AS `Result`
                                                                            FROM `Result` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            resultMnlStat;resultMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps1.`Result` AS `TgtResult`
                                                                                         FROM `Result` AS ECps0,
                                                                                              `Result` AS ECps1
                                                                                         WHERE ECps0.`resultMnlStat`=ECps1.`resultMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Result`=cp.`SrcResult` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Result` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `Result` AS ECps1
                                                              WHERE ECps0.`TgtResult`=ECps1.`Result`
                                                            ) AS cp
                                                            WHERE isect0.`SrcResult`=cp.`SrcResult` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcResult` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Result`=cp.`SrcResult` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Result` AS cp
                                            WHERE isect0.`SrcResult`=cp.`Result` AND isect0.`TgtStatus`=cp.`resultStatus`) AND isect0.`SrcResult` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;resultStatus;Result;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Result'
                            , 'expSQL' =>
                                '/* I[Result] */
                                   SELECT `Result` AS `src`, `Result` AS `tgt`
                                   FROM `Result`
                                   WHERE `Result` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultResultStatus' =>
        array ( 'name'          => 'defaultResultStatus'
              , 'ruleAdl'       => 'I[Result] |- resultStatus;resultStatus~'
              , 'origin'        => 'line 356:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Result'
              // Normalization steps:
              //     -(I[Result] |- resultStatus;resultStatus~)
              // <=> { remove |- }
              //     -(-I[Result] \\/ resultStatus;resultStatus~)
              // <=> { De Morgan }
              //     I[Result] /\\ -(resultStatus;resultStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Result
              //      ,ECpl (ECps (EDcD rel_resultStatusResultStatus
              //                  ,EFlp (EDcD rel_resultStatusResultStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Result] /\\\\ -(resultStatus;resultStatus~) ([Result*Result]) */
                          SELECT DISTINCT isect0.`Result` AS `src`, isect0.`Result` AS `tgt`
                          FROM ( /* Case EDcI Result */
                                 SELECT `Result` AS `Result`
                                 FROM `Result` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 resultStatus;resultStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps1.`Result` AS `TgtResult`
                                              FROM `Result` AS ECps0,
                                                   `Result` AS ECps1
                                              WHERE ECps0.`resultStatus`=ECps1.`resultStatus`
                                            ) AS cp
                                            WHERE isect0.`Result`=cp.`SrcResult` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Result` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;resultStatus;Result;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Result'
                            , 'expSQL' =>
                                '/* I[Result] */
                                   SELECT `Result` AS `src`, `Result` AS `tgt`
                                   FROM `Result`
                                   WHERE `Result` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'instaskCmpStatIsRed' =>
        array ( 'name'          => 'instaskCmpStatIsRed'
              , 'ruleAdl'       => 'I[Task] /\\ (-(taskPurpose;taskPurpose~) \\/ -(taskOU;taskOU~)) |- taskCmpStatIsRed'
              , 'origin'        => 'line 374:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(I[Task] /\\ (-(taskPurpose;taskPurpose~) \\/ -(taskOU;taskOU~)) |- taskCmpStatIsRed)
              // <=> { remove |- }
              //     -(-(I[Task] /\\ (-(taskPurpose;taskPurpose~) \\/ -(taskOU;taskOU~))) \\/ taskCmpStatIsRed)
              // <=> { De Morgan }
              //     I[Task] /\\ (-(taskPurpose;taskPurpose~) \\/ -(taskOU;taskOU~)) /\\ -taskCmpStatIsRed
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Task
              //      ,EIsc (EUni (ECpl (ECps (EDcD rel_taskPurposeTaskPurpose
              //                              ,EFlp (EDcD rel_taskPurposeTaskPurpose)
              //                              ))
              //                  ,ECpl (ECps (EDcD rel_taskOUTaskOrgUnit
              //                              ,EFlp (EDcD rel_taskOUTaskOrgUnit)
              //                              ))
              //                  )
              //            ,ECpl (EDcD rel_taskCmpStatIsRedTaskTask)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Task] /\\\\ (-(taskPurpose;taskPurpose~) \\\\/ -(taskOU;taskOU~)) /\\\\ -taskCmpStatIsRed ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: EUni (l,r)
                                    -(taskPurpose;taskPurpose~) \\\\/ -(taskOU;taskOU~) ([Task*Task]) */
                                 (/* case: ECpl e
                                        ECpl ( \\"taskPurpose;taskPurpose~\\" ) */
                                     SELECT DISTINCT cfst.`Task` AS `SrcTask`, csnd.`Task` AS `TgtTask`
                                     FROM `Task` AS cfst,
                                          `Task` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 taskPurpose;taskPurpose~ */
                                              
                                              SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                              FROM `taskPurpose` AS ECps0,
                                                   `taskPurpose` AS ECps1
                                              WHERE ECps0.`Purpose`=ECps1.`Purpose`
                                            ) AS cp
                                       WHERE cfst.`Task`=cp.`SrcTask` AND csnd.`Task`=cp.`TgtTask`)
                                 ) UNION (/* case: ECpl e
                                        ECpl ( \\"taskOU;taskOU~\\" ) */
                                     SELECT DISTINCT cfst.`Task` AS `SrcTask`, csnd.`Task` AS `TgtTask`
                                     FROM `Task` AS cfst,
                                          `Task` AS csnd
                                     WHERE NOT EXISTS
                                      (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 taskOU;taskOU~ */
                                              
                                              SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                              FROM `Task` AS ECps0,
                                                   `Task` AS ECps1
                                              WHERE ECps0.`taskOU`=ECps1.`taskOU`
                                            ) AS cp
                                       WHERE cfst.`Task`=cp.`SrcTask` AND csnd.`Task`=cp.`TgtTask`)
                                 )
                               ) AS isect0, 
                               ( /* Case EDcI Task */
                                 SELECT `Task` AS `Task`
                                 FROM `Task` ) AS isect1
                          WHERE isect0.`SrcTask` = isect0.`TgtTask` AND NOT EXISTS (SELECT * FROM `Task` AS cp
                                            WHERE isect0.`SrcTask`=cp.Task AND isect0.`TgtTask`=cp.`taskCmpStatIsRed`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskCmpStatIsRed;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskCmpStat;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'deltaskCmpStatIsRed' =>
        array ( 'name'          => 'deltaskCmpStatIsRed'
              , 'ruleAdl'       => 'taskCmpStatIsRed |- I[Task] /\\ -(taskPurpose;taskPurpose~ /\\ taskOU;taskOU~)'
              , 'origin'        => 'line 381:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsRed |- I[Task] /\\ -(taskPurpose;taskPurpose~ /\\ taskOU;taskOU~))
              // <=> { remove |- }
              //     -(-taskCmpStatIsRed \\/ (I[Task] /\\ -(taskPurpose;taskPurpose~ /\\ taskOU;taskOU~)))
              // <=> { De Morgan }
              //     taskCmpStatIsRed /\\ -(I[Task] /\\ -(taskPurpose;taskPurpose~ /\\ taskOU;taskOU~))
              // <=> { De Morgan }
              //     taskCmpStatIsRed /\\ -(I[Task] /\\ (-(taskPurpose;taskPurpose~) \\/ -(taskOU;taskOU~)))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_taskCmpStatIsRedTaskTask
              //      ,ECpl (EIsc (EDcI cpt_Task
              //                  ,EUni (ECpl (ECps (EDcD rel_taskPurposeTaskPurpose
              //                                    ,EFlp (EDcD rel_taskPurposeTaskPurpose)
              //                                    ))
              //                        ,ECpl (ECps (EDcD rel_taskOUTaskOrgUnit
              //                                    ,EFlp (EDcD rel_taskOUTaskOrgUnit)
              //                                    ))
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsRed /\\\\ -(I[Task] /\\\\ (-(taskPurpose;taskPurpose~) \\\\/ -(taskOU;taskOU~))) ([Task*Task]) */
                          SELECT DISTINCT isect0.`Task` AS `src`, isect0.`taskCmpStatIsRed` AS `tgt`
                          FROM `Task` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Task] /\\\\ (-(taskPurpose;taskPurpose~) \\\\/ -(taskOU;taskOU~)) ([Task*Task]) */
                                              SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                              FROM 
                                                   ( /* case: EUni (l,r)
                                                        -(taskPurpose;taskPurpose~) \\\\/ -(taskOU;taskOU~) ([Task*Task]) */
                                                     (/* case: ECpl e
                                                            ECpl ( \\"taskPurpose;taskPurpose~\\" ) */
                                                         SELECT DISTINCT cfst.`Task` AS `SrcTask`, csnd.`Task` AS `TgtTask`
                                                         FROM `Task` AS cfst,
                                                              `Task` AS csnd
                                                         WHERE NOT EXISTS
                                                          (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     taskPurpose;taskPurpose~ */
                                                                  
                                                                  SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                  FROM `taskPurpose` AS ECps0,
                                                                       `taskPurpose` AS ECps1
                                                                  WHERE ECps0.`Purpose`=ECps1.`Purpose`
                                                                ) AS cp
                                                           WHERE cfst.`Task`=cp.`SrcTask` AND csnd.`Task`=cp.`TgtTask`)
                                                     ) UNION (/* case: ECpl e
                                                            ECpl ( \\"taskOU;taskOU~\\" ) */
                                                         SELECT DISTINCT cfst.`Task` AS `SrcTask`, csnd.`Task` AS `TgtTask`
                                                         FROM `Task` AS cfst,
                                                              `Task` AS csnd
                                                         WHERE NOT EXISTS
                                                          (SELECT * FROM 
                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                     taskOU;taskOU~ */
                                                                  
                                                                  SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                  FROM `Task` AS ECps0,
                                                                       `Task` AS ECps1
                                                                  WHERE ECps0.`taskOU`=ECps1.`taskOU`
                                                                ) AS cp
                                                           WHERE cfst.`Task`=cp.`SrcTask` AND csnd.`Task`=cp.`TgtTask`)
                                                     )
                                                   ) AS isect0, 
                                                   ( /* Case EDcI Task */
                                                     SELECT `Task` AS `Task`
                                                     FROM `Task` ) AS isect1
                                              WHERE isect0.`SrcTask` = isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Task=cp.`SrcTask` AND isect0.`taskCmpStatIsRed`=cp.`TgtTask`) AND isect0.Task IS NOT NULL AND isect0.`taskCmpStatIsRed` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;taskCmpStatIsRed;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    )
              )
    , 'instaskCmpStatIsGreen' =>
        array ( 'name'          => 'instaskCmpStatIsGreen'
              , 'ruleAdl'       => 'I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf) |- taskCmpStatIsGreen'
              , 'origin'        => 'line 388:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf) |- taskCmpStatIsGreen)
              // <=> { remove |- }
              //     -(-(I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf)) \\/ taskCmpStatIsGreen)
              // <=> { De Morgan }
              //     I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf) /\\ -taskCmpStatIsGreen
              // <=> { distribute ! over /\\ and distribute ! over /\\ and -l!r = l~ }
              //     I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!I[Task] /\\ -isSubtaskOf~!(taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!I[Activity] /\\ -actTask~!(actEndTime;actEndTime~));actTask /\\ taskExpectsResult~ \\ (actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf) /\\ -taskCmpStatIsGreen
              // <=> { -l~!r = l and -l~!r = l and -l~!r = l and -l~!r = l }
              //     I[Task] /\\ -taskCmpStatIsRed /\\ (isSubtaskOf \\ I[Task] /\\ isSubtaskOf \\ taskEndTime;taskEndTime~);isSubtaskOf /\\ (actTask \\ I[Activity] /\\ actTask \\ actEndTime;actEndTime~);actTask /\\ taskExpectsResult~ \\ (actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf) /\\ -taskCmpStatIsGreen
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Task
              //      ,EIsc (ECpl (EDcD rel_taskCmpStatIsRedTaskTask)
              //            ,EIsc (ECps (EIsc (ERrs (EDcD rel_isSubtaskOfTaskTask
              //                                    ,EDcI cpt_Task
              //                                    )
              //                              ,ERrs (EDcD rel_isSubtaskOfTaskTask
              //                                    ,ECps (EDcD rel_taskEndTimeTaskTimestamp
              //                                          ,EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //                                          )
              //                                    )
              //                              )
              //                        ,EDcD rel_isSubtaskOfTaskTask
              //                        )
              //                  ,EIsc (ECps (EIsc (ERrs (EDcD rel_actTaskActivityTask
              //                                          ,EDcI cpt_Activity
              //                                          )
              //                                    ,ERrs (EDcD rel_actTaskActivityTask
              //                                          ,ECps (EDcD rel_actEndTimeActivityTimestamp
              //                                                ,EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //                                                )
              //                                          )
              //                                    )
              //                              ,EDcD rel_actTaskActivityTask
              //                              )
              //                        ,EIsc (ERrs (EFlp (EDcD rel_taskExpectsResultTaskResult)
              //                                    ,EUni (ECps (EFlp (EDcD rel_actResultActivityResult)
              //                                                ,EDcD rel_actTaskActivityTask
              //                                                )
              //                                          ,ECps (EFlp (EDcD rel_taskExpectsResultTaskResult)
              //                                                ,EDcD rel_isSubtaskOfTaskTask
              //                                                )
              //                                          )
              //                                    )
              //                              ,ECpl (EDcD rel_taskCmpStatIsGreenTaskTask)
              //                              )
              //                        )
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Task] /\\\\ -taskCmpStatIsRed /\\\\ (isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~);isSubtaskOf /\\\\ (actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~);actTask /\\\\ taskExpectsResult~ \\\\ (actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf) /\\\\ -taskCmpStatIsGreen ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    (isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~);isSubtaskOf */
                                 
                                 SELECT DISTINCT ECps0.`SrcTask`, ECps1.`TgtTask`
                                 FROM 
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                        SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                        FROM 
                                             ( /* case: ERrs (l,r)
                                                  isSubtaskOf \\\\ I[Task] ([Task*Task]) */
                                               SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                               FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                               WHERE NOT EXISTS
                                                     ( SELECT *
                                                       FROM `isSubtaskOf` AS lhs
                                                       WHERE `RResLeft`.`Task`=lhs.`TgtTask` AND
                                                             NOT EXISTS
                                                             ( SELECT *
                                                               FROM ( /* Case EDcI Task */
                                                                           SELECT `Task` AS `Task`
                                                                           FROM `Task` ) AS rhs
                                                               WHERE rhs.`Task`=lhs.`SrcTask` AND rhs.`Task1`=`RResRight`.`Task`
                                                             )
                                                     )
                                             ) AS isect0, 
                                             
                                             ( /* case: ERrs (l,r)
                                                  isSubtaskOf \\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                               SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                               FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                               WHERE NOT EXISTS
                                                     ( SELECT *
                                                       FROM `isSubtaskOf` AS lhs
                                                       WHERE `RResLeft`.`Task`=lhs.`TgtTask` AND
                                                             NOT EXISTS
                                                             ( SELECT *
                                                               FROM 
                                                                         ( /* case: (ECps es), with two or more elements in es.
                                                                              taskEndTime;taskEndTime~ */
                                                                           
                                                                           SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                           FROM `Task` AS ECps0,
                                                                                `Task` AS ECps1
                                                                           WHERE ECps0.`taskEndTime`=ECps1.`taskEndTime`
                                                                         ) AS rhs
                                                               WHERE rhs.`SrcTask`=lhs.`SrcTask` AND rhs.`TgtTask`=`RResRight`.`Task`
                                                             )
                                                     )
                                             ) AS isect1
                                        WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtTask` = isect1.`TgtTask`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                      ) AS ECps0,
                                      `isSubtaskOf` AS ECps1
                                 WHERE ECps0.`TgtTask`=ECps1.`SrcTask`
                               ) AS isect0, 
                               
                               ( /* case: (ECps es), with two or more elements in es.
                                    (actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~);actTask */
                                 
                                 SELECT DISTINCT ECps0.`SrcTask`, ECps1.`actTask` AS `TgtTask`
                                 FROM 
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~ ([Task*Activity]) */
                                        SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtActivity`
                                        FROM 
                                             ( /* case: ERrs (l,r)
                                                  actTask \\\\ I[Activity] ([Task*Activity]) */
                                               SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Activity` AS `TgtActivity`
                                               FROM `Task` AS `RResLeft`, `Activity` AS `RResRight`
                                               WHERE NOT EXISTS
                                                     ( SELECT *
                                                       FROM `Activity` AS lhs
                                                       WHERE `RResLeft`.`Task`=lhs.`actTask` AND
                                                             NOT EXISTS
                                                             ( SELECT *
                                                               FROM ( /* Case EDcI Activity */
                                                                           SELECT `Activity` AS `Activity`
                                                                           FROM `Activity` ) AS rhs
                                                               WHERE rhs.`Activity`=lhs.`Activity` AND rhs.`Activity1`=`RResRight`.`Activity`
                                                             )
                                                     )
                                             ) AS isect0, 
                                             
                                             ( /* case: ERrs (l,r)
                                                  actTask \\\\ actEndTime;actEndTime~ ([Task*Activity]) */
                                               SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Activity` AS `TgtActivity`
                                               FROM `Task` AS `RResLeft`, `Activity` AS `RResRight`
                                               WHERE NOT EXISTS
                                                     ( SELECT *
                                                       FROM `Activity` AS lhs
                                                       WHERE `RResLeft`.`Task`=lhs.`actTask` AND
                                                             NOT EXISTS
                                                             ( SELECT *
                                                               FROM 
                                                                         ( /* case: (ECps es), with two or more elements in es.
                                                                              actEndTime;actEndTime~ */
                                                                           
                                                                           SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                                           FROM `Activity` AS ECps0,
                                                                                `Activity` AS ECps1
                                                                           WHERE ECps0.`actEndTime`=ECps1.`actEndTime`
                                                                         ) AS rhs
                                                               WHERE rhs.`SrcActivity`=lhs.`Activity` AND rhs.`TgtActivity`=`RResRight`.`Activity`
                                                             )
                                                     )
                                             ) AS isect1
                                        WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtActivity` = isect1.`TgtActivity`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL
                                      ) AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`TgtActivity`=ECps1.`Activity`
                               ) AS isect1, 
                               
                               ( /* case: ERrs (l,r)
                                    taskExpectsResult~ \\\\ (actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf) ([Task*Task]) */
                                 SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                 FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM `taskExpectsResult` AS lhs
                                         WHERE `RResLeft`.`Task`=lhs.`Task` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: EUni (l,r)
                                                                actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf ([Result*Task]) */
                                                             (/* case: (ECps es), with two or more elements in es.
                                                                    actResult~;actTask */
                                                                 
                                                                 SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps1.`actTask` AS `TgtTask`
                                                                 FROM `Activity` AS ECps0,
                                                                      `Activity` AS ECps1
                                                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                                                             ) UNION (/* case: (ECps es), with two or more elements in es.
                                                                    taskExpectsResult~;isSubtaskOf */
                                                                 
                                                                 SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps1.`TgtTask`
                                                                 FROM `taskExpectsResult` AS ECps0,
                                                                      `isSubtaskOf` AS ECps1
                                                                 WHERE ECps0.`Task`=ECps1.`SrcTask`
                                                             )
                                                           ) AS rhs
                                                 WHERE rhs.`SrcResult`=lhs.`Result` AND rhs.`TgtTask`=`RResRight`.`Task`
                                               )
                                       )
                               ) AS isect2, 
                               ( /* Case EDcI Task */
                                 SELECT `Task` AS `Task`
                                 FROM `Task` ) AS isect3
                          WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtTask` = isect1.`TgtTask`) AND (isect0.`SrcTask` = isect2.`SrcTask` AND isect0.`TgtTask` = isect2.`TgtTask`) AND isect0.`SrcTask` = isect0.`TgtTask` AND NOT EXISTS (SELECT * FROM `Task` AS cp
                                            WHERE isect0.`SrcTask`=cp.Task AND isect0.`TgtTask`=cp.`taskCmpStatIsRed`) AND NOT EXISTS (SELECT * FROM `Task` AS cp
                                            WHERE isect0.`SrcTask`=cp.Task AND isect0.`TgtTask`=cp.`taskCmpStatIsGreen`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskCmpStatIsGreen;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskCmpStat;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'deltaskCmpStatIsGreen' =>
        array ( 'name'          => 'deltaskCmpStatIsGreen'
              , 'ruleAdl'       => 'taskCmpStatIsGreen |- I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf)'
              , 'origin'        => 'line 399:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsGreen |- I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf))
              // <=> { remove |- }
              //     -(-taskCmpStatIsGreen \\/ (I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf)))
              // <=> { De Morgan }
              //     taskCmpStatIsGreen /\\ -(I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!(I[Task] /\\ taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!(I[Activity] /\\ actEndTime;actEndTime~));actTask /\\ -taskExpectsResult!(actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf))
              // <=> { distribute ! over /\\ and distribute ! over /\\ and -l!r = l~ }
              //     taskCmpStatIsGreen /\\ -(I[Task] /\\ -taskCmpStatIsRed /\\ (-isSubtaskOf~!I[Task] /\\ -isSubtaskOf~!(taskEndTime;taskEndTime~));isSubtaskOf /\\ (-actTask~!I[Activity] /\\ -actTask~!(actEndTime;actEndTime~));actTask /\\ taskExpectsResult~ \\ (actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf))
              // <=> { -l~!r = l and -l~!r = l and -l~!r = l and -l~!r = l }
              //     taskCmpStatIsGreen /\\ -(I[Task] /\\ -taskCmpStatIsRed /\\ (isSubtaskOf \\ I[Task] /\\ isSubtaskOf \\ taskEndTime;taskEndTime~);isSubtaskOf /\\ (actTask \\ I[Activity] /\\ actTask \\ actEndTime;actEndTime~);actTask /\\ taskExpectsResult~ \\ (actResult~;actTask \\/ taskExpectsResult~;isSubtaskOf))
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_taskCmpStatIsGreenTaskTask
              //      ,ECpl (EIsc (EDcI cpt_Task
              //                  ,EIsc (ECpl (EDcD rel_taskCmpStatIsRedTaskTask)
              //                        ,EIsc (ECps (EIsc (ERrs (EDcD rel_isSubtaskOfTaskTask
              //                                                ,EDcI cpt_Task
              //                                                )
              //                                          ,ERrs (EDcD rel_isSubtaskOfTaskTask
              //                                                ,ECps (EDcD rel_taskEndTimeTaskTimestamp
              //                                                      ,EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //                                                      )
              //                                                )
              //                                          )
              //                                    ,EDcD rel_isSubtaskOfTaskTask
              //                                    )
              //                              ,EIsc (ECps (EIsc (ERrs (EDcD rel_actTaskActivityTask
              //                                                      ,EDcI cpt_Activity
              //                                                      )
              //                                                ,ERrs (EDcD rel_actTaskActivityTask
              //                                                      ,ECps (EDcD rel_actEndTimeActivityTimestamp
              //                                                            ,EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //                                                            )
              //                                                      )
              //                                                )
              //                                          ,EDcD rel_actTaskActivityTask
              //                                          )
              //                                    ,ERrs (EFlp (EDcD rel_taskExpectsResultTaskResult)
              //                                          ,EUni (ECps (EFlp (EDcD rel_actResultActivityResult)
              //                                                      ,EDcD rel_actTaskActivityTask
              //                                                      )
              //                                                ,ECps (EFlp (EDcD rel_taskExpectsResultTaskResult)
              //                                                      ,EDcD rel_isSubtaskOfTaskTask
              //                                                      )
              //                                                )
              //                                          )
              //                                    )
              //                              )
              //                        )
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsGreen /\\\\ -(I[Task] /\\\\ -taskCmpStatIsRed /\\\\ (isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~);isSubtaskOf /\\\\ (actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~);actTask /\\\\ taskExpectsResult~ \\\\ (actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf)) ([Task*Task]) */
                          SELECT DISTINCT isect0.`Task` AS `src`, isect0.`taskCmpStatIsGreen` AS `tgt`
                          FROM `Task` AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (EIsc lst\\\'@(_:_:_))
                                                 I[Task] /\\\\ -taskCmpStatIsRed /\\\\ (isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~);isSubtaskOf /\\\\ (actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~);actTask /\\\\ taskExpectsResult~ \\\\ (actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf) ([Task*Task]) */
                                              SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                              FROM 
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        (isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~);isSubtaskOf */
                                                     
                                                     SELECT DISTINCT ECps0.`SrcTask`, ECps1.`TgtTask`
                                                     FROM 
                                                          ( /* case: (EIsc lst\\\'@(_:_:_))
                                                               isSubtaskOf \\\\ I[Task] /\\\\ isSubtaskOf \\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                                            SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                                            FROM 
                                                                 ( /* case: ERrs (l,r)
                                                                      isSubtaskOf \\\\ I[Task] ([Task*Task]) */
                                                                   SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                                                   FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                                                   WHERE NOT EXISTS
                                                                         ( SELECT *
                                                                           FROM `isSubtaskOf` AS lhs
                                                                           WHERE `RResLeft`.`Task`=lhs.`TgtTask` AND
                                                                                 NOT EXISTS
                                                                                 ( SELECT *
                                                                                   FROM ( /* Case EDcI Task */
                                                                                               SELECT `Task` AS `Task`
                                                                                               FROM `Task` ) AS rhs
                                                                                   WHERE rhs.`Task`=lhs.`SrcTask` AND rhs.`Task1`=`RResRight`.`Task`
                                                                                 )
                                                                         )
                                                                 ) AS isect0, 
                                                                 
                                                                 ( /* case: ERrs (l,r)
                                                                      isSubtaskOf \\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                                                   SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                                                   FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                                                   WHERE NOT EXISTS
                                                                         ( SELECT *
                                                                           FROM `isSubtaskOf` AS lhs
                                                                           WHERE `RResLeft`.`Task`=lhs.`TgtTask` AND
                                                                                 NOT EXISTS
                                                                                 ( SELECT *
                                                                                   FROM 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  taskEndTime;taskEndTime~ */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                                               FROM `Task` AS ECps0,
                                                                                                    `Task` AS ECps1
                                                                                               WHERE ECps0.`taskEndTime`=ECps1.`taskEndTime`
                                                                                             ) AS rhs
                                                                                   WHERE rhs.`SrcTask`=lhs.`SrcTask` AND rhs.`TgtTask`=`RResRight`.`Task`
                                                                                 )
                                                                         )
                                                                 ) AS isect1
                                                            WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtTask` = isect1.`TgtTask`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                                          ) AS ECps0,
                                                          `isSubtaskOf` AS ECps1
                                                     WHERE ECps0.`TgtTask`=ECps1.`SrcTask`
                                                   ) AS isect0, 
                                                   
                                                   ( /* case: (ECps es), with two or more elements in es.
                                                        (actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~);actTask */
                                                     
                                                     SELECT DISTINCT ECps0.`SrcTask`, ECps1.`actTask` AS `TgtTask`
                                                     FROM 
                                                          ( /* case: (EIsc lst\\\'@(_:_:_))
                                                               actTask \\\\ I[Activity] /\\\\ actTask \\\\ actEndTime;actEndTime~ ([Task*Activity]) */
                                                            SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtActivity`
                                                            FROM 
                                                                 ( /* case: ERrs (l,r)
                                                                      actTask \\\\ I[Activity] ([Task*Activity]) */
                                                                   SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Activity` AS `TgtActivity`
                                                                   FROM `Task` AS `RResLeft`, `Activity` AS `RResRight`
                                                                   WHERE NOT EXISTS
                                                                         ( SELECT *
                                                                           FROM `Activity` AS lhs
                                                                           WHERE `RResLeft`.`Task`=lhs.`actTask` AND
                                                                                 NOT EXISTS
                                                                                 ( SELECT *
                                                                                   FROM ( /* Case EDcI Activity */
                                                                                               SELECT `Activity` AS `Activity`
                                                                                               FROM `Activity` ) AS rhs
                                                                                   WHERE rhs.`Activity`=lhs.`Activity` AND rhs.`Activity1`=`RResRight`.`Activity`
                                                                                 )
                                                                         )
                                                                 ) AS isect0, 
                                                                 
                                                                 ( /* case: ERrs (l,r)
                                                                      actTask \\\\ actEndTime;actEndTime~ ([Task*Activity]) */
                                                                   SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Activity` AS `TgtActivity`
                                                                   FROM `Task` AS `RResLeft`, `Activity` AS `RResRight`
                                                                   WHERE NOT EXISTS
                                                                         ( SELECT *
                                                                           FROM `Activity` AS lhs
                                                                           WHERE `RResLeft`.`Task`=lhs.`actTask` AND
                                                                                 NOT EXISTS
                                                                                 ( SELECT *
                                                                                   FROM 
                                                                                             ( /* case: (ECps es), with two or more elements in es.
                                                                                                  actEndTime;actEndTime~ */
                                                                                               
                                                                                               SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                                                               FROM `Activity` AS ECps0,
                                                                                                    `Activity` AS ECps1
                                                                                               WHERE ECps0.`actEndTime`=ECps1.`actEndTime`
                                                                                             ) AS rhs
                                                                                   WHERE rhs.`SrcActivity`=lhs.`Activity` AND rhs.`TgtActivity`=`RResRight`.`Activity`
                                                                                 )
                                                                         )
                                                                 ) AS isect1
                                                            WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtActivity` = isect1.`TgtActivity`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL
                                                          ) AS ECps0,
                                                          `Activity` AS ECps1
                                                     WHERE ECps0.`TgtActivity`=ECps1.`Activity`
                                                   ) AS isect1, 
                                                   
                                                   ( /* case: ERrs (l,r)
                                                        taskExpectsResult~ \\\\ (actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf) ([Task*Task]) */
                                                     SELECT `RResLeft`.`Task` AS `SrcTask`, `RResRight`.`Task` AS `TgtTask`
                                                     FROM `Task` AS `RResLeft`, `Task` AS `RResRight`
                                                     WHERE NOT EXISTS
                                                           ( SELECT *
                                                             FROM `taskExpectsResult` AS lhs
                                                             WHERE `RResLeft`.`Task`=lhs.`Task` AND
                                                                   NOT EXISTS
                                                                   ( SELECT *
                                                                     FROM 
                                                                               ( /* case: EUni (l,r)
                                                                                    actResult~;actTask \\\\/ taskExpectsResult~;isSubtaskOf ([Result*Task]) */
                                                                                 (/* case: (ECps es), with two or more elements in es.
                                                                                        actResult~;actTask */
                                                                                     
                                                                                     SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps1.`actTask` AS `TgtTask`
                                                                                     FROM `Activity` AS ECps0,
                                                                                          `Activity` AS ECps1
                                                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                                 ) UNION (/* case: (ECps es), with two or more elements in es.
                                                                                        taskExpectsResult~;isSubtaskOf */
                                                                                     
                                                                                     SELECT DISTINCT ECps0.`Result` AS `SrcResult`, ECps1.`TgtTask`
                                                                                     FROM `taskExpectsResult` AS ECps0,
                                                                                          `isSubtaskOf` AS ECps1
                                                                                     WHERE ECps0.`Task`=ECps1.`SrcTask`
                                                                                 )
                                                                               ) AS rhs
                                                                     WHERE rhs.`SrcResult`=lhs.`Result` AND rhs.`TgtTask`=`RResRight`.`Task`
                                                                   )
                                                           )
                                                   ) AS isect2, 
                                                   ( /* Case EDcI Task */
                                                     SELECT `Task` AS `Task`
                                                     FROM `Task` ) AS isect3
                                              WHERE (isect0.`SrcTask` = isect1.`SrcTask` AND isect0.`TgtTask` = isect1.`TgtTask`) AND (isect0.`SrcTask` = isect2.`SrcTask` AND isect0.`TgtTask` = isect2.`TgtTask`) AND isect0.`SrcTask` = isect0.`TgtTask` AND NOT EXISTS (SELECT * FROM `Task` AS cp
                                                                WHERE isect0.`SrcTask`=cp.Task AND isect0.`TgtTask`=cp.`taskCmpStatIsRed`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                            ) AS cp
                                            WHERE isect0.Task=cp.`SrcTask` AND isect0.`taskCmpStatIsGreen`=cp.`TgtTask`) AND isect0.Task IS NOT NULL AND isect0.`taskCmpStatIsGreen` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} DelPair;taskCmpStatIsGreen;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    )
              )
    , 'taskCmpStatIsYellow' =>
        array ( 'name'          => 'taskCmpStatIsYellow'
              , 'ruleAdl'       => 'I[Task] /\\ -taskCmpStatIsGreen /\\ -taskCmpStatIsRed |- taskCmpStat;\'Yellow\'[Status];taskCmpStat~'
              , 'origin'        => 'line 409:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(I[Task] /\\ -taskCmpStatIsGreen /\\ -taskCmpStatIsRed |- taskCmpStat;\'Yellow\'[Status];taskCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Task] /\\ -taskCmpStatIsGreen /\\ -taskCmpStatIsRed) \\/ taskCmpStat;\'Yellow\'[Status];taskCmpStat~)
              // <=> { De Morgan }
              //     I[Task] /\\ -taskCmpStatIsGreen /\\ -taskCmpStatIsRed /\\ -(taskCmpStat;\'Yellow\'[Status];taskCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Task
              //      ,EIsc (ECpl (EDcD rel_taskCmpStatIsGreenTaskTask)
              //            ,EIsc (ECpl (EDcD rel_taskCmpStatIsRedTaskTask)
              //                  ,ECpl (ECps (EDcD rel_taskCmpStatTaskStatus
              //                              ,ECps (EMp1 "Yellow" cpt_Status
              //                                    ,EFlp (EDcD rel_taskCmpStatTaskStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Task] /\\\\ -taskCmpStatIsGreen /\\\\ -taskCmpStatIsRed /\\\\ -(taskCmpStat;\\\'Yellow\\\'[Status];taskCmpStat~) ([Task*Task]) */
                          SELECT DISTINCT isect0.`Task` AS `src`, isect0.`Task` AS `tgt`
                          FROM ( /* Case EDcI Task */
                                 SELECT `Task` AS `Task`
                                 FROM `Task` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Task` AS cp
                                            WHERE isect0.`Task`=cp.Task AND isect0.`Task`=cp.`taskCmpStatIsGreen`) AND NOT EXISTS (SELECT * FROM `Task` AS cp
                                            WHERE isect0.`Task`=cp.Task AND isect0.`Task`=cp.`taskCmpStatIsRed`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 taskCmpStat;\\\'Yellow\\\'[Status];taskCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps2.`Task` AS `TgtTask`
                                              FROM `Task` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Task` AS ECps2
                                              WHERE ECps0.`taskCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`taskCmpStat`
                                            ) AS cp
                                            WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Task`=cp.`TgtTask`) AND isect0.`Task` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskCmpStat;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'InsTaskStatus' =>
        array ( 'name'          => 'InsTaskStatus'
              , 'ruleAdl'       => 'taskMnlStat \\/ (I[Task] /\\ -(taskMnlStat;taskMnlStat~));taskCmpStat |- taskStatus'
              , 'origin'        => 'line 414:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(taskMnlStat \\/ (I[Task] /\\ -(taskMnlStat;taskMnlStat~));taskCmpStat |- taskStatus)
              // <=> { remove |- }
              //     -(-(taskMnlStat \\/ (I[Task] /\\ -(taskMnlStat;taskMnlStat~));taskCmpStat) \\/ taskStatus)
              // <=> { De Morgan }
              //     -(-taskMnlStat /\\ -((I[Task] /\\ -(taskMnlStat;taskMnlStat~));taskCmpStat)) /\\ -taskStatus
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_taskMnlStatTaskStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_Task
              //                                    ,ECpl (ECps (EDcD rel_taskMnlStatTaskStatus
              //                                                ,EFlp (EDcD rel_taskMnlStatTaskStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_taskCmpStatTaskStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_taskStatusTaskStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-taskMnlStat /\\\\ -((I[Task] /\\\\ -(taskMnlStat;taskMnlStat~));taskCmpStat)) /\\\\ -taskStatus ([Task*Status]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-taskMnlStat /\\\\ -((I[Task] /\\\\ -(taskMnlStat;taskMnlStat~));taskCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`Task` AS `SrcTask`, csnd.`Status` AS `TgtStatus`
                                 FROM `Task` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -taskMnlStat /\\\\ -((I[Task] /\\\\ -(taskMnlStat;taskMnlStat~));taskCmpStat) ([Task*Status]) */
                                          SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"taskMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`Task` AS `SrcTask`, csnd.`Status` AS `TgtStatus`
                                                 FROM `Task` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Task` AS cp
                                                   WHERE cfst.`Task`=cp.`Task` AND csnd.`Status`=cp.`taskMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[Task] /\\\\ -(taskMnlStat;taskMnlStat~));taskCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcTask`, ECps1.`taskCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Task] /\\\\ -(taskMnlStat;taskMnlStat~) ([Task*Task]) */
                                                                     SELECT DISTINCT isect0.`Task` AS `SrcTask`, isect0.`Task` AS `TgtTask`
                                                                     FROM ( /* Case EDcI Task */
                                                                            SELECT `Task` AS `Task`
                                                                            FROM `Task` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            taskMnlStat;taskMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                                         FROM `Task` AS ECps0,
                                                                                              `Task` AS ECps1
                                                                                         WHERE ECps0.`taskMnlStat`=ECps1.`taskMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Task`=cp.`TgtTask`) AND isect0.`Task` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `Task` AS ECps1
                                                              WHERE ECps0.`TgtTask`=ECps1.`Task`
                                                            ) AS cp
                                                            WHERE isect0.`SrcTask`=cp.`SrcTask` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Task`=cp.`SrcTask` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Task` AS cp
                                            WHERE isect0.`SrcTask`=cp.`Task` AND isect0.`TgtStatus`=cp.`taskStatus`) AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskStatus;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultTaskStatus' =>
        array ( 'name'          => 'defaultTaskStatus'
              , 'ruleAdl'       => 'I[Task] |- taskStatus;taskStatus~'
              , 'origin'        => 'line 417:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(I[Task] |- taskStatus;taskStatus~)
              // <=> { remove |- }
              //     -(-I[Task] \\/ taskStatus;taskStatus~)
              // <=> { De Morgan }
              //     I[Task] /\\ -(taskStatus;taskStatus~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Task
              //      ,ECpl (ECps (EDcD rel_taskStatusTaskStatus
              //                  ,EFlp (EDcD rel_taskStatusTaskStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Task] /\\\\ -(taskStatus;taskStatus~) ([Task*Task]) */
                          SELECT DISTINCT isect0.`Task` AS `src`, isect0.`Task` AS `tgt`
                          FROM ( /* Case EDcI Task */
                                 SELECT `Task` AS `Task`
                                 FROM `Task` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 taskStatus;taskStatus~ */
                                              
                                              SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                              FROM `Task` AS ECps0,
                                                   `Task` AS ECps1
                                              WHERE ECps0.`taskStatus`=ECps1.`taskStatus`
                                            ) AS cp
                                            WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Task`=cp.`TgtTask`) AND isect0.`Task` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;taskStatus;Task;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Task'
                            , 'expSQL' =>
                                '/* I[Task] */
                                   SELECT `Task` AS `src`, `Task` AS `tgt`
                                   FROM `Task`
                                   WHERE `Task` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'inspurposeCmpStatIsGreen' =>
        array ( 'name'          => 'inspurposeCmpStatIsGreen'
              , 'ruleAdl'       => 'I[Purpose] /\\ taskPurpose~;taskPurpose /\\ -taskPurpose~!((I[Task] /\\ taskEndTime;taskEndTime~);taskPurpose) |- purposeCmpStat;\'Green\'[Status];purposeCmpStat~'
              , 'origin'        => 'line 432:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Purpose'
              , 'tgtConcept'    => 'Purpose'
              // Normalization steps:
              //     -(I[Purpose] /\\ taskPurpose~;taskPurpose /\\ -taskPurpose~!((I[Task] /\\ taskEndTime;taskEndTime~);taskPurpose) |- purposeCmpStat;\'Green\'[Status];purposeCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Purpose] /\\ taskPurpose~;taskPurpose /\\ -taskPurpose~!((I[Task] /\\ taskEndTime;taskEndTime~);taskPurpose)) \\/ purposeCmpStat;\'Green\'[Status];purposeCmpStat~)
              // <=> { De Morgan }
              //     I[Purpose] /\\ taskPurpose~;taskPurpose /\\ -taskPurpose~!((I[Task] /\\ taskEndTime;taskEndTime~);taskPurpose) /\\ -(purposeCmpStat;\'Green\'[Status];purposeCmpStat~)
              // <=> { -l~!r = l }
              //     I[Purpose] /\\ taskPurpose~;taskPurpose /\\ taskPurpose \\ (I[Task] /\\ taskEndTime;taskEndTime~);taskPurpose /\\ -(purposeCmpStat;\'Green\'[Status];purposeCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Purpose
              //      ,EIsc (ECps (EFlp (EDcD rel_taskPurposeTaskPurpose)
              //                  ,EDcD rel_taskPurposeTaskPurpose
              //                  )
              //            ,EIsc (ERrs (EDcD rel_taskPurposeTaskPurpose
              //                        ,ECps (EIsc (EDcI cpt_Task
              //                                    ,ECps (EDcD rel_taskEndTimeTaskTimestamp
              //                                          ,EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //                                          )
              //                                    )
              //                              ,EDcD rel_taskPurposeTaskPurpose
              //                              )
              //                        )
              //                  ,ECpl (ECps (EDcD rel_purposeCmpStatPurposeStatus
              //                              ,ECps (EMp1 "Green" cpt_Status
              //                                    ,EFlp (EDcD rel_purposeCmpStatPurposeStatus)
              //                                    )
              //                              ))
              //                  )
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Purpose] /\\\\ taskPurpose~;taskPurpose /\\\\ taskPurpose \\\\ (I[Task] /\\\\ taskEndTime;taskEndTime~);taskPurpose /\\\\ -(purposeCmpStat;\\\'Green\\\'[Status];purposeCmpStat~) ([Purpose*Purpose]) */
                          SELECT DISTINCT isect0.`SrcPurpose` AS `src`, isect0.`TgtPurpose` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskPurpose~;taskPurpose */
                                 
                                 SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps1.`Purpose` AS `TgtPurpose`
                                 FROM `taskPurpose` AS ECps0,
                                      `taskPurpose` AS ECps1
                                 WHERE ECps0.`Task`=ECps1.`Task`
                               ) AS isect0, 
                               
                               ( /* case: ERrs (l,r)
                                    taskPurpose \\\\ (I[Task] /\\\\ taskEndTime;taskEndTime~);taskPurpose ([Purpose*Purpose]) */
                                 SELECT `RResLeft`.`Purpose` AS `SrcPurpose`, `RResRight`.`Purpose` AS `TgtPurpose`
                                 FROM `Purpose` AS `RResLeft`, `Purpose` AS `RResRight`
                                 WHERE NOT EXISTS
                                       ( SELECT *
                                         FROM `taskPurpose` AS lhs
                                         WHERE `RResLeft`.`Purpose`=lhs.`Purpose` AND
                                               NOT EXISTS
                                               ( SELECT *
                                                 FROM 
                                                           ( /* case: (ECps es), with two or more elements in es.
                                                                (I[Task] /\\\\ taskEndTime;taskEndTime~);taskPurpose */
                                                             
                                                             SELECT DISTINCT ECps0.`SrcTask`, ECps1.`Purpose` AS `TgtPurpose`
                                                             FROM 
                                                                  ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                       I[Task] /\\\\ taskEndTime;taskEndTime~ ([Task*Task]) */
                                                                    SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                                                    FROM 
                                                                         ( /* case: (ECps es), with two or more elements in es.
                                                                              taskEndTime;taskEndTime~ */
                                                                           
                                                                           SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                           FROM `Task` AS ECps0,
                                                                                `Task` AS ECps1
                                                                           WHERE ECps0.`taskEndTime`=ECps1.`taskEndTime`
                                                                         ) AS isect0, 
                                                                         ( /* Case EDcI Task */
                                                                           SELECT `Task` AS `Task`
                                                                           FROM `Task` ) AS isect1
                                                                    WHERE isect0.`SrcTask` = isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                                                  ) AS ECps0,
                                                                  `taskPurpose` AS ECps1
                                                             WHERE ECps0.`TgtTask`=ECps1.`Task`
                                                           ) AS rhs
                                                 WHERE rhs.`SrcTask`=lhs.`Task` AND rhs.`TgtPurpose`=`RResRight`.`Purpose`
                                               )
                                       )
                               ) AS isect1, 
                               ( /* Case EDcI Purpose */
                                 SELECT `Purpose` AS `Purpose`
                                 FROM `Purpose` ) AS isect2
                          WHERE (isect0.`SrcPurpose` = isect1.`SrcPurpose` AND isect0.`TgtPurpose` = isect1.`TgtPurpose`) AND isect0.`SrcPurpose` = isect0.`TgtPurpose` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 purposeCmpStat;\\\'Green\\\'[Status];purposeCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps2.`Purpose` AS `TgtPurpose`
                                              FROM `Purpose` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Green\' AS `SrcStatus`, \'Green\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Purpose` AS ECps2
                                              WHERE ECps0.`purposeCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`purposeCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcPurpose`=cp.`SrcPurpose` AND isect0.`TgtPurpose`=cp.`TgtPurpose`) AND isect0.`SrcPurpose` IS NOT NULL AND isect0.`TgtPurpose` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;purposeCmpStat;Purpose;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Purpose'
                            , 'expSQL' =>
                                '/* I[Purpose] */
                                   SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                   FROM `Purpose`
                                   WHERE `Purpose` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Green')
                    )
              )
    , 'purposeCmpStatIsYellow' =>
        array ( 'name'          => 'purposeCmpStatIsYellow'
              , 'ruleAdl'       => 'I[Purpose] /\\ taskPurpose~;(I[Task] /\\ -(taskEndTime;taskEndTime~));taskPurpose |- purposeCmpStat;\'Yellow\'[Status];purposeCmpStat~'
              , 'origin'        => 'line 439:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Purpose'
              , 'tgtConcept'    => 'Purpose'
              // Normalization steps:
              //     -(I[Purpose] /\\ taskPurpose~;(I[Task] /\\ -(taskEndTime;taskEndTime~));taskPurpose |- purposeCmpStat;\'Yellow\'[Status];purposeCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Purpose] /\\ taskPurpose~;(I[Task] /\\ -(taskEndTime;taskEndTime~));taskPurpose) \\/ purposeCmpStat;\'Yellow\'[Status];purposeCmpStat~)
              // <=> { De Morgan }
              //     I[Purpose] /\\ taskPurpose~;(I[Task] /\\ -(taskEndTime;taskEndTime~));taskPurpose /\\ -(purposeCmpStat;\'Yellow\'[Status];purposeCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Purpose
              //      ,EIsc (ECps (EFlp (EDcD rel_taskPurposeTaskPurpose)
              //                  ,ECps (EIsc (EDcI cpt_Task
              //                              ,ECpl (ECps (EDcD rel_taskEndTimeTaskTimestamp
              //                                          ,EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //                                          ))
              //                              )
              //                        ,EDcD rel_taskPurposeTaskPurpose
              //                        )
              //                  )
              //            ,ECpl (ECps (EDcD rel_purposeCmpStatPurposeStatus
              //                        ,ECps (EMp1 "Yellow" cpt_Status
              //                              ,EFlp (EDcD rel_purposeCmpStatPurposeStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Purpose] /\\\\ taskPurpose~;(I[Task] /\\\\ -(taskEndTime;taskEndTime~));taskPurpose /\\\\ -(purposeCmpStat;\\\'Yellow\\\'[Status];purposeCmpStat~) ([Purpose*Purpose]) */
                          SELECT DISTINCT isect0.`SrcPurpose` AS `src`, isect0.`TgtPurpose` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskPurpose~;(I[Task] /\\\\ -(taskEndTime;taskEndTime~));taskPurpose */
                                 
                                 SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps2.`Purpose` AS `TgtPurpose`
                                 FROM `taskPurpose` AS ECps0,
                                      
                                      ( /* case: (EIsc lst\\\'@(_:_:_))
                                           I[Task] /\\\\ -(taskEndTime;taskEndTime~) ([Task*Task]) */
                                        SELECT DISTINCT isect0.`Task` AS `SrcTask`, isect0.`Task` AS `TgtTask`
                                        FROM ( /* Case EDcI Task */
                                               SELECT `Task` AS `Task`
                                               FROM `Task` ) AS isect0
                                        WHERE NOT EXISTS (SELECT * FROM 
                                                          ( /* case: (ECps es), with two or more elements in es.
                                                               taskEndTime;taskEndTime~ */
                                                            
                                                            SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`Task` AS `TgtTask`
                                                            FROM `Task` AS ECps0,
                                                                 `Task` AS ECps1
                                                            WHERE ECps0.`taskEndTime`=ECps1.`taskEndTime`
                                                          ) AS cp
                                                          WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Task`=cp.`TgtTask`) AND isect0.`Task` IS NOT NULL
                                      ) AS ECps1,
                                      `taskPurpose` AS ECps2
                                 WHERE ECps0.`Task`=ECps1.`SrcTask`
                                   AND ECps1.`TgtTask`=ECps2.`Task`
                               ) AS isect0, 
                               ( /* Case EDcI Purpose */
                                 SELECT `Purpose` AS `Purpose`
                                 FROM `Purpose` ) AS isect1
                          WHERE isect0.`SrcPurpose` = isect0.`TgtPurpose` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 purposeCmpStat;\\\'Yellow\\\'[Status];purposeCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps2.`Purpose` AS `TgtPurpose`
                                              FROM `Purpose` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Yellow\' AS `SrcStatus`, \'Yellow\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Purpose` AS ECps2
                                              WHERE ECps0.`purposeCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`purposeCmpStat`
                                            ) AS cp
                                            WHERE isect0.`SrcPurpose`=cp.`SrcPurpose` AND isect0.`TgtPurpose`=cp.`TgtPurpose`) AND isect0.`SrcPurpose` IS NOT NULL AND isect0.`TgtPurpose` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;purposeCmpStat;Purpose;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Purpose'
                            , 'expSQL' =>
                                '/* I[Purpose] */
                                   SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                   FROM `Purpose`
                                   WHERE `Purpose` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Yellow')
                    )
              )
    , 'purposeCmpStatIsRed' =>
        array ( 'name'          => 'purposeCmpStatIsRed'
              , 'ruleAdl'       => 'I[Purpose] /\\ -(taskPurpose~;taskPurpose) |- purposeCmpStat;\'Red\'[Status];purposeCmpStat~'
              , 'origin'        => 'line 446:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Purpose'
              , 'tgtConcept'    => 'Purpose'
              // Normalization steps:
              //     -(I[Purpose] /\\ -(taskPurpose~;taskPurpose) |- purposeCmpStat;\'Red\'[Status];purposeCmpStat~)
              // <=> { remove |- }
              //     -(-(I[Purpose] /\\ -(taskPurpose~;taskPurpose)) \\/ purposeCmpStat;\'Red\'[Status];purposeCmpStat~)
              // <=> { De Morgan }
              //     I[Purpose] /\\ -(taskPurpose~;taskPurpose) /\\ -(purposeCmpStat;\'Red\'[Status];purposeCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Purpose
              //      ,EIsc (ECpl (ECps (EFlp (EDcD rel_taskPurposeTaskPurpose)
              //                        ,EDcD rel_taskPurposeTaskPurpose
              //                        ))
              //            ,ECpl (ECps (EDcD rel_purposeCmpStatPurposeStatus
              //                        ,ECps (EMp1 "Red" cpt_Status
              //                              ,EFlp (EDcD rel_purposeCmpStatPurposeStatus)
              //                              )
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Purpose] /\\\\ -(taskPurpose~;taskPurpose) /\\\\ -(purposeCmpStat;\\\'Red\\\'[Status];purposeCmpStat~) ([Purpose*Purpose]) */
                          SELECT DISTINCT isect0.`Purpose` AS `src`, isect0.`Purpose` AS `tgt`
                          FROM ( /* Case EDcI Purpose */
                                 SELECT `Purpose` AS `Purpose`
                                 FROM `Purpose` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 taskPurpose~;taskPurpose */
                                              
                                              SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps1.`Purpose` AS `TgtPurpose`
                                              FROM `taskPurpose` AS ECps0,
                                                   `taskPurpose` AS ECps1
                                              WHERE ECps0.`Task`=ECps1.`Task`
                                            ) AS cp
                                            WHERE isect0.`Purpose`=cp.`SrcPurpose` AND isect0.`Purpose`=cp.`TgtPurpose`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 purposeCmpStat;\\\'Red\\\'[Status];purposeCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps2.`Purpose` AS `TgtPurpose`
                                              FROM `Purpose` AS ECps0,
                                                   
                                                   ( /* case: EMp1 atom. */
                                                     SELECT \'Red\' AS `SrcStatus`, \'Red\' AS `TgtStatus`
                                                   ) AS ECps1,
                                                   `Purpose` AS ECps2
                                              WHERE ECps0.`purposeCmpStat`=ECps1.`SrcStatus`
                                                AND ECps1.`TgtStatus`=ECps2.`purposeCmpStat`
                                            ) AS cp
                                            WHERE isect0.`Purpose`=cp.`SrcPurpose` AND isect0.`Purpose`=cp.`TgtPurpose`) AND isect0.`Purpose` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;purposeCmpStat;Purpose;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Purpose'
                            , 'expSQL' =>
                                '/* I[Purpose] */
                                   SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                   FROM `Purpose`
                                   WHERE `Purpose` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;Red')
                    )
              )
    , 'InsPurposeStatus' =>
        array ( 'name'          => 'InsPurposeStatus'
              , 'ruleAdl'       => 'purposeMnlStat \\/ (I[Purpose] /\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat |- purposeCmpStat'
              , 'origin'        => 'line 452:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Purpose'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(purposeMnlStat \\/ (I[Purpose] /\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat |- purposeCmpStat)
              // <=> { remove |- }
              //     -(-(purposeMnlStat \\/ (I[Purpose] /\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat) \\/ purposeCmpStat)
              // <=> { De Morgan }
              //     -(-purposeMnlStat /\\ -((I[Purpose] /\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat)) /\\ -purposeCmpStat
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECpl (EIsc (ECpl (EDcD rel_purposeMnlStatPurposeStatus)
              //                  ,ECpl (ECps (EIsc (EDcI cpt_Purpose
              //                                    ,ECpl (ECps (EDcD rel_purposeMnlStatPurposeStatus
              //                                                ,EFlp (EDcD rel_purposeMnlStatPurposeStatus)
              //                                                ))
              //                                    )
              //                              ,EDcD rel_purposeCmpStatPurposeStatus
              //                              ))
              //                  ))
              //      ,ECpl (EDcD rel_purposeCmpStatPurposeStatus)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             -(-purposeMnlStat /\\\\ -((I[Purpose] /\\\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat)) /\\\\ -purposeCmpStat ([Purpose*Status]) */
                          SELECT DISTINCT isect0.`SrcPurpose` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: ECpl e
                                    ECpl ( \\"-purposeMnlStat /\\\\ -((I[Purpose] /\\\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat)\\" ) */
                                 SELECT DISTINCT cfst.`Purpose` AS `SrcPurpose`, csnd.`Status` AS `TgtStatus`
                                 FROM `Purpose` AS cfst,
                                      `Status` AS csnd
                                 WHERE NOT EXISTS
                                  (SELECT * FROM 
                                        ( /* case: (EIsc lst\\\'@(_:_:_))
                                             -purposeMnlStat /\\\\ -((I[Purpose] /\\\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat) ([Purpose*Status]) */
                                          SELECT DISTINCT isect0.`SrcPurpose`, isect0.`TgtStatus`
                                          FROM 
                                               ( /* case: ECpl e
                                                    ECpl ( \\"purposeMnlStat\\" ) */
                                                 SELECT DISTINCT cfst.`Purpose` AS `SrcPurpose`, csnd.`Status` AS `TgtStatus`
                                                 FROM `Purpose` AS cfst,
                                                      `Status` AS csnd
                                                 WHERE NOT EXISTS
                                                  (SELECT * FROM `Purpose` AS cp
                                                   WHERE cfst.`Purpose`=cp.`Purpose` AND csnd.`Status`=cp.`purposeMnlStat`)
                                               ) AS isect0
                                          WHERE NOT EXISTS (SELECT * FROM 
                                                            ( /* case: (ECps es), with two or more elements in es.
                                                                 (I[Purpose] /\\\\ -(purposeMnlStat;purposeMnlStat~));purposeCmpStat */
                                                              
                                                              SELECT DISTINCT ECps0.`SrcPurpose`, ECps1.`purposeCmpStat` AS `TgtStatus`
                                                              FROM 
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Purpose] /\\\\ -(purposeMnlStat;purposeMnlStat~) ([Purpose*Purpose]) */
                                                                     SELECT DISTINCT isect0.`Purpose` AS `SrcPurpose`, isect0.`Purpose` AS `TgtPurpose`
                                                                     FROM ( /* Case EDcI Purpose */
                                                                            SELECT `Purpose` AS `Purpose`
                                                                            FROM `Purpose` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            purposeMnlStat;purposeMnlStat~ */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps1.`Purpose` AS `TgtPurpose`
                                                                                         FROM `Purpose` AS ECps0,
                                                                                              `Purpose` AS ECps1
                                                                                         WHERE ECps0.`purposeMnlStat`=ECps1.`purposeMnlStat`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Purpose`=cp.`SrcPurpose` AND isect0.`Purpose`=cp.`TgtPurpose`) AND isect0.`Purpose` IS NOT NULL
                                                                   ) AS ECps0,
                                                                   `Purpose` AS ECps1
                                                              WHERE ECps0.`TgtPurpose`=ECps1.`Purpose`
                                                            ) AS cp
                                                            WHERE isect0.`SrcPurpose`=cp.`SrcPurpose` AND isect0.`TgtStatus`=cp.`TgtStatus`) AND isect0.`SrcPurpose` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL
                                        ) AS cp
                                   WHERE cfst.`Purpose`=cp.`SrcPurpose` AND csnd.`Status`=cp.`TgtStatus`)
                               ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM `Purpose` AS cp
                                            WHERE isect0.`SrcPurpose`=cp.`Purpose` AND isect0.`TgtStatus`=cp.`purposeCmpStat`) AND isect0.`SrcPurpose` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;purposeCmpStat;Purpose;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Purpose'
                            , 'expSQL' =>
                                '/* I[Purpose] */
                                   SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                   FROM `Purpose`
                                   WHERE `Purpose` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Status'
                            , 'expSQL' =>
                                '/* I[Status] */
                                   SELECT `Status` AS `src`, `Status` AS `tgt`
                                   FROM `Status`
                                   WHERE `Status` IS NOT NULL'
                            )
                    )
              )
    , 'defaultPurposeStatus' =>
        array ( 'name'          => 'defaultPurposeStatus'
              , 'ruleAdl'       => 'I[Purpose] |- purposeCmpStat;purposeCmpStat~'
              , 'origin'        => 'line 455:1, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Purpose'
              , 'tgtConcept'    => 'Purpose'
              // Normalization steps:
              //     -(I[Purpose] |- purposeCmpStat;purposeCmpStat~)
              // <=> { remove |- }
              //     -(-I[Purpose] \\/ purposeCmpStat;purposeCmpStat~)
              // <=> { De Morgan }
              //     I[Purpose] /\\ -(purposeCmpStat;purposeCmpStat~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Purpose
              //      ,ECpl (ECps (EDcD rel_purposeCmpStatPurposeStatus
              //                  ,EFlp (EDcD rel_purposeCmpStatPurposeStatus)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Purpose] /\\\\ -(purposeCmpStat;purposeCmpStat~) ([Purpose*Purpose]) */
                          SELECT DISTINCT isect0.`Purpose` AS `src`, isect0.`Purpose` AS `tgt`
                          FROM ( /* Case EDcI Purpose */
                                 SELECT `Purpose` AS `Purpose`
                                 FROM `Purpose` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 purposeCmpStat;purposeCmpStat~ */
                                              
                                              SELECT DISTINCT ECps0.`Purpose` AS `SrcPurpose`, ECps1.`Purpose` AS `TgtPurpose`
                                              FROM `Purpose` AS ECps0,
                                                   `Purpose` AS ECps1
                                              WHERE ECps0.`purposeCmpStat`=ECps1.`purposeCmpStat`
                                            ) AS cp
                                            WHERE isect0.`Purpose`=cp.`SrcPurpose` AND isect0.`Purpose`=cp.`TgtPurpose`) AND isect0.`Purpose` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => '{EX} InsPair;purposeCmpStat;Purpose;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Purpose'
                            , 'expSQL' =>
                                '/* I[Purpose] */
                                   SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                   FROM `Purpose`
                                   WHERE `Purpose` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Status;White')
                    )
              )
    , 'Yes/No answer integrity' =>
        array ( 'name'          => 'Yes/No answer integrity'
              , 'ruleAdl'       => 'I[Yes/No answer] |- \'Yes\'[Yes/No answer] \\/ \'No\'[Yes/No answer]'
              , 'origin'        => 'line 22:1, file "CSA_Op.adl"'
              , 'meaning'       => 'A Yes/No answer can only have the values \'Yes\' or \'No\''
              , 'message'       => 'You may only specify \'Yes\' or \'No\' as an answer.'
              , 'srcConcept'    => 'Yes/No answer'
              , 'tgtConcept'    => 'Yes/No answer'
              // Normalization steps:
              //     -(I[Yes/No answer] |- \'Yes\'[Yes/No answer] \\/ \'No\'[Yes/No answer])
              // <=> { remove |- }
              //     -(-I[Yes/No answer] \\/ \'Yes\'[Yes/No answer] \\/ \'No\'[Yes/No answer])
              // <=> { De Morgan }
              //     I[Yes/No answer] /\\ -\'Yes\'[Yes/No answer] /\\ -\'No\'[Yes/No answer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_YesNoanswer
              //      ,EIsc (ECpl (EMp1 "Yes" cpt_YesNoanswer)
              //            ,ECpl (EMp1 "No" cpt_YesNoanswer)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Yes/No answer] /\\\\ -\\\'Yes\\\'[Yes/No answer] /\\\\ -\\\'No\\\'[Yes/No answer] ([Yes/No answer*Yes/No answer]) */
                          SELECT DISTINCT isect0.`Yes/No answer` AS `src`, isect0.`Yes/No answer` AS `tgt`
                          FROM ( /* Case EDcI Yes/No answer */
                                 SELECT `Yes/No answer` AS `Yes/No answer`
                                 FROM `Yes/No answer` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: EMp1 atom. */
                                              SELECT \'Yes\' AS `SrcYes/No answer`, \'Yes\' AS `TgtYes/No answer`
                                            ) AS cp
                                            WHERE isect0.`Yes/No answer`=cp.`SrcYes/No answer` AND isect0.`Yes/No answer`=cp.`TgtYes/No answer`) AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: EMp1 atom. */
                                              SELECT \'No\' AS `SrcYes/No answer`, \'No\' AS `TgtYes/No answer`
                                            ) AS cp
                                            WHERE isect0.`Yes/No answer`=cp.`SrcYes/No answer` AND isect0.`Yes/No answer`=cp.`TgtYes/No answer`) AND isect0.`Yes/No answer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'IRF[isSubtaskOf]' =>
        array ( 'name'          => 'IRF[isSubtaskOf]'
              , 'ruleAdl'       => 'isSubtaskOf |- -I[Task]'
              , 'origin'        => 'line 19:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'A task cannot be a subtask of itself'
              , 'message'       => ''
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(isSubtaskOf |- -I[Task])
              // <=> { remove |- }
              //     -(-isSubtaskOf \\/ -I[Task])
              // <=> { De Morgan }
              //     isSubtaskOf /\\ I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_isSubtaskOfTaskTask
              //      ,EDcI cpt_Task
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             isSubtaskOf /\\\\ I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM `isSubtaskOf` AS isect0, 
                               ( /* Case EDcI Task */
                                 SELECT `Task` AS `Task`
                                 FROM `Task` ) AS isect1
                          WHERE isect0.`SrcTask` = isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Activity executor must exist' =>
        array ( 'name'          => 'Activity executor must exist'
              , 'ruleAdl'       => 'I[Activity] |- actExecutingOU;actExecutingOU~'
              , 'origin'        => 'line 58:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'For every activity, an OrgUnit must be appointed that executes te activity'
              , 'message'       => ''
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actExecutingOU;actExecutingOU~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actExecutingOU;actExecutingOU~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actExecutingOU;actExecutingOU~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,ECpl (ECps (EDcD rel_actExecutingOUActivityOrgUnit
              //                  ,EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ -(actExecutingOU;actExecutingOU~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`Activity` AS `src`, isect0.`Activity` AS `tgt`
                          FROM ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actExecutingOU;actExecutingOU~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   `Activity` AS ECps1
                                              WHERE ECps0.`actExecutingOU`=ECps1.`actExecutingOU`
                                            ) AS cp
                                            WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Router network integrity' =>
        array ( 'name'          => 'Router network integrity'
              , 'ruleAdl'       => 'I[Router] /\\ rrtDirect;rrtDirect~ |- routerNW;routerNW~'
              , 'origin'        => 'line 146:1, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'Only routers that are part of a network may have routes'
              , 'message'       => ''
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(I[Router] /\\ rrtDirect;rrtDirect~ |- routerNW;routerNW~)
              // <=> { remove |- }
              //     -(-(I[Router] /\\ rrtDirect;rrtDirect~) \\/ routerNW;routerNW~)
              // <=> { De Morgan }
              //     I[Router] /\\ rrtDirect;rrtDirect~ /\\ -(routerNW;routerNW~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Router
              //      ,EIsc (ECps (EDcD rel_rrtDirectRouterRouter
              //                  ,EFlp (EDcD rel_rrtDirectRouterRouter)
              //                  )
              //            ,ECpl (ECps (EDcD rel_routerNWRouterNetwork
              //                        ,EFlp (EDcD rel_routerNWRouterNetwork)
              //                        ))
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Router] /\\\\ rrtDirect;rrtDirect~ /\\\\ -(routerNW;routerNW~) ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    rrtDirect;rrtDirect~ */
                                 
                                 SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`SrcRouter` AS `TgtRouter`
                                 FROM `rrtDirect` AS ECps0,
                                      `rrtDirect` AS ECps1
                                 WHERE ECps0.`TgtRouter`=ECps1.`TgtRouter`
                               ) AS isect0, 
                               ( /* Case EDcI Router */
                                 SELECT `Router` AS `Router`
                                 FROM `Router` ) AS isect1
                          WHERE isect0.`SrcRouter` = isect0.`TgtRouter` AND NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 routerNW;routerNW~ */
                                              
                                              SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`Router` AS `TgtRouter`
                                              FROM `Router` AS ECps0,
                                                   `Router` AS ECps1
                                              WHERE ECps0.`routerNW`=ECps1.`routerNW`
                                            ) AS cp
                                            WHERE isect0.`SrcRouter`=cp.`SrcRouter` AND isect0.`TgtRouter`=cp.`TgtRouter`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Router ')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Router'
                            , 'expSQL' =>
                                '/* I[Router] */
                                   SELECT `Router` AS `src`, `Router` AS `tgt`
                                   FROM `Router`
                                   WHERE `Router` IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ' is not part of a network, and hence may not have routes.')
                    )
              )
    , 'SYM connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'SYM connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter = connectComputerToNetworkRouter~'
              , 'origin'        => 'line 41:32, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer] is symmetric'
              , 'message'       => 'connectComputerToNetworkRouter[Computer] is not symmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter = connectComputerToNetworkRouter~)
              // <=> { remove = }
              //     -((connectComputerToNetworkRouter |- connectComputerToNetworkRouter~) /\\ (connectComputerToNetworkRouter~ |- connectComputerToNetworkRouter))
              // <=> { remove |- and remove |- }
              //     -((-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter~) /\\ (-connectComputerToNetworkRouter~ \\/ connectComputerToNetworkRouter))
              // <=> { connectComputerToNetworkRouter is symmetric and connectComputerToNetworkRouter is symmetric }
              //     -((-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter) /\\ (-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter))
              // <=> { -connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter /\\ -connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter = -connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter }
              //     -(-connectComputerToNetworkRouter \\/ connectComputerToNetworkRouter)
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter /\\ -connectComputerToNetworkRouter
              // <=> { connectComputerToNetworkRouter /\\ -connectComputerToNetworkRouter = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Computer cpt_Computer))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'ASY connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter |- I[Computer]'
              , 'origin'        => 'line 41:32, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer] is antisymmetric'
              , 'message'       => 'connectComputerToNetworkRouter[Computer] is not antisymmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter |- I[Computer])
              // <=> { remove |- }
              //     -(-(connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter) \\/ I[Computer])
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter~ /\\ connectComputerToNetworkRouter /\\ -I[Computer]
              // <=> { connectComputerToNetworkRouter is symmetric }
              //     connectComputerToNetworkRouter /\\ connectComputerToNetworkRouter /\\ -I[Computer]
              // <=> { connectComputerToNetworkRouter /\\ connectComputerToNetworkRouter = connectComputerToNetworkRouter }
              //     connectComputerToNetworkRouter /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_connectComputerToNetworkRouterComputerComputer
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             connectComputerToNetworkRouter /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`connectComputerToNetworkRouter` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE isect0.Computer <> isect0.`connectComputerToNetworkRouter` AND isect0.Computer IS NOT NULL AND isect0.`connectComputerToNetworkRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'UNI connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter~;connectComputerToNetworkRouter |- I[Computer]'
              , 'origin'        => 'line 41:32, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is univalent'
              , 'message'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is not univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter~;connectComputerToNetworkRouter |- I[Computer])
              // <=> { remove |- }
              //     -(-(connectComputerToNetworkRouter~;connectComputerToNetworkRouter) \\/ I[Computer])
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter~;connectComputerToNetworkRouter /\\ -I[Computer]
              // <=> { connectComputerToNetworkRouter is symmetric }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_connectComputerToNetworkRouterComputerComputer
              //            ,EDcD rel_connectComputerToNetworkRouterComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    connectComputerToNetworkRouter;connectComputerToNetworkRouter */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`connectComputerToNetworkRouter` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`connectComputerToNetworkRouter`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ connectComputerToNetworkRouter::Computer*Computer' =>
        array ( 'name'          => 'INJ connectComputerToNetworkRouter::Computer*Computer'
              , 'ruleAdl'       => 'connectComputerToNetworkRouter;connectComputerToNetworkRouter~ |- I[Computer]'
              , 'origin'        => 'line 41:32, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is injective'
              , 'message'       => 'connectComputerToNetworkRouter[Computer\\*Computer] is not injective'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(connectComputerToNetworkRouter;connectComputerToNetworkRouter~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(connectComputerToNetworkRouter;connectComputerToNetworkRouter~) \\/ I[Computer])
              // <=> { De Morgan }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter~ /\\ -I[Computer]
              // <=> { connectComputerToNetworkRouter is symmetric }
              //     connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_connectComputerToNetworkRouterComputerComputer
              //            ,EDcD rel_connectComputerToNetworkRouterComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             connectComputerToNetworkRouter;connectComputerToNetworkRouter /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    connectComputerToNetworkRouter;connectComputerToNetworkRouter */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`connectComputerToNetworkRouter` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`connectComputerToNetworkRouter`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'SYM compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm = compRequiresComm~'
              , 'origin'        => 'line 143:18, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compRequiresComm[Computer] is symmetric'
              , 'message'       => 'compRequiresComm[Computer] is not symmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm = compRequiresComm~)
              // <=> { remove = }
              //     -((compRequiresComm |- compRequiresComm~) /\\ (compRequiresComm~ |- compRequiresComm))
              // <=> { remove |- and remove |- }
              //     -((-compRequiresComm \\/ compRequiresComm~) /\\ (-compRequiresComm~ \\/ compRequiresComm))
              // <=> { compRequiresComm is symmetric and compRequiresComm is symmetric }
              //     -((-compRequiresComm \\/ compRequiresComm) /\\ (-compRequiresComm \\/ compRequiresComm))
              // <=> { -compRequiresComm \\/ compRequiresComm /\\ -compRequiresComm \\/ compRequiresComm = -compRequiresComm \\/ compRequiresComm }
              //     -(-compRequiresComm \\/ compRequiresComm)
              // <=> { De Morgan }
              //     compRequiresComm /\\ -compRequiresComm
              // <=> { compRequiresComm /\\ -compRequiresComm = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Computer cpt_Computer))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'ASY compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm~ /\\ compRequiresComm |- I[Computer]'
              , 'origin'        => 'line 143:18, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compRequiresComm[Computer] is antisymmetric'
              , 'message'       => 'compRequiresComm[Computer] is not antisymmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm~ /\\ compRequiresComm |- I[Computer])
              // <=> { remove |- }
              //     -(-(compRequiresComm~ /\\ compRequiresComm) \\/ I[Computer])
              // <=> { De Morgan }
              //     compRequiresComm~ /\\ compRequiresComm /\\ -I[Computer]
              // <=> { compRequiresComm is symmetric }
              //     compRequiresComm /\\ compRequiresComm /\\ -I[Computer]
              // <=> { compRequiresComm /\\ compRequiresComm = compRequiresComm }
              //     compRequiresComm /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compRequiresCommComputerComputer
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRequiresComm /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compRequiresComm` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE isect0.Computer <> isect0.`compRequiresComm` AND isect0.Computer IS NOT NULL AND isect0.`compRequiresComm` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'UNI compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm~;compRequiresComm |- I[Computer]'
              , 'origin'        => 'line 143:18, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compRequiresComm[Computer\\*Computer] is univalent'
              , 'message'       => 'compRequiresComm[Computer\\*Computer] is not univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm~;compRequiresComm |- I[Computer])
              // <=> { remove |- }
              //     -(-(compRequiresComm~;compRequiresComm) \\/ I[Computer])
              // <=> { De Morgan }
              //     compRequiresComm~;compRequiresComm /\\ -I[Computer]
              // <=> { compRequiresComm is symmetric }
              //     compRequiresComm;compRequiresComm /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_compRequiresCommComputerComputer
              //            ,EDcD rel_compRequiresCommComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRequiresComm;compRequiresComm /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRequiresComm;compRequiresComm */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`compRequiresComm` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compRequiresComm`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ compRequiresComm::Computer*Computer' =>
        array ( 'name'          => 'INJ compRequiresComm::Computer*Computer'
              , 'ruleAdl'       => 'compRequiresComm;compRequiresComm~ |- I[Computer]'
              , 'origin'        => 'line 143:18, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compRequiresComm[Computer\\*Computer] is injective'
              , 'message'       => 'compRequiresComm[Computer\\*Computer] is not injective'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compRequiresComm;compRequiresComm~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(compRequiresComm;compRequiresComm~) \\/ I[Computer])
              // <=> { De Morgan }
              //     compRequiresComm;compRequiresComm~ /\\ -I[Computer]
              // <=> { compRequiresComm is symmetric }
              //     compRequiresComm;compRequiresComm /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_compRequiresCommComputerComputer
              //            ,EDcD rel_compRequiresCommComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compRequiresComm;compRequiresComm /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compRequiresComm;compRequiresComm */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`compRequiresComm` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compRequiresComm`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'SYM compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied = compAllReqCommSatisfied~'
              , 'origin'        => 'line 159:25, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer] is symmetric'
              , 'message'       => 'compAllReqCommSatisfied[Computer] is not symmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied = compAllReqCommSatisfied~)
              // <=> { remove = }
              //     -((compAllReqCommSatisfied |- compAllReqCommSatisfied~) /\\ (compAllReqCommSatisfied~ |- compAllReqCommSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-compAllReqCommSatisfied \\/ compAllReqCommSatisfied~) /\\ (-compAllReqCommSatisfied~ \\/ compAllReqCommSatisfied))
              // <=> { compAllReqCommSatisfied is symmetric and compAllReqCommSatisfied is symmetric }
              //     -((-compAllReqCommSatisfied \\/ compAllReqCommSatisfied) /\\ (-compAllReqCommSatisfied \\/ compAllReqCommSatisfied))
              // <=> { -compAllReqCommSatisfied \\/ compAllReqCommSatisfied /\\ -compAllReqCommSatisfied \\/ compAllReqCommSatisfied = -compAllReqCommSatisfied \\/ compAllReqCommSatisfied }
              //     -(-compAllReqCommSatisfied \\/ compAllReqCommSatisfied)
              // <=> { De Morgan }
              //     compAllReqCommSatisfied /\\ -compAllReqCommSatisfied
              // <=> { compAllReqCommSatisfied /\\ -compAllReqCommSatisfied = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Computer cpt_Computer))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'ASY compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 159:25, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer] is antisymmetric'
              , 'message'       => 'compAllReqCommSatisfied[Computer] is not antisymmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied~ /\\ compAllReqCommSatisfied /\\ -I[Computer]
              // <=> { compAllReqCommSatisfied is symmetric }
              //     compAllReqCommSatisfied /\\ compAllReqCommSatisfied /\\ -I[Computer]
              // <=> { compAllReqCommSatisfied /\\ compAllReqCommSatisfied = compAllReqCommSatisfied }
              //     compAllReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compAllReqCommSatisfiedComputerComputer
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compAllReqCommSatisfied /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compAllReqCommSatisfied` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE isect0.Computer <> isect0.`compAllReqCommSatisfied` AND isect0.Computer IS NOT NULL AND isect0.`compAllReqCommSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'UNI compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied~;compAllReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 159:25, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer\\*Computer] is univalent'
              , 'message'       => 'compAllReqCommSatisfied[Computer\\*Computer] is not univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied~;compAllReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied~;compAllReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied~;compAllReqCommSatisfied /\\ -I[Computer]
              // <=> { compAllReqCommSatisfied is symmetric }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_compAllReqCommSatisfiedComputerComputer
              //            ,EDcD rel_compAllReqCommSatisfiedComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compAllReqCommSatisfied;compAllReqCommSatisfied /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compAllReqCommSatisfied;compAllReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`compAllReqCommSatisfied` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compAllReqCommSatisfied`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ compAllReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'INJ compAllReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compAllReqCommSatisfied;compAllReqCommSatisfied~ |- I[Computer]'
              , 'origin'        => 'line 159:25, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compAllReqCommSatisfied[Computer\\*Computer] is injective'
              , 'message'       => 'compAllReqCommSatisfied[Computer\\*Computer] is not injective'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compAllReqCommSatisfied;compAllReqCommSatisfied~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(compAllReqCommSatisfied;compAllReqCommSatisfied~) \\/ I[Computer])
              // <=> { De Morgan }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied~ /\\ -I[Computer]
              // <=> { compAllReqCommSatisfied is symmetric }
              //     compAllReqCommSatisfied;compAllReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_compAllReqCommSatisfiedComputerComputer
              //            ,EDcD rel_compAllReqCommSatisfiedComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compAllReqCommSatisfied;compAllReqCommSatisfied /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compAllReqCommSatisfied;compAllReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`compAllReqCommSatisfied` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compAllReqCommSatisfied`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'SYM compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied = compNoReqCommSatisfied~'
              , 'origin'        => 'line 167:24, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer] is symmetric'
              , 'message'       => 'compNoReqCommSatisfied[Computer] is not symmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied = compNoReqCommSatisfied~)
              // <=> { remove = }
              //     -((compNoReqCommSatisfied |- compNoReqCommSatisfied~) /\\ (compNoReqCommSatisfied~ |- compNoReqCommSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-compNoReqCommSatisfied \\/ compNoReqCommSatisfied~) /\\ (-compNoReqCommSatisfied~ \\/ compNoReqCommSatisfied))
              // <=> { compNoReqCommSatisfied is symmetric and compNoReqCommSatisfied is symmetric }
              //     -((-compNoReqCommSatisfied \\/ compNoReqCommSatisfied) /\\ (-compNoReqCommSatisfied \\/ compNoReqCommSatisfied))
              // <=> { -compNoReqCommSatisfied \\/ compNoReqCommSatisfied /\\ -compNoReqCommSatisfied \\/ compNoReqCommSatisfied = -compNoReqCommSatisfied \\/ compNoReqCommSatisfied }
              //     -(-compNoReqCommSatisfied \\/ compNoReqCommSatisfied)
              // <=> { De Morgan }
              //     compNoReqCommSatisfied /\\ -compNoReqCommSatisfied
              // <=> { compNoReqCommSatisfied /\\ -compNoReqCommSatisfied = V- }
              //     -V[Computer*Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Computer cpt_Computer))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Computer*Computer] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'ASY compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 167:24, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer] is antisymmetric'
              , 'message'       => 'compNoReqCommSatisfied[Computer] is not antisymmetric'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compNoReqCommSatisfied~ /\\ compNoReqCommSatisfied /\\ -I[Computer]
              // <=> { compNoReqCommSatisfied is symmetric }
              //     compNoReqCommSatisfied /\\ compNoReqCommSatisfied /\\ -I[Computer]
              // <=> { compNoReqCommSatisfied /\\ compNoReqCommSatisfied = compNoReqCommSatisfied }
              //     compNoReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_compNoReqCommSatisfiedComputerComputer
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compNoReqCommSatisfied /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`Computer` AS `src`, isect0.`compNoReqCommSatisfied` AS `tgt`
                          FROM `Computer` AS isect0
                          WHERE isect0.Computer <> isect0.`compNoReqCommSatisfied` AND isect0.Computer IS NOT NULL AND isect0.`compNoReqCommSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'UNI compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied~;compNoReqCommSatisfied |- I[Computer]'
              , 'origin'        => 'line 167:24, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer\\*Computer] is univalent'
              , 'message'       => 'compNoReqCommSatisfied[Computer\\*Computer] is not univalent'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied~;compNoReqCommSatisfied |- I[Computer])
              // <=> { remove |- }
              //     -(-(compNoReqCommSatisfied~;compNoReqCommSatisfied) \\/ I[Computer])
              // <=> { De Morgan }
              //     compNoReqCommSatisfied~;compNoReqCommSatisfied /\\ -I[Computer]
              // <=> { compNoReqCommSatisfied is symmetric }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_compNoReqCommSatisfiedComputerComputer
              //            ,EDcD rel_compNoReqCommSatisfiedComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compNoReqCommSatisfied;compNoReqCommSatisfied /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compNoReqCommSatisfied;compNoReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`compNoReqCommSatisfied` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compNoReqCommSatisfied`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ compNoReqCommSatisfied::Computer*Computer' =>
        array ( 'name'          => 'INJ compNoReqCommSatisfied::Computer*Computer'
              , 'ruleAdl'       => 'compNoReqCommSatisfied;compNoReqCommSatisfied~ |- I[Computer]'
              , 'origin'        => 'line 167:24, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'compNoReqCommSatisfied[Computer\\*Computer] is injective'
              , 'message'       => 'compNoReqCommSatisfied[Computer\\*Computer] is not injective'
              , 'srcConcept'    => 'Computer'
              , 'tgtConcept'    => 'Computer'
              // Normalization steps:
              //     -(compNoReqCommSatisfied;compNoReqCommSatisfied~ |- I[Computer])
              // <=> { remove |- }
              //     -(-(compNoReqCommSatisfied;compNoReqCommSatisfied~) \\/ I[Computer])
              // <=> { De Morgan }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied~ /\\ -I[Computer]
              // <=> { compNoReqCommSatisfied is symmetric }
              //     compNoReqCommSatisfied;compNoReqCommSatisfied /\\ -I[Computer]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_compNoReqCommSatisfiedComputerComputer
              //            ,EDcD rel_compNoReqCommSatisfiedComputerComputer
              //            )
              //      ,ECpl (EDcI cpt_Computer)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compNoReqCommSatisfied;compNoReqCommSatisfied /\\\\ -I[Computer] ([Computer*Computer]) */
                          SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compNoReqCommSatisfied;compNoReqCommSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps1.`compNoReqCommSatisfied` AS `TgtComputer`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`compNoReqCommSatisfied`=ECps1.Computer
                               ) AS isect0
                          WHERE isect0.`SrcComputer` <> isect0.`TgtComputer` AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'SYM routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied = routerAllCommReqsSatisfied~'
              , 'origin'        => 'line 200:28, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router] is symmetric'
              , 'message'       => 'routerAllCommReqsSatisfied[Router] is not symmetric'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied = routerAllCommReqsSatisfied~)
              // <=> { remove = }
              //     -((routerAllCommReqsSatisfied |- routerAllCommReqsSatisfied~) /\\ (routerAllCommReqsSatisfied~ |- routerAllCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied~) /\\ (-routerAllCommReqsSatisfied~ \\/ routerAllCommReqsSatisfied))
              // <=> { routerAllCommReqsSatisfied is symmetric and routerAllCommReqsSatisfied is symmetric }
              //     -((-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied) /\\ (-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied))
              // <=> { -routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied /\\ -routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied = -routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied }
              //     -(-routerAllCommReqsSatisfied \\/ routerAllCommReqsSatisfied)
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied /\\ -routerAllCommReqsSatisfied
              // <=> { routerAllCommReqsSatisfied /\\ -routerAllCommReqsSatisfied = V- }
              //     -V[Router*Router]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Router cpt_Router))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Router*Router] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'ASY routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 200:28, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router] is antisymmetric'
              , 'message'       => 'routerAllCommReqsSatisfied[Router] is not antisymmetric'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied~ /\\ routerAllCommReqsSatisfied /\\ -I[Router]
              // <=> { routerAllCommReqsSatisfied is symmetric }
              //     routerAllCommReqsSatisfied /\\ routerAllCommReqsSatisfied /\\ -I[Router]
              // <=> { routerAllCommReqsSatisfied /\\ routerAllCommReqsSatisfied = routerAllCommReqsSatisfied }
              //     routerAllCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //      ,ECpl (EDcI cpt_Router)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerAllCommReqsSatisfied /\\\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`routerAllCommReqsSatisfied` AS `tgt`
                          FROM `Router` AS isect0
                          WHERE isect0.Router <> isect0.`routerAllCommReqsSatisfied` AND isect0.Router IS NOT NULL AND isect0.`routerAllCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'UNI routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 200:28, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router\\*Router] is univalent'
              , 'message'       => 'routerAllCommReqsSatisfied[Router\\*Router] is not univalent'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied~;routerAllCommReqsSatisfied /\\ -I[Router]
              // <=> { routerAllCommReqsSatisfied is symmetric }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //            ,EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //            )
              //      ,ECpl (EDcI cpt_Router)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerAllCommReqsSatisfied;routerAllCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`routerAllCommReqsSatisfied` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.Router
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ routerAllCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'INJ routerAllCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ |- I[Router]'
              , 'origin'        => 'line 200:28, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerAllCommReqsSatisfied[Router\\*Router] is injective'
              , 'message'       => 'routerAllCommReqsSatisfied[Router\\*Router] is not injective'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ |- I[Router])
              // <=> { remove |- }
              //     -(-(routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~) \\/ I[Router])
              // <=> { De Morgan }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied~ /\\ -I[Router]
              // <=> { routerAllCommReqsSatisfied is symmetric }
              //     routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //            ,EDcD rel_routerAllCommReqsSatisfiedRouterRouter
              //            )
              //      ,ECpl (EDcI cpt_Router)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerAllCommReqsSatisfied;routerAllCommReqsSatisfied /\\\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerAllCommReqsSatisfied;routerAllCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`routerAllCommReqsSatisfied` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerAllCommReqsSatisfied`=ECps1.Router
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'SYM routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied = routerNoCommReqsSatisfied~'
              , 'origin'        => 'line 208:27, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router] is symmetric'
              , 'message'       => 'routerNoCommReqsSatisfied[Router] is not symmetric'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied = routerNoCommReqsSatisfied~)
              // <=> { remove = }
              //     -((routerNoCommReqsSatisfied |- routerNoCommReqsSatisfied~) /\\ (routerNoCommReqsSatisfied~ |- routerNoCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied~) /\\ (-routerNoCommReqsSatisfied~ \\/ routerNoCommReqsSatisfied))
              // <=> { routerNoCommReqsSatisfied is symmetric and routerNoCommReqsSatisfied is symmetric }
              //     -((-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied) /\\ (-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied))
              // <=> { -routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied /\\ -routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied = -routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied }
              //     -(-routerNoCommReqsSatisfied \\/ routerNoCommReqsSatisfied)
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied /\\ -routerNoCommReqsSatisfied
              // <=> { routerNoCommReqsSatisfied /\\ -routerNoCommReqsSatisfied = V- }
              //     -V[Router*Router]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Router cpt_Router))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Router*Router] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'ASY routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 208:27, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router] is antisymmetric'
              , 'message'       => 'routerNoCommReqsSatisfied[Router] is not antisymmetric'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied~ /\\ routerNoCommReqsSatisfied /\\ -I[Router]
              // <=> { routerNoCommReqsSatisfied is symmetric }
              //     routerNoCommReqsSatisfied /\\ routerNoCommReqsSatisfied /\\ -I[Router]
              // <=> { routerNoCommReqsSatisfied /\\ routerNoCommReqsSatisfied = routerNoCommReqsSatisfied }
              //     routerNoCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //      ,ECpl (EDcI cpt_Router)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNoCommReqsSatisfied /\\\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`Router` AS `src`, isect0.`routerNoCommReqsSatisfied` AS `tgt`
                          FROM `Router` AS isect0
                          WHERE isect0.Router <> isect0.`routerNoCommReqsSatisfied` AND isect0.Router IS NOT NULL AND isect0.`routerNoCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'UNI routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied |- I[Router]'
              , 'origin'        => 'line 208:27, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router\\*Router] is univalent'
              , 'message'       => 'routerNoCommReqsSatisfied[Router\\*Router] is not univalent'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied |- I[Router])
              // <=> { remove |- }
              //     -(-(routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied) \\/ I[Router])
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied~;routerNoCommReqsSatisfied /\\ -I[Router]
              // <=> { routerNoCommReqsSatisfied is symmetric }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //            ,EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //            )
              //      ,ECpl (EDcI cpt_Router)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNoCommReqsSatisfied;routerNoCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`routerNoCommReqsSatisfied` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNoCommReqsSatisfied`=ECps1.Router
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ routerNoCommReqsSatisfied::Router*Router' =>
        array ( 'name'          => 'INJ routerNoCommReqsSatisfied::Router*Router'
              , 'ruleAdl'       => 'routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ |- I[Router]'
              , 'origin'        => 'line 208:27, file ".\\\\CSA_Op Process.adl"'
              , 'meaning'       => 'routerNoCommReqsSatisfied[Router\\*Router] is injective'
              , 'message'       => 'routerNoCommReqsSatisfied[Router\\*Router] is not injective'
              , 'srcConcept'    => 'Router'
              , 'tgtConcept'    => 'Router'
              // Normalization steps:
              //     -(routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ |- I[Router])
              // <=> { remove |- }
              //     -(-(routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~) \\/ I[Router])
              // <=> { De Morgan }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied~ /\\ -I[Router]
              // <=> { routerNoCommReqsSatisfied is symmetric }
              //     routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\ -I[Router]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //            ,EDcD rel_routerNoCommReqsSatisfiedRouterRouter
              //            )
              //      ,ECpl (EDcI cpt_Router)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNoCommReqsSatisfied;routerNoCommReqsSatisfied /\\\\ -I[Router] ([Router*Router]) */
                          SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtRouter` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNoCommReqsSatisfied;routerNoCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps1.`routerNoCommReqsSatisfied` AS `TgtRouter`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`routerNoCommReqsSatisfied`=ECps1.Router
                               ) AS isect0
                          WHERE isect0.`SrcRouter` <> isect0.`TgtRouter` AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtRouter` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'SYM nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied~'
              , 'origin'        => 'line 15:28, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network] is symmetric'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network] is not symmetric'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied~)
              // <=> { remove = }
              //     -((nwAllCompCommReqsSatisfied |- nwAllCompCommReqsSatisfied~) /\\ (nwAllCompCommReqsSatisfied~ |- nwAllCompCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied~) /\\ (-nwAllCompCommReqsSatisfied~ \\/ nwAllCompCommReqsSatisfied))
              // <=> { nwAllCompCommReqsSatisfied is symmetric and nwAllCompCommReqsSatisfied is symmetric }
              //     -((-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied) /\\ (-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied))
              // <=> { -nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied /\\ -nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied = -nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied }
              //     -(-nwAllCompCommReqsSatisfied \\/ nwAllCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied /\\ -nwAllCompCommReqsSatisfied
              // <=> { nwAllCompCommReqsSatisfied /\\ -nwAllCompCommReqsSatisfied = V- }
              //     -V[Network*Network]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Network cpt_Network))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Network*Network] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'ASY nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 15:28, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network] is antisymmetric'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network] is not antisymmetric'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied~ /\\ nwAllCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwAllCompCommReqsSatisfied is symmetric }
              //     nwAllCompCommReqsSatisfied /\\ nwAllCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwAllCompCommReqsSatisfied /\\ nwAllCompCommReqsSatisfied = nwAllCompCommReqsSatisfied }
              //     nwAllCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwAllCompCommReqsSatisfied /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`Network` AS `src`, isect0.`nwAllCompCommReqsSatisfied` AS `tgt`
                          FROM `Network` AS isect0
                          WHERE isect0.Network <> isect0.`nwAllCompCommReqsSatisfied` AND isect0.Network IS NOT NULL AND isect0.`nwAllCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'UNI nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 15:28, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is univalent'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is not univalent'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied~;nwAllCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwAllCompCommReqsSatisfied is symmetric }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //            ,EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //            )
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps1.`nwAllCompCommReqsSatisfied` AS `TgtNetwork`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwAllCompCommReqsSatisfied`=ECps1.Network
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ nwAllCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'INJ nwAllCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ |- I[Network]'
              , 'origin'        => 'line 15:28, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is injective'
              , 'message'       => 'nwAllCompCommReqsSatisfied[Network\\*Network] is not injective'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ |- I[Network])
              // <=> { remove |- }
              //     -(-(nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~) \\/ I[Network])
              // <=> { De Morgan }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied~ /\\ -I[Network]
              // <=> { nwAllCompCommReqsSatisfied is symmetric }
              //     nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //            ,EDcD rel_nwAllCompCommReqsSatisfiedNetworkNetwork
              //            )
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwAllCompCommReqsSatisfied;nwAllCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps1.`nwAllCompCommReqsSatisfied` AS `TgtNetwork`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwAllCompCommReqsSatisfied`=ECps1.Network
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'SYM nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied~'
              , 'origin'        => 'line 23:27, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network] is symmetric'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network] is not symmetric'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied~)
              // <=> { remove = }
              //     -((nwNoCompCommReqsSatisfied |- nwNoCompCommReqsSatisfied~) /\\ (nwNoCompCommReqsSatisfied~ |- nwNoCompCommReqsSatisfied))
              // <=> { remove |- and remove |- }
              //     -((-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied~) /\\ (-nwNoCompCommReqsSatisfied~ \\/ nwNoCompCommReqsSatisfied))
              // <=> { nwNoCompCommReqsSatisfied is symmetric and nwNoCompCommReqsSatisfied is symmetric }
              //     -((-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied) /\\ (-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied))
              // <=> { -nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied = -nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied }
              //     -(-nwNoCompCommReqsSatisfied \\/ nwNoCompCommReqsSatisfied)
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied
              // <=> { nwNoCompCommReqsSatisfied /\\ -nwNoCompCommReqsSatisfied = V- }
              //     -V[Network*Network]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Network cpt_Network))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Network*Network] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'ASY nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 23:27, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network] is antisymmetric'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network] is not antisymmetric'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied~ /\\ nwNoCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwNoCompCommReqsSatisfied is symmetric }
              //     nwNoCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwNoCompCommReqsSatisfied /\\ nwNoCompCommReqsSatisfied = nwNoCompCommReqsSatisfied }
              //     nwNoCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwNoCompCommReqsSatisfied /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`Network` AS `src`, isect0.`nwNoCompCommReqsSatisfied` AS `tgt`
                          FROM `Network` AS isect0
                          WHERE isect0.Network <> isect0.`nwNoCompCommReqsSatisfied` AND isect0.Network IS NOT NULL AND isect0.`nwNoCompCommReqsSatisfied` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'UNI nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied |- I[Network]'
              , 'origin'        => 'line 23:27, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is univalent'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is not univalent'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied |- I[Network])
              // <=> { remove |- }
              //     -(-(nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied) \\/ I[Network])
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied~;nwNoCompCommReqsSatisfied /\\ -I[Network]
              // <=> { nwNoCompCommReqsSatisfied is symmetric }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //            ,EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //            )
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps1.`nwNoCompCommReqsSatisfied` AS `TgtNetwork`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwNoCompCommReqsSatisfied`=ECps1.Network
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ nwNoCompCommReqsSatisfied::Network*Network' =>
        array ( 'name'          => 'INJ nwNoCompCommReqsSatisfied::Network*Network'
              , 'ruleAdl'       => 'nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ |- I[Network]'
              , 'origin'        => 'line 23:27, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is injective'
              , 'message'       => 'nwNoCompCommReqsSatisfied[Network\\*Network] is not injective'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ |- I[Network])
              // <=> { remove |- }
              //     -(-(nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~) \\/ I[Network])
              // <=> { De Morgan }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied~ /\\ -I[Network]
              // <=> { nwNoCompCommReqsSatisfied is symmetric }
              //     nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //            ,EDcD rel_nwNoCompCommReqsSatisfiedNetworkNetwork
              //            )
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwNoCompCommReqsSatisfied;nwNoCompCommReqsSatisfied */
                                 
                                 SELECT DISTINCT ECps0.`Network` AS `SrcNetwork`, ECps1.`nwNoCompCommReqsSatisfied` AS `TgtNetwork`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`nwNoCompCommReqsSatisfied`=ECps1.Network
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compCmpStat::Computer*Status' =>
        array ( 'name'          => 'UNI compCmpStat::Computer*Status'
              , 'ruleAdl'       => 'compCmpStat~;compCmpStat |- I[Status]'
              , 'origin'        => 'line 143:13, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'compCmpStat[Computer\\*Status] is univalent'
              , 'message'       => 'compCmpStat[Computer\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compCmpStat~;compCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(compCmpStat~;compCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     compCmpStat~;compCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_compCmpStatComputerStatus)
              //            ,EDcD rel_compCmpStatComputerStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compCmpStat~;compCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compCmpStat~;compCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`compCmpStat` AS `SrcStatus`, ECps1.`compCmpStat` AS `TgtStatus`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scCmpStat::SvcComponent*Status' =>
        array ( 'name'          => 'UNI scCmpStat::SvcComponent*Status'
              , 'ruleAdl'       => 'scCmpStat~;scCmpStat |- I[Status]'
              , 'origin'        => 'line 157:11, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'scCmpStat[SvcComponent\\*Status] is univalent'
              , 'message'       => 'scCmpStat[SvcComponent\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scCmpStat~;scCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(scCmpStat~;scCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     scCmpStat~;scCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_scCmpStatSvcComponentStatus)
              //            ,EDcD rel_scCmpStatSvcComponentStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             scCmpStat~;scCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scCmpStat~;scCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`scCmpStat` AS `SrcStatus`, ECps1.`scCmpStat` AS `TgtStatus`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI itsvcCmpStat::ITService*Status' =>
        array ( 'name'          => 'UNI itsvcCmpStat::ITService*Status'
              , 'ruleAdl'       => 'itsvcCmpStat~;itsvcCmpStat |- I[Status]'
              , 'origin'        => 'line 206:14, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'itsvcCmpStat[ITService\\*Status] is univalent'
              , 'message'       => 'itsvcCmpStat[ITService\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(itsvcCmpStat~;itsvcCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(itsvcCmpStat~;itsvcCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     itsvcCmpStat~;itsvcCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_itsvcCmpStatITServiceStatus)
              //            ,EDcD rel_itsvcCmpStatITServiceStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             itsvcCmpStat~;itsvcCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcCmpStat~;itsvcCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`itsvcCmpStat` AS `SrcStatus`, ECps1.`itsvcCmpStat` AS `TgtStatus`
                                 FROM `ITService` AS ECps0,
                                      `ITService` AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`ITService`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcCmpStat::Service*Status' =>
        array ( 'name'          => 'UNI svcCmpStat::Service*Status'
              , 'ruleAdl'       => 'svcCmpStat~;svcCmpStat |- I[Status]'
              , 'origin'        => 'line 223:12, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'svcCmpStat[Service\\*Status] is univalent'
              , 'message'       => 'svcCmpStat[Service\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(svcCmpStat~;svcCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(svcCmpStat~;svcCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     svcCmpStat~;svcCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_svcCmpStatServiceStatus)
              //            ,EDcD rel_svcCmpStatServiceStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             svcCmpStat~;svcCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcCmpStat~;svcCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`svcCmpStat` AS `SrcStatus`, ECps1.`svcCmpStat` AS `TgtStatus`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'SYM allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'allRequiredITAvailbleToOrgUnit = allRequiredITAvailbleToOrgUnit~'
              , 'origin'        => 'line 241:32, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit] is symmetric'
              , 'message'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit] is not symmetric'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(allRequiredITAvailbleToOrgUnit = allRequiredITAvailbleToOrgUnit~)
              // <=> { remove = }
              //     -((allRequiredITAvailbleToOrgUnit |- allRequiredITAvailbleToOrgUnit~) /\\ (allRequiredITAvailbleToOrgUnit~ |- allRequiredITAvailbleToOrgUnit))
              // <=> { remove |- and remove |- }
              //     -((-allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit~) /\\ (-allRequiredITAvailbleToOrgUnit~ \\/ allRequiredITAvailbleToOrgUnit))
              // <=> { allRequiredITAvailbleToOrgUnit is symmetric and allRequiredITAvailbleToOrgUnit is symmetric }
              //     -((-allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit) /\\ (-allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit))
              // <=> { -allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit = -allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit }
              //     -(-allRequiredITAvailbleToOrgUnit \\/ allRequiredITAvailbleToOrgUnit)
              // <=> { De Morgan }
              //     allRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit
              // <=> { allRequiredITAvailbleToOrgUnit /\\ -allRequiredITAvailbleToOrgUnit = V- }
              //     -V[OrgUnit*OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_OrgUnit cpt_OrgUnit))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [OrgUnit*OrgUnit] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'ASY allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'allRequiredITAvailbleToOrgUnit~ /\\ allRequiredITAvailbleToOrgUnit |- I[OrgUnit]'
              , 'origin'        => 'line 241:32, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit] is antisymmetric'
              , 'message'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit] is not antisymmetric'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(allRequiredITAvailbleToOrgUnit~ /\\ allRequiredITAvailbleToOrgUnit |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(allRequiredITAvailbleToOrgUnit~ /\\ allRequiredITAvailbleToOrgUnit) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     allRequiredITAvailbleToOrgUnit~ /\\ allRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // <=> { allRequiredITAvailbleToOrgUnit is symmetric }
              //     allRequiredITAvailbleToOrgUnit /\\ allRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // <=> { allRequiredITAvailbleToOrgUnit /\\ allRequiredITAvailbleToOrgUnit = allRequiredITAvailbleToOrgUnit }
              //     allRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             allRequiredITAvailbleToOrgUnit /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`allRequiredITAvailbleToOrgUnit` AS `tgt`
                          FROM `OrgUnit` AS isect0
                          WHERE isect0.OrgUnit <> isect0.`allRequiredITAvailbleToOrgUnit` AND isect0.OrgUnit IS NOT NULL AND isect0.`allRequiredITAvailbleToOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'UNI allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'allRequiredITAvailbleToOrgUnit~;allRequiredITAvailbleToOrgUnit |- I[OrgUnit]'
              , 'origin'        => 'line 241:32, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is univalent'
              , 'message'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is not univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(allRequiredITAvailbleToOrgUnit~;allRequiredITAvailbleToOrgUnit |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(allRequiredITAvailbleToOrgUnit~;allRequiredITAvailbleToOrgUnit) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     allRequiredITAvailbleToOrgUnit~;allRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // <=> { allRequiredITAvailbleToOrgUnit is symmetric }
              //     allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            ,EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit */
                                 
                                 SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps1.`allRequiredITAvailbleToOrgUnit` AS `TgtOrgUnit`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`allRequiredITAvailbleToOrgUnit`=ECps1.OrgUnit
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'INJ allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit~ |- I[OrgUnit]'
              , 'origin'        => 'line 241:32, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is injective'
              , 'message'       => 'allRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is not injective'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit~ |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit~) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit~ /\\ -I[OrgUnit]
              // <=> { allRequiredITAvailbleToOrgUnit is symmetric }
              //     allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            ,EDcD rel_allRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    allRequiredITAvailbleToOrgUnit;allRequiredITAvailbleToOrgUnit */
                                 
                                 SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps1.`allRequiredITAvailbleToOrgUnit` AS `TgtOrgUnit`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`allRequiredITAvailbleToOrgUnit`=ECps1.OrgUnit
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'SYM noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'noRequiredITAvailbleToOrgUnit = noRequiredITAvailbleToOrgUnit~'
              , 'origin'        => 'line 249:31, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit] is symmetric'
              , 'message'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit] is not symmetric'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(noRequiredITAvailbleToOrgUnit = noRequiredITAvailbleToOrgUnit~)
              // <=> { remove = }
              //     -((noRequiredITAvailbleToOrgUnit |- noRequiredITAvailbleToOrgUnit~) /\\ (noRequiredITAvailbleToOrgUnit~ |- noRequiredITAvailbleToOrgUnit))
              // <=> { remove |- and remove |- }
              //     -((-noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit~) /\\ (-noRequiredITAvailbleToOrgUnit~ \\/ noRequiredITAvailbleToOrgUnit))
              // <=> { noRequiredITAvailbleToOrgUnit is symmetric and noRequiredITAvailbleToOrgUnit is symmetric }
              //     -((-noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit) /\\ (-noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit))
              // <=> { -noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit /\\ -noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit = -noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit }
              //     -(-noRequiredITAvailbleToOrgUnit \\/ noRequiredITAvailbleToOrgUnit)
              // <=> { De Morgan }
              //     noRequiredITAvailbleToOrgUnit /\\ -noRequiredITAvailbleToOrgUnit
              // <=> { noRequiredITAvailbleToOrgUnit /\\ -noRequiredITAvailbleToOrgUnit = V- }
              //     -V[OrgUnit*OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_OrgUnit cpt_OrgUnit))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [OrgUnit*OrgUnit] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'ASY noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'noRequiredITAvailbleToOrgUnit~ /\\ noRequiredITAvailbleToOrgUnit |- I[OrgUnit]'
              , 'origin'        => 'line 249:31, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit] is antisymmetric'
              , 'message'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit] is not antisymmetric'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(noRequiredITAvailbleToOrgUnit~ /\\ noRequiredITAvailbleToOrgUnit |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(noRequiredITAvailbleToOrgUnit~ /\\ noRequiredITAvailbleToOrgUnit) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     noRequiredITAvailbleToOrgUnit~ /\\ noRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // <=> { noRequiredITAvailbleToOrgUnit is symmetric }
              //     noRequiredITAvailbleToOrgUnit /\\ noRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // <=> { noRequiredITAvailbleToOrgUnit /\\ noRequiredITAvailbleToOrgUnit = noRequiredITAvailbleToOrgUnit }
              //     noRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             noRequiredITAvailbleToOrgUnit /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`OrgUnit` AS `src`, isect0.`noRequiredITAvailbleToOrgUnit` AS `tgt`
                          FROM `OrgUnit` AS isect0
                          WHERE isect0.OrgUnit <> isect0.`noRequiredITAvailbleToOrgUnit` AND isect0.OrgUnit IS NOT NULL AND isect0.`noRequiredITAvailbleToOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'UNI noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'noRequiredITAvailbleToOrgUnit~;noRequiredITAvailbleToOrgUnit |- I[OrgUnit]'
              , 'origin'        => 'line 249:31, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is univalent'
              , 'message'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is not univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(noRequiredITAvailbleToOrgUnit~;noRequiredITAvailbleToOrgUnit |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(noRequiredITAvailbleToOrgUnit~;noRequiredITAvailbleToOrgUnit) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     noRequiredITAvailbleToOrgUnit~;noRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // <=> { noRequiredITAvailbleToOrgUnit is symmetric }
              //     noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            ,EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit */
                                 
                                 SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps1.`noRequiredITAvailbleToOrgUnit` AS `TgtOrgUnit`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`noRequiredITAvailbleToOrgUnit`=ECps1.OrgUnit
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'INJ noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit~ |- I[OrgUnit]'
              , 'origin'        => 'line 249:31, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is injective'
              , 'message'       => 'noRequiredITAvailbleToOrgUnit[OrgUnit\\*OrgUnit] is not injective'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit~ |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit~) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit~ /\\ -I[OrgUnit]
              // <=> { noRequiredITAvailbleToOrgUnit is symmetric }
              //     noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            ,EDcD rel_noRequiredITAvailbleToOrgUnitOrgUnitOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    noRequiredITAvailbleToOrgUnit;noRequiredITAvailbleToOrgUnit */
                                 
                                 SELECT DISTINCT ECps0.`OrgUnit` AS `SrcOrgUnit`, ECps1.`noRequiredITAvailbleToOrgUnit` AS `TgtOrgUnit`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`noRequiredITAvailbleToOrgUnit`=ECps1.OrgUnit
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI ouCmpStat::OrgUnit*Status' =>
        array ( 'name'          => 'UNI ouCmpStat::OrgUnit*Status'
              , 'ruleAdl'       => 'ouCmpStat~;ouCmpStat |- I[Status]'
              , 'origin'        => 'line 272:11, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'ouCmpStat[OrgUnit\\*Status] is univalent'
              , 'message'       => 'ouCmpStat[OrgUnit\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouCmpStat~;ouCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(ouCmpStat~;ouCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     ouCmpStat~;ouCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_ouCmpStatOrgUnitStatus)
              //            ,EDcD rel_ouCmpStatOrgUnitStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             ouCmpStat~;ouCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouCmpStat~;ouCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`ouCmpStat` AS `SrcStatus`, ECps1.`ouCmpStat` AS `TgtStatus`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actCmpStat::Activity*Status' =>
        array ( 'name'          => 'UNI actCmpStat::Activity*Status'
              , 'ruleAdl'       => 'actCmpStat~;actCmpStat |- I[Status]'
              , 'origin'        => 'line 321:12, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'actCmpStat[Activity\\*Status] is univalent'
              , 'message'       => 'actCmpStat[Activity\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actCmpStat~;actCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(actCmpStat~;actCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     actCmpStat~;actCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actCmpStatActivityStatus)
              //            ,EDcD rel_actCmpStatActivityStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actCmpStat~;actCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actCmpStat~;actCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`actCmpStat` AS `SrcStatus`, ECps1.`actCmpStat` AS `TgtStatus`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI resultCmpStat::Result*Status' =>
        array ( 'name'          => 'UNI resultCmpStat::Result*Status'
              , 'ruleAdl'       => 'resultCmpStat~;resultCmpStat |- I[Status]'
              , 'origin'        => 'line 351:15, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'resultCmpStat[Result\\*Status] is univalent'
              , 'message'       => 'resultCmpStat[Result\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(resultCmpStat~;resultCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(resultCmpStat~;resultCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     resultCmpStat~;resultCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_resultCmpStatResultStatus)
              //            ,EDcD rel_resultCmpStatResultStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             resultCmpStat~;resultCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    resultCmpStat~;resultCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`resultCmpStat` AS `SrcStatus`, ECps1.`resultCmpStat` AS `TgtStatus`
                                 FROM `Result` AS ECps0,
                                      `Result` AS ECps1
                                 WHERE ECps0.`Result`=ECps1.`Result`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM taskCmpStatIsRed::Task*Task' =>
        array ( 'name'          => 'SYM taskCmpStatIsRed::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsRed = taskCmpStatIsRed~'
              , 'origin'        => 'line 372:18, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsRed[Task] is symmetric'
              , 'message'       => 'taskCmpStatIsRed[Task] is not symmetric'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsRed = taskCmpStatIsRed~)
              // <=> { remove = }
              //     -((taskCmpStatIsRed |- taskCmpStatIsRed~) /\\ (taskCmpStatIsRed~ |- taskCmpStatIsRed))
              // <=> { remove |- and remove |- }
              //     -((-taskCmpStatIsRed \\/ taskCmpStatIsRed~) /\\ (-taskCmpStatIsRed~ \\/ taskCmpStatIsRed))
              // <=> { taskCmpStatIsRed is symmetric and taskCmpStatIsRed is symmetric }
              //     -((-taskCmpStatIsRed \\/ taskCmpStatIsRed) /\\ (-taskCmpStatIsRed \\/ taskCmpStatIsRed))
              // <=> { -taskCmpStatIsRed \\/ taskCmpStatIsRed /\\ -taskCmpStatIsRed \\/ taskCmpStatIsRed = -taskCmpStatIsRed \\/ taskCmpStatIsRed }
              //     -(-taskCmpStatIsRed \\/ taskCmpStatIsRed)
              // <=> { De Morgan }
              //     taskCmpStatIsRed /\\ -taskCmpStatIsRed
              // <=> { taskCmpStatIsRed /\\ -taskCmpStatIsRed = V- }
              //     -V[Task*Task]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Task cpt_Task))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Task*Task] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY taskCmpStatIsRed::Task*Task' =>
        array ( 'name'          => 'ASY taskCmpStatIsRed::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsRed~ /\\ taskCmpStatIsRed |- I[Task]'
              , 'origin'        => 'line 372:18, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsRed[Task] is antisymmetric'
              , 'message'       => 'taskCmpStatIsRed[Task] is not antisymmetric'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsRed~ /\\ taskCmpStatIsRed |- I[Task])
              // <=> { remove |- }
              //     -(-(taskCmpStatIsRed~ /\\ taskCmpStatIsRed) \\/ I[Task])
              // <=> { De Morgan }
              //     taskCmpStatIsRed~ /\\ taskCmpStatIsRed /\\ -I[Task]
              // <=> { taskCmpStatIsRed is symmetric }
              //     taskCmpStatIsRed /\\ taskCmpStatIsRed /\\ -I[Task]
              // <=> { taskCmpStatIsRed /\\ taskCmpStatIsRed = taskCmpStatIsRed }
              //     taskCmpStatIsRed /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_taskCmpStatIsRedTaskTask
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsRed /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`Task` AS `src`, isect0.`taskCmpStatIsRed` AS `tgt`
                          FROM `Task` AS isect0
                          WHERE isect0.Task <> isect0.`taskCmpStatIsRed` AND isect0.Task IS NOT NULL AND isect0.`taskCmpStatIsRed` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskCmpStatIsRed::Task*Task' =>
        array ( 'name'          => 'UNI taskCmpStatIsRed::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsRed~;taskCmpStatIsRed |- I[Task]'
              , 'origin'        => 'line 372:18, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsRed[Task\\*Task] is univalent'
              , 'message'       => 'taskCmpStatIsRed[Task\\*Task] is not univalent'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsRed~;taskCmpStatIsRed |- I[Task])
              // <=> { remove |- }
              //     -(-(taskCmpStatIsRed~;taskCmpStatIsRed) \\/ I[Task])
              // <=> { De Morgan }
              //     taskCmpStatIsRed~;taskCmpStatIsRed /\\ -I[Task]
              // <=> { taskCmpStatIsRed is symmetric }
              //     taskCmpStatIsRed;taskCmpStatIsRed /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_taskCmpStatIsRedTaskTask
              //            ,EDcD rel_taskCmpStatIsRedTaskTask
              //            )
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsRed;taskCmpStatIsRed /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskCmpStatIsRed;taskCmpStatIsRed */
                                 
                                 SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`taskCmpStatIsRed` AS `TgtTask`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`taskCmpStatIsRed`=ECps1.Task
                               ) AS isect0
                          WHERE isect0.`SrcTask` <> isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ taskCmpStatIsRed::Task*Task' =>
        array ( 'name'          => 'INJ taskCmpStatIsRed::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsRed;taskCmpStatIsRed~ |- I[Task]'
              , 'origin'        => 'line 372:18, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsRed[Task\\*Task] is injective'
              , 'message'       => 'taskCmpStatIsRed[Task\\*Task] is not injective'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsRed;taskCmpStatIsRed~ |- I[Task])
              // <=> { remove |- }
              //     -(-(taskCmpStatIsRed;taskCmpStatIsRed~) \\/ I[Task])
              // <=> { De Morgan }
              //     taskCmpStatIsRed;taskCmpStatIsRed~ /\\ -I[Task]
              // <=> { taskCmpStatIsRed is symmetric }
              //     taskCmpStatIsRed;taskCmpStatIsRed /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_taskCmpStatIsRedTaskTask
              //            ,EDcD rel_taskCmpStatIsRedTaskTask
              //            )
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsRed;taskCmpStatIsRed /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskCmpStatIsRed;taskCmpStatIsRed */
                                 
                                 SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`taskCmpStatIsRed` AS `TgtTask`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`taskCmpStatIsRed`=ECps1.Task
                               ) AS isect0
                          WHERE isect0.`SrcTask` <> isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM taskCmpStatIsGreen::Task*Task' =>
        array ( 'name'          => 'SYM taskCmpStatIsGreen::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsGreen = taskCmpStatIsGreen~'
              , 'origin'        => 'line 386:20, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsGreen[Task] is symmetric'
              , 'message'       => 'taskCmpStatIsGreen[Task] is not symmetric'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsGreen = taskCmpStatIsGreen~)
              // <=> { remove = }
              //     -((taskCmpStatIsGreen |- taskCmpStatIsGreen~) /\\ (taskCmpStatIsGreen~ |- taskCmpStatIsGreen))
              // <=> { remove |- and remove |- }
              //     -((-taskCmpStatIsGreen \\/ taskCmpStatIsGreen~) /\\ (-taskCmpStatIsGreen~ \\/ taskCmpStatIsGreen))
              // <=> { taskCmpStatIsGreen is symmetric and taskCmpStatIsGreen is symmetric }
              //     -((-taskCmpStatIsGreen \\/ taskCmpStatIsGreen) /\\ (-taskCmpStatIsGreen \\/ taskCmpStatIsGreen))
              // <=> { -taskCmpStatIsGreen \\/ taskCmpStatIsGreen /\\ -taskCmpStatIsGreen \\/ taskCmpStatIsGreen = -taskCmpStatIsGreen \\/ taskCmpStatIsGreen }
              //     -(-taskCmpStatIsGreen \\/ taskCmpStatIsGreen)
              // <=> { De Morgan }
              //     taskCmpStatIsGreen /\\ -taskCmpStatIsGreen
              // <=> { taskCmpStatIsGreen /\\ -taskCmpStatIsGreen = V- }
              //     -V[Task*Task]
              // 
              // Normalized complement (== violationsSQL): 
              // ECpl (EDcV (Sign cpt_Task cpt_Task))
              , 'violationsSQL' => '/* case: ECpl (EDcV _)  with signature [Task*Task] */
                          SELECT DISTINCT 1 AS `src`, 1 AS `tgt`
                          FROM (SELECT 1) AS a
                          WHERE 0'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY taskCmpStatIsGreen::Task*Task' =>
        array ( 'name'          => 'ASY taskCmpStatIsGreen::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsGreen~ /\\ taskCmpStatIsGreen |- I[Task]'
              , 'origin'        => 'line 386:20, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsGreen[Task] is antisymmetric'
              , 'message'       => 'taskCmpStatIsGreen[Task] is not antisymmetric'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsGreen~ /\\ taskCmpStatIsGreen |- I[Task])
              // <=> { remove |- }
              //     -(-(taskCmpStatIsGreen~ /\\ taskCmpStatIsGreen) \\/ I[Task])
              // <=> { De Morgan }
              //     taskCmpStatIsGreen~ /\\ taskCmpStatIsGreen /\\ -I[Task]
              // <=> { taskCmpStatIsGreen is symmetric }
              //     taskCmpStatIsGreen /\\ taskCmpStatIsGreen /\\ -I[Task]
              // <=> { taskCmpStatIsGreen /\\ taskCmpStatIsGreen = taskCmpStatIsGreen }
              //     taskCmpStatIsGreen /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcD rel_taskCmpStatIsGreenTaskTask
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsGreen /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`Task` AS `src`, isect0.`taskCmpStatIsGreen` AS `tgt`
                          FROM `Task` AS isect0
                          WHERE isect0.Task <> isect0.`taskCmpStatIsGreen` AND isect0.Task IS NOT NULL AND isect0.`taskCmpStatIsGreen` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskCmpStatIsGreen::Task*Task' =>
        array ( 'name'          => 'UNI taskCmpStatIsGreen::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsGreen~;taskCmpStatIsGreen |- I[Task]'
              , 'origin'        => 'line 386:20, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsGreen[Task\\*Task] is univalent'
              , 'message'       => 'taskCmpStatIsGreen[Task\\*Task] is not univalent'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsGreen~;taskCmpStatIsGreen |- I[Task])
              // <=> { remove |- }
              //     -(-(taskCmpStatIsGreen~;taskCmpStatIsGreen) \\/ I[Task])
              // <=> { De Morgan }
              //     taskCmpStatIsGreen~;taskCmpStatIsGreen /\\ -I[Task]
              // <=> { taskCmpStatIsGreen is symmetric }
              //     taskCmpStatIsGreen;taskCmpStatIsGreen /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_taskCmpStatIsGreenTaskTask
              //            ,EDcD rel_taskCmpStatIsGreenTaskTask
              //            )
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsGreen;taskCmpStatIsGreen /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskCmpStatIsGreen;taskCmpStatIsGreen */
                                 
                                 SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`taskCmpStatIsGreen` AS `TgtTask`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`taskCmpStatIsGreen`=ECps1.Task
                               ) AS isect0
                          WHERE isect0.`SrcTask` <> isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ taskCmpStatIsGreen::Task*Task' =>
        array ( 'name'          => 'INJ taskCmpStatIsGreen::Task*Task'
              , 'ruleAdl'       => 'taskCmpStatIsGreen;taskCmpStatIsGreen~ |- I[Task]'
              , 'origin'        => 'line 386:20, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStatIsGreen[Task\\*Task] is injective'
              , 'message'       => 'taskCmpStatIsGreen[Task\\*Task] is not injective'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(taskCmpStatIsGreen;taskCmpStatIsGreen~ |- I[Task])
              // <=> { remove |- }
              //     -(-(taskCmpStatIsGreen;taskCmpStatIsGreen~) \\/ I[Task])
              // <=> { De Morgan }
              //     taskCmpStatIsGreen;taskCmpStatIsGreen~ /\\ -I[Task]
              // <=> { taskCmpStatIsGreen is symmetric }
              //     taskCmpStatIsGreen;taskCmpStatIsGreen /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EDcD rel_taskCmpStatIsGreenTaskTask
              //            ,EDcD rel_taskCmpStatIsGreenTaskTask
              //            )
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStatIsGreen;taskCmpStatIsGreen /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskCmpStatIsGreen;taskCmpStatIsGreen */
                                 
                                 SELECT DISTINCT ECps0.`Task` AS `SrcTask`, ECps1.`taskCmpStatIsGreen` AS `TgtTask`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`taskCmpStatIsGreen`=ECps1.Task
                               ) AS isect0
                          WHERE isect0.`SrcTask` <> isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskCmpStat::Task*Status' =>
        array ( 'name'          => 'UNI taskCmpStat::Task*Status'
              , 'ruleAdl'       => 'taskCmpStat~;taskCmpStat |- I[Status]'
              , 'origin'        => 'line 412:13, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'taskCmpStat[Task\\*Status] is univalent'
              , 'message'       => 'taskCmpStat[Task\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(taskCmpStat~;taskCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(taskCmpStat~;taskCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     taskCmpStat~;taskCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_taskCmpStatTaskStatus)
              //            ,EDcD rel_taskCmpStatTaskStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskCmpStat~;taskCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskCmpStat~;taskCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`taskCmpStat` AS `SrcStatus`, ECps1.`taskCmpStat` AS `TgtStatus`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`Task`=ECps1.`Task`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI purposeCmpStat::Purpose*Status' =>
        array ( 'name'          => 'UNI purposeCmpStat::Purpose*Status'
              , 'ruleAdl'       => 'purposeCmpStat~;purposeCmpStat |- I[Status]'
              , 'origin'        => 'line 450:16, file ".\\\\CSA_Op Status.adl"'
              , 'meaning'       => 'purposeCmpStat[Purpose\\*Status] is univalent'
              , 'message'       => 'purposeCmpStat[Purpose\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(purposeCmpStat~;purposeCmpStat |- I[Status])
              // <=> { remove |- }
              //     -(-(purposeCmpStat~;purposeCmpStat) \\/ I[Status])
              // <=> { De Morgan }
              //     purposeCmpStat~;purposeCmpStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_purposeCmpStatPurposeStatus)
              //            ,EDcD rel_purposeCmpStatPurposeStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             purposeCmpStat~;purposeCmpStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    purposeCmpStat~;purposeCmpStat */
                                 
                                 SELECT DISTINCT ECps0.`purposeCmpStat` AS `SrcStatus`, ECps1.`purposeCmpStat` AS `TgtStatus`
                                 FROM `Purpose` AS ECps0,
                                      `Purpose` AS ECps1
                                 WHERE ECps0.`Purpose`=ECps1.`Purpose`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI purposeStatus::Purpose*Status' =>
        array ( 'name'          => 'UNI purposeStatus::Purpose*Status'
              , 'ruleAdl'       => 'purposeStatus~;purposeStatus |- I[Status]'
              , 'origin'        => 'line 4:15, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'purposeStatus[Purpose\\*Status] is univalent'
              , 'message'       => 'purposeStatus[Purpose\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(purposeStatus~;purposeStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(purposeStatus~;purposeStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     purposeStatus~;purposeStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_purposeStatusPurposeStatus)
              //            ,EDcD rel_purposeStatusPurposeStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             purposeStatus~;purposeStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    purposeStatus~;purposeStatus */
                                 
                                 SELECT DISTINCT ECps0.`purposeStatus` AS `SrcStatus`, ECps1.`purposeStatus` AS `TgtStatus`
                                 FROM `Purpose` AS ECps0,
                                      `Purpose` AS ECps1
                                 WHERE ECps0.`Purpose`=ECps1.`Purpose`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI purposeMnlStat::Purpose*Status' =>
        array ( 'name'          => 'UNI purposeMnlStat::Purpose*Status'
              , 'ruleAdl'       => 'purposeMnlStat~;purposeMnlStat |- I[Status]'
              , 'origin'        => 'line 6:16, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'purposeMnlStat[Purpose\\*Status] is univalent'
              , 'message'       => 'purposeMnlStat[Purpose\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(purposeMnlStat~;purposeMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(purposeMnlStat~;purposeMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     purposeMnlStat~;purposeMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_purposeMnlStatPurposeStatus)
              //            ,EDcD rel_purposeMnlStatPurposeStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             purposeMnlStat~;purposeMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    purposeMnlStat~;purposeMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`purposeMnlStat` AS `SrcStatus`, ECps1.`purposeMnlStat` AS `TgtStatus`
                                 FROM `Purpose` AS ECps0,
                                      `Purpose` AS ECps1
                                 WHERE ECps0.`Purpose`=ECps1.`Purpose`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskStatus::Task*Status' =>
        array ( 'name'          => 'UNI taskStatus::Task*Status'
              , 'ruleAdl'       => 'taskStatus~;taskStatus |- I[Status]'
              , 'origin'        => 'line 10:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'taskStatus[Task\\*Status] is univalent'
              , 'message'       => 'taskStatus[Task\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(taskStatus~;taskStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(taskStatus~;taskStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     taskStatus~;taskStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_taskStatusTaskStatus)
              //            ,EDcD rel_taskStatusTaskStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskStatus~;taskStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskStatus~;taskStatus */
                                 
                                 SELECT DISTINCT ECps0.`taskStatus` AS `SrcStatus`, ECps1.`taskStatus` AS `TgtStatus`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`Task`=ECps1.`Task`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskMnlStat::Task*Status' =>
        array ( 'name'          => 'UNI taskMnlStat::Task*Status'
              , 'ruleAdl'       => 'taskMnlStat~;taskMnlStat |- I[Status]'
              , 'origin'        => 'line 12:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'taskMnlStat[Task\\*Status] is univalent'
              , 'message'       => 'taskMnlStat[Task\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(taskMnlStat~;taskMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(taskMnlStat~;taskMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     taskMnlStat~;taskMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_taskMnlStatTaskStatus)
              //            ,EDcD rel_taskMnlStatTaskStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskMnlStat~;taskMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskMnlStat~;taskMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`taskMnlStat` AS `SrcStatus`, ECps1.`taskMnlStat` AS `TgtStatus`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`Task`=ECps1.`Task`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskEndTime::Task*Timestamp' =>
        array ( 'name'          => 'UNI taskEndTime::Task*Timestamp'
              , 'ruleAdl'       => 'taskEndTime~;taskEndTime |- I[Timestamp]'
              , 'origin'        => 'line 14:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'taskEndTime[Task\\*Timestamp] is univalent'
              , 'message'       => 'taskEndTime[Task\\*Timestamp] is not univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(taskEndTime~;taskEndTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(taskEndTime~;taskEndTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     taskEndTime~;taskEndTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_taskEndTimeTaskTimestamp)
              //            ,EDcD rel_taskEndTimeTaskTimestamp
              //            )
              //      ,ECpl (EDcI cpt_Timestamp)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskEndTime~;taskEndTime /\\\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS `src`, isect0.`TgtTimestamp` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskEndTime~;taskEndTime */
                                 
                                 SELECT DISTINCT ECps0.`taskEndTime` AS `SrcTimestamp`, ECps1.`taskEndTime` AS `TgtTimestamp`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`Task`=ECps1.`Task`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TgtTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TgtTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY isSubtaskOf::Task*Task' =>
        array ( 'name'          => 'ASY isSubtaskOf::Task*Task'
              , 'ruleAdl'       => 'isSubtaskOf~ /\\ isSubtaskOf |- I[Task]'
              , 'origin'        => 'line 16:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'isSubtaskOf[Task] is antisymmetric'
              , 'message'       => 'isSubtaskOf[Task] is not antisymmetric'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(isSubtaskOf~ /\\ isSubtaskOf |- I[Task])
              // <=> { remove |- }
              //     -(-(isSubtaskOf~ /\\ isSubtaskOf) \\/ I[Task])
              // <=> { De Morgan }
              //     isSubtaskOf~ /\\ isSubtaskOf /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EFlp (EDcD rel_isSubtaskOfTaskTask)
              //      ,EIsc (EDcD rel_isSubtaskOfTaskTask
              //            ,ECpl (EDcI cpt_Task)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             isSubtaskOf~ /\\\\ isSubtaskOf /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`TgtTask` AS `src`, isect0.`SrcTask` AS `tgt`
                          FROM `isSubtaskOf` AS isect0, 
                               `isSubtaskOf` AS isect1
                          WHERE (isect0.`TgtTask` = isect1.`SrcTask` AND isect0.`SrcTask` = isect1.`TgtTask`) AND isect0.`TgtTask` <> isect0.`SrcTask` AND isect0.`TgtTask` IS NOT NULL AND isect0.`SrcTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI taskOU::Task*OrgUnit' =>
        array ( 'name'          => 'UNI taskOU::Task*OrgUnit'
              , 'ruleAdl'       => 'taskOU~;taskOU |- I[OrgUnit]'
              , 'origin'        => 'line 26:8, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'taskOU[Task\\*OrgUnit] is univalent'
              , 'message'       => 'taskOU[Task\\*OrgUnit] is not univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(taskOU~;taskOU |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(taskOU~;taskOU) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     taskOU~;taskOU /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_taskOUTaskOrgUnit)
              //            ,EDcD rel_taskOUTaskOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             taskOU~;taskOU /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    taskOU~;taskOU */
                                 
                                 SELECT DISTINCT ECps0.`taskOU` AS `SrcOrgUnit`, ECps1.`taskOU` AS `TgtOrgUnit`
                                 FROM `Task` AS ECps0,
                                      `Task` AS ECps1
                                 WHERE ECps0.`Task`=ECps1.`Task`
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI resultStatus::Result*Status' =>
        array ( 'name'          => 'UNI resultStatus::Result*Status'
              , 'ruleAdl'       => 'resultStatus~;resultStatus |- I[Status]'
              , 'origin'        => 'line 32:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'resultStatus[Result\\*Status] is univalent'
              , 'message'       => 'resultStatus[Result\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(resultStatus~;resultStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(resultStatus~;resultStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     resultStatus~;resultStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_resultStatusResultStatus)
              //            ,EDcD rel_resultStatusResultStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             resultStatus~;resultStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    resultStatus~;resultStatus */
                                 
                                 SELECT DISTINCT ECps0.`resultStatus` AS `SrcStatus`, ECps1.`resultStatus` AS `TgtStatus`
                                 FROM `Result` AS ECps0,
                                      `Result` AS ECps1
                                 WHERE ECps0.`Result`=ECps1.`Result`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI resultMnlStat::Result*Status' =>
        array ( 'name'          => 'UNI resultMnlStat::Result*Status'
              , 'ruleAdl'       => 'resultMnlStat~;resultMnlStat |- I[Status]'
              , 'origin'        => 'line 34:15, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'resultMnlStat[Result\\*Status] is univalent'
              , 'message'       => 'resultMnlStat[Result\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(resultMnlStat~;resultMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(resultMnlStat~;resultMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     resultMnlStat~;resultMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_resultMnlStatResultStatus)
              //            ,EDcD rel_resultMnlStatResultStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             resultMnlStat~;resultMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    resultMnlStat~;resultMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`resultMnlStat` AS `SrcStatus`, ECps1.`resultMnlStat` AS `TgtStatus`
                                 FROM `Result` AS ECps0,
                                      `Result` AS ECps1
                                 WHERE ECps0.`Result`=ECps1.`Result`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI resultDeadline::Result*Timestamp' =>
        array ( 'name'          => 'UNI resultDeadline::Result*Timestamp'
              , 'ruleAdl'       => 'resultDeadline~;resultDeadline |- I[Timestamp]'
              , 'origin'        => 'line 37:16, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'resultDeadline[Result\\*Timestamp] is univalent'
              , 'message'       => 'resultDeadline[Result\\*Timestamp] is not univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(resultDeadline~;resultDeadline |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(resultDeadline~;resultDeadline) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     resultDeadline~;resultDeadline /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_resultDeadlineResultTimestamp)
              //            ,EDcD rel_resultDeadlineResultTimestamp
              //            )
              //      ,ECpl (EDcI cpt_Timestamp)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             resultDeadline~;resultDeadline /\\\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS `src`, isect0.`TgtTimestamp` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    resultDeadline~;resultDeadline */
                                 
                                 SELECT DISTINCT ECps0.`resultDeadline` AS `SrcTimestamp`, ECps1.`resultDeadline` AS `TgtTimestamp`
                                 FROM `Result` AS ECps0,
                                      `Result` AS ECps1
                                 WHERE ECps0.`Result`=ECps1.`Result`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TgtTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TgtTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcStatus::Service*Status' =>
        array ( 'name'          => 'UNI svcStatus::Service*Status'
              , 'ruleAdl'       => 'svcStatus~;svcStatus |- I[Status]'
              , 'origin'        => 'line 43:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'svcStatus[Service\\*Status] is univalent'
              , 'message'       => 'svcStatus[Service\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(svcStatus~;svcStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(svcStatus~;svcStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     svcStatus~;svcStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_svcStatusServiceStatus)
              //            ,EDcD rel_svcStatusServiceStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             svcStatus~;svcStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcStatus~;svcStatus */
                                 
                                 SELECT DISTINCT ECps0.`svcStatus` AS `SrcStatus`, ECps1.`svcStatus` AS `TgtStatus`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actStatus::Activity*Status' =>
        array ( 'name'          => 'UNI actStatus::Activity*Status'
              , 'ruleAdl'       => 'actStatus~;actStatus |- I[Status]'
              , 'origin'        => 'line 46:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actStatus[Activity\\*Status] is univalent'
              , 'message'       => 'actStatus[Activity\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actStatus~;actStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(actStatus~;actStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     actStatus~;actStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actStatusActivityStatus)
              //            ,EDcD rel_actStatusActivityStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actStatus~;actStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actStatus~;actStatus */
                                 
                                 SELECT DISTINCT ECps0.`actStatus` AS `SrcStatus`, ECps1.`actStatus` AS `TgtStatus`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actMnlStat::Activity*Status' =>
        array ( 'name'          => 'UNI actMnlStat::Activity*Status'
              , 'ruleAdl'       => 'actMnlStat~;actMnlStat |- I[Status]'
              , 'origin'        => 'line 48:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actMnlStat[Activity\\*Status] is univalent'
              , 'message'       => 'actMnlStat[Activity\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(actMnlStat~;actMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(actMnlStat~;actMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     actMnlStat~;actMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actMnlStatActivityStatus)
              //            ,EDcD rel_actMnlStatActivityStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actMnlStat~;actMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actMnlStat~;actMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`actMnlStat` AS `SrcStatus`, ECps1.`actMnlStat` AS `TgtStatus`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actResult::Activity*Result' =>
        array ( 'name'          => 'UNI actResult::Activity*Result'
              , 'ruleAdl'       => 'actResult~;actResult |- I[Result]'
              , 'origin'        => 'line 51:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actResult[Activity\\*Result] is univalent'
              , 'message'       => 'actResult[Activity\\*Result] is not univalent'
              , 'srcConcept'    => 'Result'
              , 'tgtConcept'    => 'Result'
              // Normalization steps:
              //     -(actResult~;actResult |- I[Result])
              // <=> { remove |- }
              //     -(-(actResult~;actResult) \\/ I[Result])
              // <=> { De Morgan }
              //     actResult~;actResult /\\ -I[Result]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actResultActivityResult)
              //            ,EDcD rel_actResultActivityResult
              //            )
              //      ,ECpl (EDcI cpt_Result)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actResult~;actResult /\\\\ -I[Result] ([Result*Result]) */
                          SELECT DISTINCT isect0.`SrcResult` AS `src`, isect0.`TgtResult` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actResult~;actResult */
                                 
                                 SELECT DISTINCT ECps0.`actResult` AS `SrcResult`, ECps1.`actResult` AS `TgtResult`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcResult` <> isect0.`TgtResult` AND isect0.`SrcResult` IS NOT NULL AND isect0.`TgtResult` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actTask::Activity*Task' =>
        array ( 'name'          => 'UNI actTask::Activity*Task'
              , 'ruleAdl'       => 'actTask~;actTask |- I[Task]'
              , 'origin'        => 'line 53:9, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actTask[Activity\\*Task] is univalent'
              , 'message'       => 'actTask[Activity\\*Task] is not univalent'
              , 'srcConcept'    => 'Task'
              , 'tgtConcept'    => 'Task'
              // Normalization steps:
              //     -(actTask~;actTask |- I[Task])
              // <=> { remove |- }
              //     -(-(actTask~;actTask) \\/ I[Task])
              // <=> { De Morgan }
              //     actTask~;actTask /\\ -I[Task]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actTaskActivityTask)
              //            ,EDcD rel_actTaskActivityTask
              //            )
              //      ,ECpl (EDcI cpt_Task)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actTask~;actTask /\\\\ -I[Task] ([Task*Task]) */
                          SELECT DISTINCT isect0.`SrcTask` AS `src`, isect0.`TgtTask` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actTask~;actTask */
                                 
                                 SELECT DISTINCT ECps0.`actTask` AS `SrcTask`, ECps1.`actTask` AS `TgtTask`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcTask` <> isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT actTask::Activity*Task' =>
        array ( 'name'          => 'TOT actTask::Activity*Task'
              , 'ruleAdl'       => 'I[Activity] |- actTask;actTask~'
              , 'origin'        => 'line 53:9, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actTask[Activity\\*Task] is total'
              , 'message'       => 'actTask[Activity\\*Task] is not total'
              , 'srcConcept'    => 'Activity'
              , 'tgtConcept'    => 'Activity'
              // Normalization steps:
              //     -(I[Activity] |- actTask;actTask~)
              // <=> { remove |- }
              //     -(-I[Activity] \\/ actTask;actTask~)
              // <=> { De Morgan }
              //     I[Activity] /\\ -(actTask;actTask~)
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EDcI cpt_Activity
              //      ,ECpl (ECps (EDcD rel_actTaskActivityTask
              //                  ,EFlp (EDcD rel_actTaskActivityTask)
              //                  ))
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             I[Activity] /\\\\ -(actTask;actTask~) ([Activity*Activity]) */
                          SELECT DISTINCT isect0.`Activity` AS `src`, isect0.`Activity` AS `tgt`
                          FROM ( /* Case EDcI Activity */
                                 SELECT `Activity` AS `Activity`
                                 FROM `Activity` ) AS isect0
                          WHERE NOT EXISTS (SELECT * FROM 
                                            ( /* case: (ECps es), with two or more elements in es.
                                                 actTask;actTask~ */
                                              
                                              SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                              FROM `Activity` AS ECps0,
                                                   `Activity` AS ECps1
                                              WHERE ECps0.`actTask`=ECps1.`actTask`
                                            ) AS cp
                                            WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actExecutingOU::Activity*OrgUnit' =>
        array ( 'name'          => 'UNI actExecutingOU::Activity*OrgUnit'
              , 'ruleAdl'       => 'actExecutingOU~;actExecutingOU |- I[OrgUnit]'
              , 'origin'        => 'line 55:16, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actExecutingOU[Activity\\*OrgUnit] is univalent'
              , 'message'       => 'actExecutingOU[Activity\\*OrgUnit] is not univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(actExecutingOU~;actExecutingOU |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(actExecutingOU~;actExecutingOU) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     actExecutingOU~;actExecutingOU /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actExecutingOUActivityOrgUnit)
              //            ,EDcD rel_actExecutingOUActivityOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actExecutingOU~;actExecutingOU /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actExecutingOU~;actExecutingOU */
                                 
                                 SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`actExecutingOU` AS `TgtOrgUnit`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actPlannedStartTime::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actPlannedStartTime::Activity*Timestamp'
              , 'ruleAdl'       => 'actPlannedStartTime~;actPlannedStartTime |- I[Timestamp]'
              , 'origin'        => 'line 61:21, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actPlannedStartTime[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actPlannedStartTime[Activity\\*Timestamp] is not univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actPlannedStartTime~;actPlannedStartTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actPlannedStartTime~;actPlannedStartTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actPlannedStartTime~;actPlannedStartTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actPlannedStartTimeActivityTimestamp)
              //            ,EDcD rel_actPlannedStartTimeActivityTimestamp
              //            )
              //      ,ECpl (EDcI cpt_Timestamp)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actPlannedStartTime~;actPlannedStartTime /\\\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS `src`, isect0.`TgtTimestamp` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlannedStartTime~;actPlannedStartTime */
                                 
                                 SELECT DISTINCT ECps0.`actPlannedStartTime` AS `SrcTimestamp`, ECps1.`actPlannedStartTime` AS `TgtTimestamp`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TgtTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TgtTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actPlannedEndTime::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actPlannedEndTime::Activity*Timestamp'
              , 'ruleAdl'       => 'actPlannedEndTime~;actPlannedEndTime |- I[Timestamp]'
              , 'origin'        => 'line 63:19, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actPlannedEndTime[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actPlannedEndTime[Activity\\*Timestamp] is not univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actPlannedEndTime~;actPlannedEndTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actPlannedEndTime~;actPlannedEndTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actPlannedEndTime~;actPlannedEndTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actPlannedEndTimeActivityTimestamp)
              //            ,EDcD rel_actPlannedEndTimeActivityTimestamp
              //            )
              //      ,ECpl (EDcI cpt_Timestamp)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actPlannedEndTime~;actPlannedEndTime /\\\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS `src`, isect0.`TgtTimestamp` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actPlannedEndTime~;actPlannedEndTime */
                                 
                                 SELECT DISTINCT ECps0.`actPlannedEndTime` AS `SrcTimestamp`, ECps1.`actPlannedEndTime` AS `TgtTimestamp`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TgtTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TgtTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actStartTime::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actStartTime::Activity*Timestamp'
              , 'ruleAdl'       => 'actStartTime~;actStartTime |- I[Timestamp]'
              , 'origin'        => 'line 65:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actStartTime[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actStartTime[Activity\\*Timestamp] is not univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actStartTime~;actStartTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actStartTime~;actStartTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actStartTime~;actStartTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actStartTimeActivityTimestamp)
              //            ,EDcD rel_actStartTimeActivityTimestamp
              //            )
              //      ,ECpl (EDcI cpt_Timestamp)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actStartTime~;actStartTime /\\\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS `src`, isect0.`TgtTimestamp` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actStartTime~;actStartTime */
                                 
                                 SELECT DISTINCT ECps0.`actStartTime` AS `SrcTimestamp`, ECps1.`actStartTime` AS `TgtTimestamp`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TgtTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TgtTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI actEndTime::Activity*Timestamp' =>
        array ( 'name'          => 'UNI actEndTime::Activity*Timestamp'
              , 'ruleAdl'       => 'actEndTime~;actEndTime |- I[Timestamp]'
              , 'origin'        => 'line 67:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'actEndTime[Activity\\*Timestamp] is univalent'
              , 'message'       => 'actEndTime[Activity\\*Timestamp] is not univalent'
              , 'srcConcept'    => 'Timestamp'
              , 'tgtConcept'    => 'Timestamp'
              // Normalization steps:
              //     -(actEndTime~;actEndTime |- I[Timestamp])
              // <=> { remove |- }
              //     -(-(actEndTime~;actEndTime) \\/ I[Timestamp])
              // <=> { De Morgan }
              //     actEndTime~;actEndTime /\\ -I[Timestamp]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_actEndTimeActivityTimestamp)
              //            ,EDcD rel_actEndTimeActivityTimestamp
              //            )
              //      ,ECpl (EDcI cpt_Timestamp)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             actEndTime~;actEndTime /\\\\ -I[Timestamp] ([Timestamp*Timestamp]) */
                          SELECT DISTINCT isect0.`SrcTimestamp` AS `src`, isect0.`TgtTimestamp` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    actEndTime~;actEndTime */
                                 
                                 SELECT DISTINCT ECps0.`actEndTime` AS `SrcTimestamp`, ECps1.`actEndTime` AS `TgtTimestamp`
                                 FROM `Activity` AS ECps0,
                                      `Activity` AS ECps1
                                 WHERE ECps0.`Activity`=ECps1.`Activity`
                               ) AS isect0
                          WHERE isect0.`SrcTimestamp` <> isect0.`TgtTimestamp` AND isect0.`SrcTimestamp` IS NOT NULL AND isect0.`TgtTimestamp` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI ouStatus::OrgUnit*Status' =>
        array ( 'name'          => 'UNI ouStatus::OrgUnit*Status'
              , 'ruleAdl'       => 'ouStatus~;ouStatus |- I[Status]'
              , 'origin'        => 'line 74:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'ouStatus[OrgUnit\\*Status] is univalent'
              , 'message'       => 'ouStatus[OrgUnit\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouStatus~;ouStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(ouStatus~;ouStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     ouStatus~;ouStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_ouStatusOrgUnitStatus)
              //            ,EDcD rel_ouStatusOrgUnitStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             ouStatus~;ouStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouStatus~;ouStatus */
                                 
                                 SELECT DISTINCT ECps0.`ouStatus` AS `SrcStatus`, ECps1.`ouStatus` AS `TgtStatus`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI ouMnlStat::OrgUnit*Status' =>
        array ( 'name'          => 'UNI ouMnlStat::OrgUnit*Status'
              , 'ruleAdl'       => 'ouMnlStat~;ouMnlStat |- I[Status]'
              , 'origin'        => 'line 76:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'ouMnlStat[OrgUnit\\*Status] is univalent'
              , 'message'       => 'ouMnlStat[OrgUnit\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(ouMnlStat~;ouMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(ouMnlStat~;ouMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     ouMnlStat~;ouMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_ouMnlStatOrgUnitStatus)
              //            ,EDcD rel_ouMnlStatOrgUnitStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             ouMnlStat~;ouMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    ouMnlStat~;ouMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`ouMnlStat` AS `SrcStatus`, ECps1.`ouMnlStat` AS `TgtStatus`
                                 FROM `OrgUnit` AS ECps0,
                                      `OrgUnit` AS ECps1
                                 WHERE ECps0.`OrgUnit`=ECps1.`OrgUnit`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY isSubUnitOf::OrgUnit*OrgUnit' =>
        array ( 'name'          => 'ASY isSubUnitOf::OrgUnit*OrgUnit'
              , 'ruleAdl'       => 'isSubUnitOf~ /\\ isSubUnitOf |- I[OrgUnit]'
              , 'origin'        => 'line 79:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'isSubUnitOf[OrgUnit] is antisymmetric'
              , 'message'       => 'isSubUnitOf[OrgUnit] is not antisymmetric'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(isSubUnitOf~ /\\ isSubUnitOf |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(isSubUnitOf~ /\\ isSubUnitOf) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     isSubUnitOf~ /\\ isSubUnitOf /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (EFlp (EDcD rel_isSubUnitOfOrgUnitOrgUnit)
              //      ,EIsc (EDcD rel_isSubUnitOfOrgUnitOrgUnit
              //            ,ECpl (EDcI cpt_OrgUnit)
              //            )
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             isSubUnitOf~ /\\\\ isSubUnitOf /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`TgtOrgUnit` AS `src`, isect0.`SrcOrgUnit` AS `tgt`
                          FROM `isSubUnitOf` AS isect0, 
                               `isSubUnitOf` AS isect1
                          WHERE (isect0.`TgtOrgUnit` = isect1.`SrcOrgUnit` AND isect0.`SrcOrgUnit` = isect1.`TgtOrgUnit`) AND isect0.`TgtOrgUnit` <> isect0.`SrcOrgUnit` AND isect0.`TgtOrgUnit` IS NOT NULL AND isect0.`SrcOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI svcMnlStat::Service*Status' =>
        array ( 'name'          => 'UNI svcMnlStat::Service*Status'
              , 'ruleAdl'       => 'svcMnlStat~;svcMnlStat |- I[Status]'
              , 'origin'        => 'line 85:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'svcMnlStat[Service\\*Status] is univalent'
              , 'message'       => 'svcMnlStat[Service\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(svcMnlStat~;svcMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(svcMnlStat~;svcMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     svcMnlStat~;svcMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_svcMnlStatServiceStatus)
              //            ,EDcD rel_svcMnlStatServiceStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             svcMnlStat~;svcMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    svcMnlStat~;svcMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`svcMnlStat` AS `SrcStatus`, ECps1.`svcMnlStat` AS `TgtStatus`
                                 FROM `Service` AS ECps0,
                                      `Service` AS ECps1
                                 WHERE ECps0.`Service`=ECps1.`Service`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI itsvcStatus::ITService*Status' =>
        array ( 'name'          => 'UNI itsvcStatus::ITService*Status'
              , 'ruleAdl'       => 'itsvcStatus~;itsvcStatus |- I[Status]'
              , 'origin'        => 'line 91:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'itsvcStatus[ITService\\*Status] is univalent'
              , 'message'       => 'itsvcStatus[ITService\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(itsvcStatus~;itsvcStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(itsvcStatus~;itsvcStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     itsvcStatus~;itsvcStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_itsvcStatusITServiceStatus)
              //            ,EDcD rel_itsvcStatusITServiceStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             itsvcStatus~;itsvcStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcStatus~;itsvcStatus */
                                 
                                 SELECT DISTINCT ECps0.`itsvcStatus` AS `SrcStatus`, ECps1.`itsvcStatus` AS `TgtStatus`
                                 FROM `ITService` AS ECps0,
                                      `ITService` AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`ITService`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI itsvcMnlStat::ITService*Status' =>
        array ( 'name'          => 'UNI itsvcMnlStat::ITService*Status'
              , 'ruleAdl'       => 'itsvcMnlStat~;itsvcMnlStat |- I[Status]'
              , 'origin'        => 'line 93:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'itsvcMnlStat[ITService\\*Status] is univalent'
              , 'message'       => 'itsvcMnlStat[ITService\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(itsvcMnlStat~;itsvcMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(itsvcMnlStat~;itsvcMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     itsvcMnlStat~;itsvcMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_itsvcMnlStatITServiceStatus)
              //            ,EDcD rel_itsvcMnlStatITServiceStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             itsvcMnlStat~;itsvcMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    itsvcMnlStat~;itsvcMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`itsvcMnlStat` AS `SrcStatus`, ECps1.`itsvcMnlStat` AS `TgtStatus`
                                 FROM `ITService` AS ECps0,
                                      `ITService` AS ECps1
                                 WHERE ECps0.`ITService`=ECps1.`ITService`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scStatus::SvcComponent*Status' =>
        array ( 'name'          => 'UNI scStatus::SvcComponent*Status'
              , 'ruleAdl'       => 'scStatus~;scStatus |- I[Status]'
              , 'origin'        => 'line 100:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'scStatus[SvcComponent\\*Status] is univalent'
              , 'message'       => 'scStatus[SvcComponent\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scStatus~;scStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(scStatus~;scStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     scStatus~;scStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_scStatusSvcComponentStatus)
              //            ,EDcD rel_scStatusSvcComponentStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             scStatus~;scStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scStatus~;scStatus */
                                 
                                 SELECT DISTINCT ECps0.`scStatus` AS `SrcStatus`, ECps1.`scStatus` AS `TgtStatus`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI scMnlStat::SvcComponent*Status' =>
        array ( 'name'          => 'UNI scMnlStat::SvcComponent*Status'
              , 'ruleAdl'       => 'scMnlStat~;scMnlStat |- I[Status]'
              , 'origin'        => 'line 102:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'scMnlStat[SvcComponent\\*Status] is univalent'
              , 'message'       => 'scMnlStat[SvcComponent\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(scMnlStat~;scMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(scMnlStat~;scMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     scMnlStat~;scMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_scMnlStatSvcComponentStatus)
              //            ,EDcD rel_scMnlStatSvcComponentStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             scMnlStat~;scMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    scMnlStat~;scMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`scMnlStat` AS `SrcStatus`, ECps1.`scMnlStat` AS `TgtStatus`
                                 FROM `SvcComponent` AS ECps0,
                                      `SvcComponent` AS ECps1
                                 WHERE ECps0.`SvcComponent`=ECps1.`SvcComponent`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compStatus::Computer*Status' =>
        array ( 'name'          => 'UNI compStatus::Computer*Status'
              , 'ruleAdl'       => 'compStatus~;compStatus |- I[Status]'
              , 'origin'        => 'line 121:12, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compStatus[Computer\\*Status] is univalent'
              , 'message'       => 'compStatus[Computer\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compStatus~;compStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(compStatus~;compStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     compStatus~;compStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_compStatusComputerStatus)
              //            ,EDcD rel_compStatusComputerStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compStatus~;compStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compStatus~;compStatus */
                                 
                                 SELECT DISTINCT ECps0.`compStatus` AS `SrcStatus`, ECps1.`compStatus` AS `TgtStatus`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compMnlStat::Computer*Status' =>
        array ( 'name'          => 'UNI compMnlStat::Computer*Status'
              , 'ruleAdl'       => 'compMnlStat~;compMnlStat |- I[Status]'
              , 'origin'        => 'line 123:13, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compMnlStat[Computer\\*Status] is univalent'
              , 'message'       => 'compMnlStat[Computer\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(compMnlStat~;compMnlStat |- I[Status])
              // <=> { remove |- }
              //     -(-(compMnlStat~;compMnlStat) \\/ I[Status])
              // <=> { De Morgan }
              //     compMnlStat~;compMnlStat /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_compMnlStatComputerStatus)
              //            ,EDcD rel_compMnlStatComputerStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compMnlStat~;compMnlStat /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compMnlStat~;compMnlStat */
                                 
                                 SELECT DISTINCT ECps0.`compMnlStat` AS `SrcStatus`, ECps1.`compMnlStat` AS `TgtStatus`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI compOwner::Computer*OrgUnit' =>
        array ( 'name'          => 'UNI compOwner::Computer*OrgUnit'
              , 'ruleAdl'       => 'compOwner~;compOwner |- I[OrgUnit]'
              , 'origin'        => 'line 126:11, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'compOwner[Computer\\*OrgUnit] is univalent'
              , 'message'       => 'compOwner[Computer\\*OrgUnit] is not univalent'
              , 'srcConcept'    => 'OrgUnit'
              , 'tgtConcept'    => 'OrgUnit'
              // Normalization steps:
              //     -(compOwner~;compOwner |- I[OrgUnit])
              // <=> { remove |- }
              //     -(-(compOwner~;compOwner) \\/ I[OrgUnit])
              // <=> { De Morgan }
              //     compOwner~;compOwner /\\ -I[OrgUnit]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_compOwnerComputerOrgUnit)
              //            ,EDcD rel_compOwnerComputerOrgUnit
              //            )
              //      ,ECpl (EDcI cpt_OrgUnit)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             compOwner~;compOwner /\\\\ -I[OrgUnit] ([OrgUnit*OrgUnit]) */
                          SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    compOwner~;compOwner */
                                 
                                 SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`compOwner` AS `TgtOrgUnit`
                                 FROM `Computer` AS ECps0,
                                      `Computer` AS ECps1
                                 WHERE ECps0.`Computer`=ECps1.`Computer`
                               ) AS isect0
                          WHERE isect0.`SrcOrgUnit` <> isect0.`TgtOrgUnit` AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerStatus::Router*Status' =>
        array ( 'name'          => 'UNI routerStatus::Router*Status'
              , 'ruleAdl'       => 'routerStatus~;routerStatus |- I[Status]'
              , 'origin'        => 'line 137:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'routerStatus[Router\\*Status] is univalent'
              , 'message'       => 'routerStatus[Router\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(routerStatus~;routerStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(routerStatus~;routerStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     routerStatus~;routerStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_routerStatusRouterStatus)
              //            ,EDcD rel_routerStatusRouterStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerStatus~;routerStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerStatus~;routerStatus */
                                 
                                 SELECT DISTINCT ECps0.`routerStatus` AS `SrcStatus`, ECps1.`routerStatus` AS `TgtStatus`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerSerial::Router*SerialNumber' =>
        array ( 'name'          => 'UNI routerSerial::Router*SerialNumber'
              , 'ruleAdl'       => 'routerSerial~;routerSerial |- I[SerialNumber]'
              , 'origin'        => 'line 138:14, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'routerSerial[Router\\*SerialNumber] is univalent'
              , 'message'       => 'routerSerial[Router\\*SerialNumber] is not univalent'
              , 'srcConcept'    => 'SerialNumber'
              , 'tgtConcept'    => 'SerialNumber'
              // Normalization steps:
              //     -(routerSerial~;routerSerial |- I[SerialNumber])
              // <=> { remove |- }
              //     -(-(routerSerial~;routerSerial) \\/ I[SerialNumber])
              // <=> { De Morgan }
              //     routerSerial~;routerSerial /\\ -I[SerialNumber]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_routerSerialRouterSerialNumber)
              //            ,EDcD rel_routerSerialRouterSerialNumber
              //            )
              //      ,ECpl (EDcI cpt_SerialNumber)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerSerial~;routerSerial /\\\\ -I[SerialNumber] ([SerialNumber*SerialNumber]) */
                          SELECT DISTINCT isect0.`SrcSerialNumber` AS `src`, isect0.`TgtSerialNumber` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerSerial~;routerSerial */
                                 
                                 SELECT DISTINCT ECps0.`routerSerial` AS `SrcSerialNumber`, ECps1.`routerSerial` AS `TgtSerialNumber`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`SrcSerialNumber` <> isect0.`TgtSerialNumber` AND isect0.`SrcSerialNumber` IS NOT NULL AND isect0.`TgtSerialNumber` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerLocation::Router*Location' =>
        array ( 'name'          => 'UNI routerLocation::Router*Location'
              , 'ruleAdl'       => 'routerLocation~;routerLocation |- I[Location]'
              , 'origin'        => 'line 139:16, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'routerLocation[Router\\*Location] is univalent'
              , 'message'       => 'routerLocation[Router\\*Location] is not univalent'
              , 'srcConcept'    => 'Location'
              , 'tgtConcept'    => 'Location'
              // Normalization steps:
              //     -(routerLocation~;routerLocation |- I[Location])
              // <=> { remove |- }
              //     -(-(routerLocation~;routerLocation) \\/ I[Location])
              // <=> { De Morgan }
              //     routerLocation~;routerLocation /\\ -I[Location]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_routerLocationRouterLocation)
              //            ,EDcD rel_routerLocationRouterLocation
              //            )
              //      ,ECpl (EDcI cpt_Location)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerLocation~;routerLocation /\\\\ -I[Location] ([Location*Location]) */
                          SELECT DISTINCT isect0.`SrcLocation` AS `src`, isect0.`TgtLocation` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerLocation~;routerLocation */
                                 
                                 SELECT DISTINCT ECps0.`routerLocation` AS `SrcLocation`, ECps1.`routerLocation` AS `TgtLocation`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`SrcLocation` <> isect0.`TgtLocation` AND isect0.`SrcLocation` IS NOT NULL AND isect0.`TgtLocation` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI routerNW::Router*Network' =>
        array ( 'name'          => 'UNI routerNW::Router*Network'
              , 'ruleAdl'       => 'routerNW~;routerNW |- I[Network]'
              , 'origin'        => 'line 140:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'routerNW[Router\\*Network] is univalent'
              , 'message'       => 'routerNW[Router\\*Network] is not univalent'
              , 'srcConcept'    => 'Network'
              , 'tgtConcept'    => 'Network'
              // Normalization steps:
              //     -(routerNW~;routerNW |- I[Network])
              // <=> { remove |- }
              //     -(-(routerNW~;routerNW) \\/ I[Network])
              // <=> { De Morgan }
              //     routerNW~;routerNW /\\ -I[Network]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_routerNWRouterNetwork)
              //            ,EDcD rel_routerNWRouterNetwork
              //            )
              //      ,ECpl (EDcI cpt_Network)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             routerNW~;routerNW /\\\\ -I[Network] ([Network*Network]) */
                          SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    routerNW~;routerNW */
                                 
                                 SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps1.`routerNW` AS `TgtNetwork`
                                 FROM `Router` AS ECps0,
                                      `Router` AS ECps1
                                 WHERE ECps0.`Router`=ECps1.`Router`
                               ) AS isect0
                          WHERE isect0.`SrcNetwork` <> isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI nwStatus::Network*Status' =>
        array ( 'name'          => 'UNI nwStatus::Network*Status'
              , 'ruleAdl'       => 'nwStatus~;nwStatus |- I[Status]'
              , 'origin'        => 'line 154:10, file ".\\\\CSA_Op Ontology.adl"'
              , 'meaning'       => 'nwStatus[Network\\*Status] is univalent'
              , 'message'       => 'nwStatus[Network\\*Status] is not univalent'
              , 'srcConcept'    => 'Status'
              , 'tgtConcept'    => 'Status'
              // Normalization steps:
              //     -(nwStatus~;nwStatus |- I[Status])
              // <=> { remove |- }
              //     -(-(nwStatus~;nwStatus) \\/ I[Status])
              // <=> { De Morgan }
              //     nwStatus~;nwStatus /\\ -I[Status]
              // 
              // Normalized complement (== violationsSQL): 
              // EIsc (ECps (EFlp (EDcD rel_nwStatusNetworkStatus)
              //            ,EDcD rel_nwStatusNetworkStatus
              //            )
              //      ,ECpl (EDcI cpt_Status)
              //      )
              , 'violationsSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                             nwStatus~;nwStatus /\\\\ -I[Status] ([Status*Status]) */
                          SELECT DISTINCT isect0.`SrcStatus` AS `src`, isect0.`TgtStatus` AS `tgt`
                          FROM 
                               ( /* case: (ECps es), with two or more elements in es.
                                    nwStatus~;nwStatus */
                                 
                                 SELECT DISTINCT ECps0.`nwStatus` AS `SrcStatus`, ECps1.`nwStatus` AS `TgtStatus`
                                 FROM `Network` AS ECps0,
                                      `Network` AS ECps1
                                 WHERE ECps0.`Network`=ECps1.`Network`
                               ) AS isect0
                          WHERE isect0.`SrcStatus` <> isect0.`TgtStatus` AND isect0.`SrcStatus` IS NOT NULL AND isect0.`TgtStatus` IS NOT NULL'
              , 'pairView'      =>
                  array
                    ()
              )
    );

$invariantRuleNames = array ('Task completion integrity', 'rrtStar Transitive closure integrity', 'Yes/No answer integrity', 'IRF[isSubtaskOf]', 'Activity executor must exist', 'Router network integrity', 'SYM connectComputerToNetworkRouter::Computer*Computer', 'ASY connectComputerToNetworkRouter::Computer*Computer', 'UNI connectComputerToNetworkRouter::Computer*Computer', 'INJ connectComputerToNetworkRouter::Computer*Computer', 'SYM compRequiresComm::Computer*Computer', 'ASY compRequiresComm::Computer*Computer', 'UNI compRequiresComm::Computer*Computer', 'INJ compRequiresComm::Computer*Computer', 'SYM compAllReqCommSatisfied::Computer*Computer', 'ASY compAllReqCommSatisfied::Computer*Computer', 'UNI compAllReqCommSatisfied::Computer*Computer', 'INJ compAllReqCommSatisfied::Computer*Computer', 'SYM compNoReqCommSatisfied::Computer*Computer', 'ASY compNoReqCommSatisfied::Computer*Computer', 'UNI compNoReqCommSatisfied::Computer*Computer', 'INJ compNoReqCommSatisfied::Computer*Computer', 'SYM routerAllCommReqsSatisfied::Router*Router', 'ASY routerAllCommReqsSatisfied::Router*Router', 'UNI routerAllCommReqsSatisfied::Router*Router', 'INJ routerAllCommReqsSatisfied::Router*Router', 'SYM routerNoCommReqsSatisfied::Router*Router', 'ASY routerNoCommReqsSatisfied::Router*Router', 'UNI routerNoCommReqsSatisfied::Router*Router', 'INJ routerNoCommReqsSatisfied::Router*Router', 'SYM nwAllCompCommReqsSatisfied::Network*Network', 'ASY nwAllCompCommReqsSatisfied::Network*Network', 'UNI nwAllCompCommReqsSatisfied::Network*Network', 'INJ nwAllCompCommReqsSatisfied::Network*Network', 'SYM nwNoCompCommReqsSatisfied::Network*Network', 'ASY nwNoCompCommReqsSatisfied::Network*Network', 'UNI nwNoCompCommReqsSatisfied::Network*Network', 'INJ nwNoCompCommReqsSatisfied::Network*Network', 'UNI compCmpStat::Computer*Status', 'UNI scCmpStat::SvcComponent*Status', 'UNI itsvcCmpStat::ITService*Status', 'UNI svcCmpStat::Service*Status', 'SYM allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'ASY allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'UNI allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'INJ allRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'SYM noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'ASY noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'UNI noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'INJ noRequiredITAvailbleToOrgUnit::OrgUnit*OrgUnit', 'UNI ouCmpStat::OrgUnit*Status', 'UNI actCmpStat::Activity*Status', 'UNI resultCmpStat::Result*Status', 'SYM taskCmpStatIsRed::Task*Task', 'ASY taskCmpStatIsRed::Task*Task', 'UNI taskCmpStatIsRed::Task*Task', 'INJ taskCmpStatIsRed::Task*Task', 'SYM taskCmpStatIsGreen::Task*Task', 'ASY taskCmpStatIsGreen::Task*Task', 'UNI taskCmpStatIsGreen::Task*Task', 'INJ taskCmpStatIsGreen::Task*Task', 'UNI taskCmpStat::Task*Status', 'UNI purposeCmpStat::Purpose*Status', 'UNI purposeStatus::Purpose*Status', 'UNI purposeMnlStat::Purpose*Status', 'UNI taskStatus::Task*Status', 'UNI taskMnlStat::Task*Status', 'UNI taskEndTime::Task*Timestamp', 'ASY isSubtaskOf::Task*Task', 'UNI taskOU::Task*OrgUnit', 'UNI resultStatus::Result*Status', 'UNI resultMnlStat::Result*Status', 'UNI resultDeadline::Result*Timestamp', 'UNI svcStatus::Service*Status', 'UNI actStatus::Activity*Status', 'UNI actMnlStat::Activity*Status', 'UNI actResult::Activity*Result', 'UNI actTask::Activity*Task', 'TOT actTask::Activity*Task', 'UNI actExecutingOU::Activity*OrgUnit', 'UNI actPlannedStartTime::Activity*Timestamp', 'UNI actPlannedEndTime::Activity*Timestamp', 'UNI actStartTime::Activity*Timestamp', 'UNI actEndTime::Activity*Timestamp', 'UNI ouStatus::OrgUnit*Status', 'UNI ouMnlStat::OrgUnit*Status', 'ASY isSubUnitOf::OrgUnit*OrgUnit', 'UNI svcMnlStat::Service*Status', 'UNI itsvcStatus::ITService*Status', 'UNI itsvcMnlStat::ITService*Status', 'UNI scStatus::SvcComponent*Status', 'UNI scMnlStat::SvcComponent*Status', 'UNI compStatus::Computer*Status', 'UNI compMnlStat::Computer*Status', 'UNI compOwner::Computer*OrgUnit', 'UNI routerStatus::Router*Status', 'UNI routerSerial::Router*SerialNumber', 'UNI routerLocation::Router*Location', 'UNI routerNW::Router*Network', 'UNI nwStatus::Network*Status');

$allRoles =
  array
    ( array ( 'name' => 'Developer'
            , 'ruleNames' => array ('SUR[taskExpectsResult]', 'Connect computer to network router', 'Create router paths', 'Routes to be discarded', 'Computers to be disconnected', 'Deploying ITService', 'Network status integrity check', 'Router status integrity check', 'Computer status integrity check')
            )
    , array ( 'name' => 'ExecEngine'
            , 'ruleNames' => array ('insconnectComputerToNetworkRouter', 'delconnectComputerToNetworkRouter', 'insroutesToBeDiscarded', 'delroutesToBeDiscarded', 'inscomputerToBeDisconnected', 'delcomputerToBeDisconnected', 'Activity termination', 'inscompITService', 'delcompITService', 'Create path within network', 'Remove routes from non-network routers', 'Remove computers from non-network routers', 'InscompReqCommWith', 'DelcompReqCommWith', 'InscompRequiresComm', 'DelcompRequiresComm', 'InscompHasCommWith', 'DelcompHasCommWith', 'InscompAllReqCommSatisfied', 'DelCompAllReqCommSatisfied', 'InscompNoReqCommSatisfied', 'DelCompNoReqCommSatisfied', 'rrtCompTransitiveClosure', 'InsrouterNeedsPathTo', 'DelrouterNeedsPathTo', 'InsrouterAllCommReqsSatisfied', 'DelrouterAllCommReqsSatisfied', 'InsrouterNoCommReqsSatisfied', 'DelrouterNoCommReqsSatisfied', 'InsnwAllCompCommReqsSatisfied', 'DelnwAllCompCommReqsSatisfied', 'InsnwNoCompCommReqsSatisfied', 'DelnwNoCompCommReqsSatisfied', 'Network status \'Green\'', 'Network status \'Yellow\'', 'Network status \'Red\'', 'Network status \'Blue\'', 'Router status \'Green\'', 'Router status \'Yellow\'', 'Router status \'Red\'', 'Router status \'Blue\'', 'Computer status \'Black\'', 'Computer status \'Blue\'', 'Computer status \'Green\'', 'Computer status \'Yellow\'', 'Computer status \'Red\'', 'InsComputerStatus', 'InsSvcComponentStatus', 'defaultSvcComponentStatus', 'ITService status \'Grey\'', 'ITService status \'Blue\'', 'ITService status \'Red\'', 'ITService status \'Green\'', 'ITService status \'Yellow\'', 'InsITServiceStatus', 'defaultITServiceStatus', 'InsServiceStatus', 'defaultServiceStatus', 'insallRequiredITAvailbleToOrgUnit', 'delallRequiredITAvailbleToOrgUnit', 'insnoRequiredITAvailbleToOrgUnit', 'delnoRequiredITAvailbleToOrgUnit', 'insouCmpStatRed', 'insouCmpStatGreen', 'insouCmpStatYellow', 'InsOrgUnitStatus', 'defaultOrgUnitStatus', 'actCmpStatIsGrey', 'actCmpStatIsBlue', 'actCmpStatIsRed', 'actCmpStatIsYellow', 'actCmpStatIsGreen', 'InsActivityStatus', 'defaultActivityStatus', 'resultCmpStatIsRed', 'resultCmpStatIsYellow', 'resultCmpStatIsGreen', 'InsResultStatus', 'defaultResultStatus', 'instaskCmpStatIsRed', 'deltaskCmpStatIsRed', 'instaskCmpStatIsGreen', 'deltaskCmpStatIsGreen', 'taskCmpStatIsYellow', 'InsTaskStatus', 'defaultTaskStatus', 'inspurposeCmpStatIsGreen', 'purposeCmpStatIsYellow', 'purposeCmpStatIsRed', 'InsPurposeStatus', 'defaultPurposeStatus')
            )
    );

//$allViews is sorted from spec to gen such that the first match for a concept will be the most specific (e.g. see DatabaseUtils.getView()).
$allViews =
  array
    ();

$allInterfaceObjects =
  array
    ( // Top-level interface OVERVIEW for all roles:
      'OVERVIEW' => 
      array ( 'name' => 'OVERVIEW'
            // Normalized interface expression (== expressionSQL): I[ONE]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ()
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ONE'
            , 'tgtConcept' => 'ONE'
            , 'expressionSQL' => '/* I[ONE] */
                                  SELECT 1 AS src, 1 AS tgt'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Purposes'
                          // Normalized interface expression (== expressionSQL): V[ONE*Purpose]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Purpose'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Purpose]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Purpose`.`Purpose` AS `tgt`
                                                FROM `Purpose` AS `Purpose`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Purpose'
                                        // Normalized interface expression (== expressionSQL): I[Purpose]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Purpose'
                                        , 'tgtConcept' => 'Purpose'
                                        , 'expressionSQL' => '/* I[Purpose] */
                                                                SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                                                FROM `Purpose`
                                                                WHERE `Purpose` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): purposeStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Purpose'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Purpose` AS `src`, `purposeStatus` AS `tgt`
                                                              FROM `Purpose`
                                                              WHERE `Purpose` IS NOT NULL AND `purposeStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Tasks'
                          // Normalized interface expression (== expressionSQL): V[ONE*Task]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Task]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Task`.`Task` AS `tgt`
                                                FROM `Task` AS `Task`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Task'
                                        // Normalized interface expression (== expressionSQL): I[Task]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Task'
                                        , 'expressionSQL' => '/* I[Task] */
                                                                SELECT `Task` AS `src`, `Task` AS `tgt`
                                                                FROM `Task`
                                                                WHERE `Task` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): taskStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `taskStatus` AS `tgt`
                                                              FROM `Task`
                                                              WHERE `Task` IS NOT NULL AND `taskStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Results'
                          // Normalized interface expression (== expressionSQL): V[ONE*Result]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Result'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Result]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Result`.`Result` AS `tgt`
                                                FROM `Result` AS `Result`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Result'
                                        // Normalized interface expression (== expressionSQL): I[Result]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Result'
                                        , 'tgtConcept' => 'Result'
                                        , 'expressionSQL' => '/* I[Result] */
                                                                SELECT `Result` AS `src`, `Result` AS `tgt`
                                                                FROM `Result`
                                                                WHERE `Result` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): resultStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Result'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Result` AS `src`, `resultStatus` AS `tgt`
                                                              FROM `Result`
                                                              WHERE `Result` IS NOT NULL AND `resultStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Activities'
                          // Normalized interface expression (== expressionSQL): V[ONE*Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Activity]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Activity`.`Activity` AS `tgt`
                                                FROM `Activity` AS `Activity`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Activity'
                                        // Normalized interface expression (== expressionSQL): I[Activity]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* I[Activity] */
                                                                SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                                FROM `Activity`
                                                                WHERE `Activity` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): actStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actStatus` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Services'
                          // Normalized interface expression (== expressionSQL): V[ONE*Service]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Service]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Service`.`Service` AS `tgt`
                                                FROM `Service` AS `Service`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Service'
                                        // Normalized interface expression (== expressionSQL): I[Service]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* I[Service] */
                                                                SELECT `Service` AS `src`, `Service` AS `tgt`
                                                                FROM `Service`
                                                                WHERE `Service` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): svcStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS `src`, `svcStatus` AS `tgt`
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'OrgUnits'
                          // Normalized interface expression (== expressionSQL): V[ONE*OrgUnit]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*OrgUnit]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `OrgUnit`.`OrgUnit` AS `tgt`
                                                FROM `OrgUnit` AS `OrgUnit`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Org.Unit'
                                        // Normalized interface expression (== expressionSQL): I[OrgUnit]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* I[OrgUnit] */
                                                                SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                                                FROM `OrgUnit`
                                                                WHERE `OrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): ouStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS `src`, `ouStatus` AS `tgt`
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'ITServices'
                          // Normalized interface expression (== expressionSQL): V[ONE*ITService]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*ITService]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `ITService`.`ITService` AS `tgt`
                                                FROM `ITService` AS `ITService`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ITService'
                                        // Normalized interface expression (== expressionSQL): I[ITService]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => '/* I[ITService] */
                                                                SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                                                FROM `ITService`
                                                                WHERE `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): itsvcStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ITService` AS `src`, `itsvcStatus` AS `tgt`
                                                              FROM `ITService`
                                                              WHERE `ITService` IS NOT NULL AND `itsvcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'SvcComponents'
                          // Normalized interface expression (== expressionSQL): V[ONE*SvcComponent]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*SvcComponent]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `SvcComponent`.`SvcComponent` AS `tgt`
                                                FROM `SvcComponent` AS `SvcComponent`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'SvcComponent'
                                        // Normalized interface expression (== expressionSQL): I[SvcComponent]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* I[SvcComponent] */
                                                                SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                                                FROM `SvcComponent`
                                                                WHERE `SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): scStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `scStatus` AS `tgt`
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Computers'
                          // Normalized interface expression (== expressionSQL): V[ONE*Computer]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Computer]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Computer`.`Computer` AS `tgt`
                                                FROM `Computer` AS `Computer`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // Normalized interface expression (== expressionSQL): I[Computer]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                                SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                                                FROM `Computer`
                                                                WHERE `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): compStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `compStatus` AS `tgt`
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Networks'
                          // Normalized interface expression (== expressionSQL): V[ONE*Network]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Network]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Network`.`Network` AS `tgt`
                                                FROM `Network` AS `Network`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Network'
                                        // Normalized interface expression (== expressionSQL): I[Network]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Network'
                                        , 'expressionSQL' => '/* I[Network] */
                                                                SELECT `Network` AS `src`, `Network` AS `tgt`
                                                                FROM `Network`
                                                                WHERE `Network` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): nwStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS `src`, `nwStatus` AS `tgt`
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Routers'
                          // Normalized interface expression (== expressionSQL): V[ONE*Router]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ONE'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: (EDcV (Sign s t))
                                                   V [ \\"[ONE*Router]\\" ] */
                                                SELECT DISTINCT 1 AS `src`, `Router`.`Router` AS `tgt`
                                                FROM `Router` AS `Router`'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Router'
                                        // Normalized interface expression (== expressionSQL): I[Router]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* I[Router] */
                                                                SELECT `Router` AS `src`, `Router` AS `tgt`
                                                                FROM `Router`
                                                                WHERE `Router` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): routerStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS `src`, `routerStatus` AS `tgt`
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Purpose for all roles:
      'Purpose' => 
      array ( 'name' => 'Purpose'
            // Normalized interface expression (== expressionSQL): I[Purpose]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Status', 'Task')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Purpose'
            , 'tgtConcept' => 'Purpose'
            , 'expressionSQL' => '/* I[Purpose] */
                                    SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                    FROM `Purpose`
                                    WHERE `Purpose` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Purpose'
                          // Normalized interface expression (== expressionSQL): I[Purpose]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Purpose'
                          , 'tgtConcept' => 'Purpose'
                          , 'expressionSQL' => '/* I[Purpose] */
                                                  SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                                  FROM `Purpose`
                                                  WHERE `Purpose` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[Purpose]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Purpose'
                                        , 'tgtConcept' => 'Purpose'
                                        , 'expressionSQL' => '/* I[Purpose] */
                                                                SELECT `Purpose` AS `src`, `Purpose` AS `tgt`
                                                                FROM `Purpose`
                                                                WHERE `Purpose` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): purposeStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Purpose'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Purpose` AS `src`, `purposeStatus` AS `tgt`
                                                              FROM `Purpose`
                                                              WHERE `Purpose` IS NOT NULL AND `purposeStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): purposeMnlStat
                                        , 'relation' => 'purposeMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Purpose'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Purpose` AS `src`, `purposeMnlStat` AS `tgt`
                                                              FROM `Purpose`
                                                              WHERE `Purpose` IS NOT NULL AND `purposeMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Development themes'
                          // Normalized interface expression (== expressionSQL): taskPurpose~;isSubtaskOf~;taskPurpose
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Purpose'
                          , 'tgtConcept' => 'Purpose'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   taskPurpose~;isSubtaskOf~;taskPurpose */
                                                
                                                SELECT DISTINCT ECps0.`Purpose` AS `src`, ECps2.`Purpose` AS `tgt`
                                                FROM `taskPurpose` AS ECps0,
                                                     `isSubtaskOf` AS ECps1,
                                                     `taskPurpose` AS ECps2
                                                WHERE ECps0.`Task`=ECps1.`TgtTask`
                                                  AND ECps1.`SrcTask`=ECps2.`Task`'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Task'
                          // Normalized interface expression (== expressionSQL): taskPurpose~
                          , 'relation' => 'taskPurpose'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Purpose'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Purpose` AS `src`, `Task` AS `tgt`
                                                FROM `taskPurpose`
                                                WHERE `Task` IS NOT NULL AND `Purpose` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Task for all roles:
      'Task' => 
      array ( 'name' => 'Task'
            // Normalized interface expression (== expressionSQL): I[Task]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Purpose', 'OrgUnit', 'Status', 'Result', 'Task', 'Service')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Task'
            , 'tgtConcept' => 'Task'
            , 'expressionSQL' => '/* I[Task] */
                                    SELECT `Task` AS `src`, `Task` AS `tgt`
                                    FROM `Task`
                                    WHERE `Task` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Task'
                          // Normalized interface expression (== expressionSQL): I[Task]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Task'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* I[Task] */
                                                  SELECT `Task` AS `src`, `Task` AS `tgt`
                                                  FROM `Task`
                                                  WHERE `Task` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[Task]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Task'
                                        , 'expressionSQL' => '/* I[Task] */
                                                                SELECT `Task` AS `src`, `Task` AS `tgt`
                                                                FROM `Task`
                                                                WHERE `Task` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Purpose/Missie'
                                        // Normalized interface expression (== expressionSQL): taskPurpose
                                        , 'relation' => 'taskPurpose'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'Many'
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Purpose'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `Purpose` AS `tgt`
                                                              FROM `taskPurpose`
                                                              WHERE `Task` IS NOT NULL AND `Purpose` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Uitvoerder'
                                        // Normalized interface expression (== expressionSQL): taskOU
                                        , 'relation' => 'taskOU'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `taskOU` AS `tgt`
                                                              FROM `Task`
                                                              WHERE `Task` IS NOT NULL AND `taskOU` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): taskStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `taskStatus` AS `tgt`
                                                              FROM `Task`
                                                              WHERE `Task` IS NOT NULL AND `taskStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): taskMnlStat
                                        , 'relation' => 'taskMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `taskMnlStat` AS `tgt`
                                                              FROM `Task`
                                                              WHERE `Task` IS NOT NULL AND `taskMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Expected results'
                          // Normalized interface expression (== expressionSQL): taskExpectsResult
                          , 'relation' => 'taskExpectsResult'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Task'
                          , 'tgtConcept' => 'Result'
                          , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `Result` AS `tgt`
                                                FROM `taskExpectsResult`
                                                WHERE `Task` IS NOT NULL AND `Result` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Subtasks'
                          // Normalized interface expression (== expressionSQL): isSubtaskOf~
                          , 'relation' => 'isSubtaskOf'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Task'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `TgtTask` AS `src`, `SrcTask` AS `tgt`
                                                FROM `isSubtaskOf`
                                                WHERE `SrcTask` IS NOT NULL AND `TgtTask` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Activities'
                          // Normalized interface expression (== expressionSQL): actTask~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Task'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `actTask` AS `src`, `Activity` AS `tgt`
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actTask` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Req\'d InfoServices'
                          // Normalized interface expression (== expressionSQL): taskReqsSvc
                          , 'relation' => 'taskReqsSvc'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Task'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `Task` AS `src`, `Service` AS `tgt`
                                                FROM `taskReqsSvc`
                                                WHERE `Task` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): I[Task]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Task'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* I[Task] */
                                                  SELECT `Task` AS `src`, `Task` AS `tgt`
                                                  FROM `Task`
                                                  WHERE `Task` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Results that need to be planned by me'
                                        // Normalization steps:
                                        //     taskExpectsResult /\\ -(actTask~;actResult \\/ isSubtaskOf~;taskExpectsResult)
                                        // <=> { De Morgan }
                                        //     taskExpectsResult /\\ -(actTask~;actResult) /\\ -(isSubtaskOf~;taskExpectsResult)
                                        //
                                        // Normalized interface expression (== expressionSQL): taskExpectsResult /\\ -(actTask~;actResult) /\\ -(isSubtaskOf~;taskExpectsResult)
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Result'
                                        , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                                 taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult) ([Task*Result]) */
                                                              SELECT DISTINCT isect0.`Task` AS `src`, isect0.`Result` AS `tgt`
                                                              FROM `taskExpectsResult` AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                                     actTask~;actResult */
                                                                                  
                                                                                  SELECT DISTINCT ECps0.`actTask` AS `SrcTask`, ECps1.`actResult` AS `TgtResult`
                                                                                  FROM `Activity` AS ECps0,
                                                                                       `Activity` AS ECps1
                                                                                  WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                                ) AS cp
                                                                                WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Result`=cp.`TgtResult`) AND NOT EXISTS (SELECT * FROM 
                                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                                     isSubtaskOf~;taskExpectsResult */
                                                                                  
                                                                                  SELECT DISTINCT ECps0.`TgtTask` AS `SrcTask`, ECps1.`Result` AS `TgtResult`
                                                                                  FROM `isSubtaskOf` AS ECps0,
                                                                                       `taskExpectsResult` AS ECps1
                                                                                  WHERE ECps0.`SrcTask`=ECps1.`Task`
                                                                                ) AS cp
                                                                                WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Task` IS NOT NULL AND isect0.`Result` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Subtasks that need further planning'
                                        // Normalization steps:
                                        //     isSubtaskOf~;(I[Task] /\\ (taskExpectsResult /\\ -(actTask~;actResult \\/ isSubtaskOf~;taskExpectsResult));taskExpectsResult~)
                                        // <=> { De Morgan }
                                        //     isSubtaskOf~;(I[Task] /\\ (taskExpectsResult /\\ -(actTask~;actResult) /\\ -(isSubtaskOf~;taskExpectsResult));taskExpectsResult~)
                                        //
                                        // Normalized interface expression (== expressionSQL): isSubtaskOf~;(I[Task] /\\ (taskExpectsResult /\\ -(actTask~;actResult) /\\ -(isSubtaskOf~;taskExpectsResult));taskExpectsResult~)
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Task'
                                        , 'tgtConcept' => 'Task'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 isSubtaskOf~;(I[Task] /\\\\ (taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult));taskExpectsResult~) */
                                                              
                                                              SELECT DISTINCT ECps0.`TgtTask` AS `src`, ECps1.`TgtTask` AS `tgt`
                                                              FROM `isSubtaskOf` AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Task] /\\\\ (taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult));taskExpectsResult~ ([Task*Task]) */
                                                                     SELECT DISTINCT isect0.`SrcTask`, isect0.`TgtTask`
                                                                     FROM 
                                                                          ( /* case: (ECps es), with two or more elements in es.
                                                                               (taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult));taskExpectsResult~ */
                                                                            
                                                                            SELECT DISTINCT ECps0.`SrcTask`, ECps1.`Task` AS `TgtTask`
                                                                            FROM 
                                                                                 ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                                      taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult) ([Task*Result]) */
                                                                                   SELECT DISTINCT isect0.`Task` AS `SrcTask`, isect0.`Result` AS `TgtResult`
                                                                                   FROM `taskExpectsResult` AS isect0
                                                                                   WHERE NOT EXISTS (SELECT * FROM 
                                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                                          actTask~;actResult */
                                                                                                       
                                                                                                       SELECT DISTINCT ECps0.`actTask` AS `SrcTask`, ECps1.`actResult` AS `TgtResult`
                                                                                                       FROM `Activity` AS ECps0,
                                                                                                            `Activity` AS ECps1
                                                                                                       WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                                                     ) AS cp
                                                                                                     WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Result`=cp.`TgtResult`) AND NOT EXISTS (SELECT * FROM 
                                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                                          isSubtaskOf~;taskExpectsResult */
                                                                                                       
                                                                                                       SELECT DISTINCT ECps0.`TgtTask` AS `SrcTask`, ECps1.`Result` AS `TgtResult`
                                                                                                       FROM `isSubtaskOf` AS ECps0,
                                                                                                            `taskExpectsResult` AS ECps1
                                                                                                       WHERE ECps0.`SrcTask`=ECps1.`Task`
                                                                                                     ) AS cp
                                                                                                     WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Task` IS NOT NULL AND isect0.`Result` IS NOT NULL
                                                                                 ) AS ECps0,
                                                                                 `taskExpectsResult` AS ECps1
                                                                            WHERE ECps0.`TgtResult`=ECps1.`Result`
                                                                          ) AS isect0, 
                                                                          ( /* Case EDcI Task */
                                                                            SELECT `Task` AS `Task`
                                                                            FROM `Task` ) AS isect1
                                                                     WHERE isect0.`SrcTask` = isect0.`TgtTask` AND isect0.`SrcTask` IS NOT NULL AND isect0.`TgtTask` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`SrcTask`=ECps1.`SrcTask`'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Result for all roles:
      'Result' => 
      array ( 'name' => 'Result'
            // Normalized interface expression (== expressionSQL): I[Result]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Status', 'Timestamp')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Result'
            , 'tgtConcept' => 'Result'
            , 'expressionSQL' => '/* I[Result] */
                                    SELECT `Result` AS `src`, `Result` AS `tgt`
                                    FROM `Result`
                                    WHERE `Result` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Result'
                          // Normalized interface expression (== expressionSQL): I[Result]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Result'
                          , 'tgtConcept' => 'Result'
                          , 'expressionSQL' => '/* I[Result] */
                                                  SELECT `Result` AS `src`, `Result` AS `tgt`
                                                  FROM `Result`
                                                  WHERE `Result` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[Result]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Result'
                                        , 'tgtConcept' => 'Result'
                                        , 'expressionSQL' => '/* I[Result] */
                                                                SELECT `Result` AS `src`, `Result` AS `tgt`
                                                                FROM `Result`
                                                                WHERE `Result` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): resultStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Result'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Result` AS `src`, `resultStatus` AS `tgt`
                                                              FROM `Result`
                                                              WHERE `Result` IS NOT NULL AND `resultStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): resultMnlStat
                                        , 'relation' => 'resultMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Result'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Result` AS `src`, `resultMnlStat` AS `tgt`
                                                              FROM `Result`
                                                              WHERE `Result` IS NOT NULL AND `resultMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Deadline'
                                        // Normalized interface expression (== expressionSQL): resultDeadline
                                        , 'relation' => 'resultDeadline'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Result'
                                        , 'tgtConcept' => 'Timestamp'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Result` AS `src`, `resultDeadline` AS `tgt`
                                                              FROM `Result`
                                                              WHERE `Result` IS NOT NULL AND `resultDeadline` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Tasks'
                          // Normalized interface expression (== expressionSQL): taskExpectsResult~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Result'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Result` AS `src`, `Task` AS `tgt`
                                                FROM `taskExpectsResult`
                                                WHERE `Task` IS NOT NULL AND `Result` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Activities'
                          // Normalized interface expression (== expressionSQL): actResult~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Result'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `actResult` AS `src`, `Activity` AS `tgt`
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actResult` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Activity for all roles:
      'Activity' => 
      array ( 'name' => 'Activity'
            // Normalized interface expression (== expressionSQL): I[Activity]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Status', 'Task', 'OrgUnit', 'Timestamp', 'Timestamp', 'ITService', 'Timestamp', 'Timestamp')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Activity'
            , 'tgtConcept' => 'Activity'
            , 'expressionSQL' => '/* I[Activity] */
                                    SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                    FROM `Activity`
                                    WHERE `Activity` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Activity'
                          // Normalized interface expression (== expressionSQL): I[Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* I[Activity] */
                                                  SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                  FROM `Activity`
                                                  WHERE `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Name'
                                        // Normalized interface expression (== expressionSQL): I[Activity]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* I[Activity] */
                                                                SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                                FROM `Activity`
                                                                WHERE `Activity` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): actStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actStatus` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): actMnlStat
                                        , 'relation' => 'actMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actMnlStat` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Task'
                                        // Normalized interface expression (== expressionSQL): actTask
                                        , 'relation' => 'actTask'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'One'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Task'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actTask` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actTask` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Executed by'
                                        // Normalized interface expression (== expressionSQL): actExecutingOU
                                        , 'relation' => 'actExecutingOU'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actExecutingOU` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Planning'
                          // Normalized interface expression (== expressionSQL): I[Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* I[Activity] */
                                                  SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                  FROM `Activity`
                                                  WHERE `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Planned start time'
                                        // Normalized interface expression (== expressionSQL): actPlannedStartTime
                                        , 'relation' => 'actPlannedStartTime'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Timestamp'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actPlannedStartTime` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actPlannedStartTime` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Result to realize'
                                        // Normalized interface expression (== expressionSQL): actResult
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Result'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actResult` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actResult` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Deadline for result'
                                        // Normalized interface expression (== expressionSQL): actResult;resultDeadline
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Timestamp'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 actResult;resultDeadline */
                                                              
                                                              SELECT DISTINCT ECps0.`Activity` AS `src`, ECps1.`resultDeadline` AS `tgt`
                                                              FROM `Activity` AS ECps0,
                                                                   `Result` AS ECps1
                                                              WHERE ECps0.`actResult`=ECps1.`Result`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Planned end time'
                                        // Normalized interface expression (== expressionSQL): actPlannedEndTime
                                        , 'relation' => 'actPlannedEndTime'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Timestamp'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actPlannedEndTime` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actPlannedEndTime` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Required resources'
                          // Normalized interface expression (== expressionSQL): actUsesITSvc
                          , 'relation' => 'actUsesITSvc'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `ITService` AS `tgt`
                                                FROM `actUsesITSvc`
                                                WHERE `Activity` IS NOT NULL AND `ITService` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'IT Service'
                                        // Normalized interface expression (== expressionSQL): I[ITService]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => '/* I[ITService] */
                                                                SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                                                FROM `ITService`
                                                                WHERE `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): itsvcStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ITService` AS `src`, `itsvcStatus` AS `tgt`
                                                              FROM `ITService`
                                                              WHERE `ITService` IS NOT NULL AND `itsvcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Execution'
                          // Normalized interface expression (== expressionSQL): I[Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* I[Activity] */
                                                  SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                  FROM `Activity`
                                                  WHERE `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Actual start time'
                                        // Normalized interface expression (== expressionSQL): actStartTime
                                        , 'relation' => 'actStartTime'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Timestamp'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actStartTime` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actStartTime` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Actual end time'
                                        // Normalized interface expression (== expressionSQL): actEndTime
                                        , 'relation' => 'actEndTime'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Timestamp'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `actEndTime` AS `tgt`
                                                              FROM `Activity`
                                                              WHERE `Activity` IS NOT NULL AND `actEndTime` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): I[Activity]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Activity'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* I[Activity] */
                                                  SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                  FROM `Activity`
                                                  WHERE `Activity` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Lacking ITServices'
                                        // Normalized interface expression (== expressionSQL): actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService)
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                                 actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService) ([Activity*ITService]) */
                                                              SELECT DISTINCT isect0.`Activity` AS `src`, isect0.`ITService` AS `tgt`
                                                              FROM `actUsesITSvc` AS isect0, 
                                                                   
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actExecutingOU;-(compOwner~;compITService) */
                                                                     
                                                                     SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtITService`
                                                                     FROM `Activity` AS ECps0,
                                                                          
                                                                          ( /* case: ECpl e
                                                                               ECpl ( \\"compOwner~;compITService\\" ) */
                                                                            SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`ITService` AS `TgtITService`
                                                                            FROM `OrgUnit` AS cfst,
                                                                                 `ITService` AS csnd
                                                                            WHERE NOT EXISTS
                                                                             (SELECT * FROM 
                                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                                        compOwner~;compITService */
                                                                                     
                                                                                     SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                                     FROM `Computer` AS ECps0,
                                                                                          `compITService` AS ECps1
                                                                                     WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                   ) AS cp
                                                                              WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`ITService`=cp.`TgtITService`)
                                                                          ) AS ECps1
                                                                     WHERE ECps0.`actExecutingOU`=ECps1.`SrcOrgUnit`
                                                                   ) AS isect1
                                                              WHERE (isect0.`Activity` = isect1.`SrcActivity` AND isect0.`ITService` = isect1.`TgtITService`) AND isect0.`Activity` IS NOT NULL AND isect0.`ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Service for role Developer:
      'Service' => 
      array ( 'name' => 'Service'
            // Normalized interface expression (== expressionSQL): I[Service]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('Status', 'Task')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Service'
            , 'tgtConcept' => 'Service'
            , 'expressionSQL' => '/* I[Service] */
                                    SELECT `Service` AS `src`, `Service` AS `tgt`
                                    FROM `Service`
                                    WHERE `Service` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Service'
                          // Normalized interface expression (== expressionSQL): I[Service]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => '/* I[Service] */
                                                  SELECT `Service` AS `src`, `Service` AS `tgt`
                                                  FROM `Service`
                                                  WHERE `Service` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[Service]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Service'
                                        , 'expressionSQL' => '/* I[Service] */
                                                                SELECT `Service` AS `src`, `Service` AS `tgt`
                                                                FROM `Service`
                                                                WHERE `Service` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): svcStatus
                                        , 'relation' => 'svcStatus'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Service'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Service` AS `src`, `svcStatus` AS `tgt`
                                                              FROM `Service`
                                                              WHERE `Service` IS NOT NULL AND `svcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Required by (Task)'
                          // Normalized interface expression (== expressionSQL): taskReqsSvc~
                          , 'relation' => 'taskReqsSvc'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Service` AS `src`, `Task` AS `tgt`
                                                FROM `taskReqsSvc`
                                                WHERE `Task` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Supported by (ITService)'
                          // Normalized interface expression (== expressionSQL): itsvcSupports~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Service'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Service` AS `src`, `ITService` AS `tgt`
                                                FROM `itsvcSupports`
                                                WHERE `ITService` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface OrgUnit for all roles:
      'OrgUnit' => 
      array ( 'name' => 'OrgUnit'
            // Normalized interface expression (== expressionSQL): I[OrgUnit]
            , 'interfaceRoles' => array ()
            , 'editableConcepts' => array ('Status', 'OrgUnit', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'OrgUnit'
            , 'tgtConcept' => 'OrgUnit'
            , 'expressionSQL' => '/* I[OrgUnit] */
                                    SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                    FROM `OrgUnit`
                                    WHERE `OrgUnit` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'OrgUnit'
                          // Normalized interface expression (== expressionSQL): I[OrgUnit]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* I[OrgUnit] */
                                                  SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                                  FROM `OrgUnit`
                                                  WHERE `OrgUnit` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[OrgUnit]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* I[OrgUnit] */
                                                                SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                                                FROM `OrgUnit`
                                                                WHERE `OrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status'
                                        // Normalized interface expression (== expressionSQL): ouStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS `src`, `ouStatus` AS `tgt`
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): ouMnlStat
                                        , 'relation' => 'ouMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `OrgUnit` AS `src`, `ouMnlStat` AS `tgt`
                                                              FROM `OrgUnit`
                                                              WHERE `OrgUnit` IS NOT NULL AND `ouMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'is subunit of'
                                        // Normalized interface expression (== expressionSQL): isSubUnitOf
                                        , 'relation' => 'isSubUnitOf'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'Many'
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SrcOrgUnit` AS `src`, `TgtOrgUnit` AS `tgt`
                                                              FROM `isSubUnitOf`
                                                              WHERE `SrcOrgUnit` IS NOT NULL AND `TgtOrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Assigned Tasks'
                          // Normalized interface expression (== expressionSQL): taskOU~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Task'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `taskOU` AS `src`, `Task` AS `tgt`
                                                FROM `Task`
                                                WHERE `Task` IS NOT NULL AND `taskOU` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Assigned Activities'
                          // Normalized interface expression (== expressionSQL): actExecutingOU~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `actExecutingOU` AS `src`, `Activity` AS `tgt`
                                                FROM `Activity`
                                                WHERE `Activity` IS NOT NULL AND `actExecutingOU` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Activity'
                                        // Normalized interface expression (== expressionSQL): I[Activity]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* I[Activity] */
                                                                SELECT `Activity` AS `src`, `Activity` AS `tgt`
                                                                FROM `Activity`
                                                                WHERE `Activity` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Uses (ITService)'
                                        // Normalized interface expression (== expressionSQL): actUsesITSvc
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Activity'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Activity` AS `src`, `ITService` AS `tgt`
                                                              FROM `actUsesITSvc`
                                                              WHERE `Activity` IS NOT NULL AND `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Owner of (Computer)'
                          // Normalized interface expression (== expressionSQL): compOwner~
                          , 'relation' => 'compOwner'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `compOwner` AS `src`, `Computer` AS `tgt`
                                                FROM `Computer`
                                                WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer'
                                        // Normalized interface expression (== expressionSQL): I[Computer]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                                SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                                                FROM `Computer`
                                                                WHERE `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Available ITService'
                                        // Normalized interface expression (== expressionSQL): compITService
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `ITService` AS `tgt`
                                                              FROM `compITService`
                                                              WHERE `Computer` IS NOT NULL AND `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): I[OrgUnit]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'OrgUnit'
                          , 'tgtConcept' => 'OrgUnit'
                          , 'expressionSQL' => '/* I[OrgUnit] */
                                                  SELECT `OrgUnit` AS `src`, `OrgUnit` AS `tgt`
                                                  FROM `OrgUnit`
                                                  WHERE `OrgUnit` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Results to be planned'
                                        // Normalization steps:
                                        //     taskOU~;(taskExpectsResult /\\ -(actTask~;actResult \\/ isSubtaskOf~;taskExpectsResult))
                                        // <=> { De Morgan }
                                        //     taskOU~;(taskExpectsResult /\\ -(actTask~;actResult) /\\ -(isSubtaskOf~;taskExpectsResult))
                                        //
                                        // Normalized interface expression (== expressionSQL): taskOU~;(taskExpectsResult /\\ -(actTask~;actResult) /\\ -(isSubtaskOf~;taskExpectsResult))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Result'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 taskOU~;(taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult)) */
                                                              
                                                              SELECT DISTINCT ECps0.`taskOU` AS `src`, ECps1.`TgtResult` AS `tgt`
                                                              FROM `Task` AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        taskExpectsResult /\\\\ -(actTask~;actResult) /\\\\ -(isSubtaskOf~;taskExpectsResult) ([Task*Result]) */
                                                                     SELECT DISTINCT isect0.`Task` AS `SrcTask`, isect0.`Result` AS `TgtResult`
                                                                     FROM `taskExpectsResult` AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            actTask~;actResult */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`actTask` AS `SrcTask`, ECps1.`actResult` AS `TgtResult`
                                                                                         FROM `Activity` AS ECps0,
                                                                                              `Activity` AS ECps1
                                                                                         WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Result`=cp.`TgtResult`) AND NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (ECps es), with two or more elements in es.
                                                                                            isSubtaskOf~;taskExpectsResult */
                                                                                         
                                                                                         SELECT DISTINCT ECps0.`TgtTask` AS `SrcTask`, ECps1.`Result` AS `TgtResult`
                                                                                         FROM `isSubtaskOf` AS ECps0,
                                                                                              `taskExpectsResult` AS ECps1
                                                                                         WHERE ECps0.`SrcTask`=ECps1.`Task`
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Task`=cp.`SrcTask` AND isect0.`Result`=cp.`TgtResult`) AND isect0.`Task` IS NOT NULL AND isect0.`Result` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`Task`=ECps1.`SrcTask`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Activities to be planned'
                                        // Normalized interface expression (== expressionSQL): actExecutingOU~;(I[Activity] /\\ -(actPlannedStartTime;actPlannedStartTime~ /\\ actPlannedEndTime;actPlannedEndTime~))
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'Activity'
                                        , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                                 actExecutingOU~;(I[Activity] /\\\\ -(actPlannedStartTime;actPlannedStartTime~ /\\\\ actPlannedEndTime;actPlannedEndTime~)) */
                                                              
                                                              SELECT DISTINCT ECps0.`actExecutingOU` AS `src`, ECps1.`TgtActivity` AS `tgt`
                                                              FROM `Activity` AS ECps0,
                                                                   
                                                                   ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                        I[Activity] /\\\\ -(actPlannedStartTime;actPlannedStartTime~ /\\\\ actPlannedEndTime;actPlannedEndTime~) ([Activity*Activity]) */
                                                                     SELECT DISTINCT isect0.`Activity` AS `SrcActivity`, isect0.`Activity` AS `TgtActivity`
                                                                     FROM ( /* Case EDcI Activity */
                                                                            SELECT `Activity` AS `Activity`
                                                                            FROM `Activity` ) AS isect0
                                                                     WHERE NOT EXISTS (SELECT * FROM 
                                                                                       ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                                            actPlannedStartTime;actPlannedStartTime~ /\\\\ actPlannedEndTime;actPlannedEndTime~ ([Activity*Activity]) */
                                                                                         SELECT DISTINCT isect0.`SrcActivity`, isect0.`TgtActivity`
                                                                                         FROM 
                                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                                   actPlannedStartTime;actPlannedStartTime~ */
                                                                                                
                                                                                                SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                                                                FROM `Activity` AS ECps0,
                                                                                                     `Activity` AS ECps1
                                                                                                WHERE ECps0.`actPlannedStartTime`=ECps1.`actPlannedStartTime`
                                                                                              ) AS isect0, 
                                                                                              
                                                                                              ( /* case: (ECps es), with two or more elements in es.
                                                                                                   actPlannedEndTime;actPlannedEndTime~ */
                                                                                                
                                                                                                SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`Activity` AS `TgtActivity`
                                                                                                FROM `Activity` AS ECps0,
                                                                                                     `Activity` AS ECps1
                                                                                                WHERE ECps0.`actPlannedEndTime`=ECps1.`actPlannedEndTime`
                                                                                              ) AS isect1
                                                                                         WHERE (isect0.`SrcActivity` = isect1.`SrcActivity` AND isect0.`TgtActivity` = isect1.`TgtActivity`) AND isect0.`SrcActivity` IS NOT NULL AND isect0.`TgtActivity` IS NOT NULL
                                                                                       ) AS cp
                                                                                       WHERE isect0.`Activity`=cp.`SrcActivity` AND isect0.`Activity`=cp.`TgtActivity`) AND isect0.`Activity` IS NOT NULL
                                                                   ) AS ECps1
                                                              WHERE ECps0.`Activity`=ECps1.`SrcActivity`'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'ITServices to be deployed'
                                        // Normalized interface expression (== expressionSQL): actExecutingOU~;actUsesITSvc /\\ -(compOwner~;compITService)
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'OrgUnit'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                                 actExecutingOU~;actUsesITSvc /\\\\ -(compOwner~;compITService) ([OrgUnit*ITService]) */
                                                              SELECT DISTINCT isect0.`SrcOrgUnit` AS `src`, isect0.`TgtITService` AS `tgt`
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actExecutingOU~;actUsesITSvc */
                                                                     
                                                                     SELECT DISTINCT ECps0.`actExecutingOU` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                     FROM `Activity` AS ECps0,
                                                                          `actUsesITSvc` AS ECps1
                                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                                     compOwner~;compITService */
                                                                                  
                                                                                  SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                                  FROM `Computer` AS ECps0,
                                                                                       `compITService` AS ECps1
                                                                                  WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                ) AS cp
                                                                                WHERE isect0.`SrcOrgUnit`=cp.`SrcOrgUnit` AND isect0.`TgtITService`=cp.`TgtITService`) AND isect0.`SrcOrgUnit` IS NOT NULL AND isect0.`TgtITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface ITService for role Developer:
      'ITService' => 
      array ( 'name' => 'ITService'
            // Normalized interface expression (== expressionSQL): I[ITService]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('Status', 'Status', 'Service', 'SvcComponent', 'SvcComponent', 'SvcComponent')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'ITService'
            , 'tgtConcept' => 'ITService'
            , 'expressionSQL' => '/* I[ITService] */
                                    SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                    FROM `ITService`
                                    WHERE `ITService` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'ITService'
                          // Normalized interface expression (== expressionSQL): I[ITService]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ITService'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => '/* I[ITService] */
                                                  SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                                  FROM `ITService`
                                                  WHERE `ITService` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[ITService]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'ITService'
                                        , 'expressionSQL' => '/* I[ITService] */
                                                                SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                                                FROM `ITService`
                                                                WHERE `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): itsvcStatus
                                        , 'relation' => 'itsvcStatus'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ITService` AS `src`, `itsvcStatus` AS `tgt`
                                                              FROM `ITService`
                                                              WHERE `ITService` IS NOT NULL AND `itsvcStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): itsvcMnlStat
                                        , 'relation' => 'itsvcMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `ITService` AS `src`, `itsvcMnlStat` AS `tgt`
                                                              FROM `ITService`
                                                              WHERE `ITService` IS NOT NULL AND `itsvcMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Supports (InfoService)'
                          // Normalized interface expression (== expressionSQL): itsvcSupports
                          , 'relation' => 'itsvcSupports'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'ITService'
                          , 'tgtConcept' => 'Service'
                          , 'expressionSQL' => 'SELECT DISTINCT `ITService` AS `src`, `Service` AS `tgt`
                                                FROM `itsvcSupports`
                                                WHERE `ITService` IS NOT NULL AND `Service` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Used by (Activity)'
                          // Normalized interface expression (== expressionSQL): actUsesITSvc~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ITService'
                          , 'tgtConcept' => 'Activity'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `ITService` AS `src`, `Activity` AS `tgt`
                                                FROM `actUsesITSvc`
                                                WHERE `Activity` IS NOT NULL AND `ITService` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Service components'
                          // Normalized interface expression (== expressionSQL): I[ITService]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ITService'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => '/* I[ITService] */
                                                  SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                                  FROM `ITService`
                                                  WHERE `ITService` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Stand alone'
                                        // Normalized interface expression (== expressionSQL): scImplements~
                                        , 'relation' => 'scImplements'
                                        , 'relationIsFlipped' => True
                                        , 'min' => 'Zero'
                                        , 'max' => 'Many'
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: EFlp x. */
                                                              SELECT DISTINCT `ITService` AS `src`, `SvcComponent` AS `tgt`
                                                              FROM `scImplements`
                                                              WHERE `SvcComponent` IS NOT NULL AND `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Servers'
                                        // Normalized interface expression (== expressionSQL): scIsServerFor~
                                        , 'relation' => 'scIsServerFor'
                                        , 'relationIsFlipped' => True
                                        , 'min' => 'Zero'
                                        , 'max' => 'Many'
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: EFlp x. */
                                                              SELECT DISTINCT `ITService` AS `src`, `SvcComponent` AS `tgt`
                                                              FROM `scIsServerFor`
                                                              WHERE `SvcComponent` IS NOT NULL AND `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Clients'
                                        // Normalized interface expression (== expressionSQL): scIsClientFor~
                                        , 'relation' => 'scIsClientFor'
                                        , 'relationIsFlipped' => True
                                        , 'min' => 'Zero'
                                        , 'max' => 'Many'
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: EFlp x. */
                                                              SELECT DISTINCT `ITService` AS `src`, `SvcComponent` AS `tgt`
                                                              FROM `scIsClientFor`
                                                              WHERE `SvcComponent` IS NOT NULL AND `ITService` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): I[ITService]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'ITService'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => '/* I[ITService] */
                                                  SELECT `ITService` AS `src`, `ITService` AS `tgt`
                                                  FROM `ITService`
                                                  WHERE `ITService` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'OrgUnits that need to deploy this ITService'
                                        // Normalized interface expression (== expressionSQL): actUsesITSvc~;actExecutingOU /\\ -(compITService~;compOwner)
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'ITService'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                                 actUsesITSvc~;actExecutingOU /\\\\ -(compITService~;compOwner) ([ITService*OrgUnit]) */
                                                              SELECT DISTINCT isect0.`SrcITService` AS `src`, isect0.`TgtOrgUnit` AS `tgt`
                                                              FROM 
                                                                   ( /* case: (ECps es), with two or more elements in es.
                                                                        actUsesITSvc~;actExecutingOU */
                                                                     
                                                                     SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`actExecutingOU` AS `TgtOrgUnit`
                                                                     FROM `actUsesITSvc` AS ECps0,
                                                                          `Activity` AS ECps1
                                                                     WHERE ECps0.`Activity`=ECps1.`Activity`
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM 
                                                                                ( /* case: (ECps es), with two or more elements in es.
                                                                                     compITService~;compOwner */
                                                                                  
                                                                                  SELECT DISTINCT ECps0.`ITService` AS `SrcITService`, ECps1.`compOwner` AS `TgtOrgUnit`
                                                                                  FROM `compITService` AS ECps0,
                                                                                       `Computer` AS ECps1
                                                                                  WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                ) AS cp
                                                                                WHERE isect0.`SrcITService`=cp.`SrcITService` AND isect0.`TgtOrgUnit`=cp.`TgtOrgUnit`) AND isect0.`SrcITService` IS NOT NULL AND isect0.`TgtOrgUnit` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface SvcComponent for role Developer:
      'SvcComponent' => 
      array ( 'name' => 'SvcComponent'
            // Normalized interface expression (== expressionSQL): I[SvcComponent]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('Status', 'Status', 'ITService', 'ITService', 'ITService', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'SvcComponent'
            , 'tgtConcept' => 'SvcComponent'
            , 'expressionSQL' => '/* I[SvcComponent] */
                                    SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                    FROM `SvcComponent`
                                    WHERE `SvcComponent` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'SvcComponent'
                          // Normalized interface expression (== expressionSQL): I[SvcComponent]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* I[SvcComponent] */
                                                  SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                                  FROM `SvcComponent`
                                                  WHERE `SvcComponent` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[SvcComponent]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* I[SvcComponent] */
                                                                SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                                                FROM `SvcComponent`
                                                                WHERE `SvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): scStatus
                                        , 'relation' => 'scStatus'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `scStatus` AS `tgt`
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): scMnlStat
                                        , 'relation' => 'scMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `scMnlStat` AS `tgt`
                                                              FROM `SvcComponent`
                                                              WHERE `SvcComponent` IS NOT NULL AND `scMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Used for (ITService)'
                                        // Normalized interface expression (== expressionSQL): I[SvcComponent]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'SvcComponent'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* I[SvcComponent] */
                                                                SELECT `SvcComponent` AS `src`, `SvcComponent` AS `tgt`
                                                                FROM `SvcComponent`
                                                                WHERE `SvcComponent` IS NOT NULL'
                                        // Box
                                        , 'boxSubInterfaces' =>
                                            array
                                              ( array ( 'name' => 'implements'
                                                      // Normalized interface expression (== expressionSQL): scImplements
                                                      , 'relation' => 'scImplements'
                                                      , 'relationIsFlipped' => False
                                                      , 'min' => 'Zero'
                                                      , 'max' => 'Many'
                                                      , 'srcConcept' => 'SvcComponent'
                                                      , 'tgtConcept' => 'ITService'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `ITService` AS `tgt`
                                                                            FROM `scImplements`
                                                                            WHERE `SvcComponent` IS NOT NULL AND `ITService` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'is client for'
                                                      // Normalized interface expression (== expressionSQL): scIsServerFor
                                                      , 'relation' => 'scIsServerFor'
                                                      , 'relationIsFlipped' => False
                                                      , 'min' => 'Zero'
                                                      , 'max' => 'Many'
                                                      , 'srcConcept' => 'SvcComponent'
                                                      , 'tgtConcept' => 'ITService'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `ITService` AS `tgt`
                                                                            FROM `scIsServerFor`
                                                                            WHERE `SvcComponent` IS NOT NULL AND `ITService` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              , array ( 'name' => 'is server for'
                                                      // Normalized interface expression (== expressionSQL): scIsClientFor
                                                      , 'relation' => 'scIsClientFor'
                                                      , 'relationIsFlipped' => False
                                                      , 'min' => 'Zero'
                                                      , 'max' => 'Many'
                                                      , 'srcConcept' => 'SvcComponent'
                                                      , 'tgtConcept' => 'ITService'
                                                      , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `ITService` AS `tgt`
                                                                            FROM `scIsClientFor`
                                                                            WHERE `SvcComponent` IS NOT NULL AND `ITService` IS NOT NULL'
                                                      // No subinterfaces
                                                      )
                                              )
                                        )
                                )
                          )
                  , array ( 'name' => 'Deployed on (Computer)'
                          // Normalized interface expression (== expressionSQL): scDeployedOn
                          , 'relation' => 'scDeployedOn'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'SvcComponent'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `SvcComponent` AS `src`, `Computer` AS `tgt`
                                                FROM `scDeployedOn`
                                                WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL'
                          // No subinterfaces
                          )
                  )
            )
    , // Top-level interface Computer for role Developer:
      'Computer' => 
      array ( 'name' => 'Computer'
            // Normalized interface expression (== expressionSQL): I[Computer]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('OrgUnit', 'Status', 'SvcComponent', 'Router')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Computer'
            , 'tgtConcept' => 'Computer'
            , 'expressionSQL' => '/* I[Computer] */
                                    SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                    FROM `Computer`
                                    WHERE `Computer` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'ID'
                          // Normalized interface expression (== expressionSQL): I[Computer]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* I[Computer] */
                                                  SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                                  FROM `Computer`
                                                  WHERE `Computer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer ID'
                                        // Normalized interface expression (== expressionSQL): I[Computer]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* I[Computer] */
                                                                SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                                                FROM `Computer`
                                                                WHERE `Computer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Owner'
                                        // Normalized interface expression (== expressionSQL): compOwner
                                        , 'relation' => 'compOwner'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'OrgUnit'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `compOwner` AS `tgt`
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compOwner` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): compStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `compStatus` AS `tgt`
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Toestand Update'
                                        // Normalized interface expression (== expressionSQL): compMnlStat
                                        , 'relation' => 'compMnlStat'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `compMnlStat` AS `tgt`
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `compMnlStat` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Capable of running (IT Service)'
                          // Normalized interface expression (== expressionSQL): compITService
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'ITService'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `ITService` AS `tgt`
                                                FROM `compITService`
                                                WHERE `Computer` IS NOT NULL AND `ITService` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Runs an instance of (service component)'
                          // Normalized interface expression (== expressionSQL): scDeployedOn~
                          , 'relation' => 'scDeployedOn'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'SvcComponent'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Computer` AS `src`, `SvcComponent` AS `tgt`
                                                FROM `scDeployedOn`
                                                WHERE `SvcComponent` IS NOT NULL AND `Computer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected to (Router)'
                          // Normalized interface expression (== expressionSQL): compRouter
                          , 'relation' => 'compRouter'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `Router` AS `tgt`
                                                FROM `compRouter`
                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'May need to communicate with (Computer)'
                          // Normalized interface expression (== expressionSQL): compReqCommWith
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => 'SELECT DISTINCT `SrcComputer` AS `src`, `TgtComputer` AS `tgt`
                                                FROM `compReqCommWith`
                                                WHERE `SrcComputer` IS NOT NULL AND `TgtComputer` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): I[Computer]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Computer'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* I[Computer] */
                                                  SELECT `Computer` AS `src`, `Computer` AS `tgt`
                                                  FROM `Computer`
                                                  WHERE `Computer` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Computer to connect to a router'
                                        // Normalized interface expression (== expressionSQL): connectComputerToNetworkRouter
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Computer` AS `src`, `connectComputerToNetworkRouter` AS `tgt`
                                                              FROM `Computer`
                                                              WHERE `Computer` IS NOT NULL AND `connectComputerToNetworkRouter` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Organize connectivity with (Computer)'
                                        // Normalized interface expression (== expressionSQL): compReqCommWith /\\ -compHasCommWith
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'Computer'
                                        , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                                 compReqCommWith /\\\\ -compHasCommWith ([Computer*Computer]) */
                                                              SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtComputer` AS `tgt`
                                                              FROM `compReqCommWith` AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM `compHasCommWith` AS cp
                                                                                WHERE isect0.`SrcComputer`=cp.`SrcComputer` AND isect0.`TgtComputer`=cp.`TgtComputer`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtComputer` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Suggest to install SvcComponent'
                                        // Normalization steps:
                                        //     -scDeployedOn~ /\\ compOwner;actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));(scImplements~ \\/ scIsClientFor~)
                                        // <=> { distribute ; over \\/ }
                                        //     -scDeployedOn~ /\\ compOwner;actExecutingOU~;((actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scImplements~ \\/ (actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~)
                                        // <=> { distribute ; over \\/ }
                                        //     -scDeployedOn~ /\\ compOwner;(actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scImplements~ \\/ actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~)
                                        // <=> { distribute ; over \\/ }
                                        //     -scDeployedOn~ /\\ (compOwner;actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scImplements~ \\/ compOwner;actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~)
                                        //
                                        // Normalized interface expression (== expressionSQL): -scDeployedOn~ /\\ (compOwner;actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scImplements~ \\/ compOwner;actExecutingOU~;(actUsesITSvc /\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~)
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Computer'
                                        , 'tgtConcept' => 'SvcComponent'
                                        , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                                 -scDeployedOn~ /\\\\ (compOwner;actExecutingOU~;(actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService));scImplements~ \\\\/ compOwner;actExecutingOU~;(actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~) ([Computer*SvcComponent]) */
                                                              SELECT DISTINCT isect0.`SrcComputer` AS `src`, isect0.`TgtSvcComponent` AS `tgt`
                                                              FROM 
                                                                   ( /* case: EUni (l,r)
                                                                        compOwner;actExecutingOU~;(actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService));scImplements~ \\\\/ compOwner;actExecutingOU~;(actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~ ([Computer*SvcComponent]) */
                                                                     (/* case: (ECps es), with two or more elements in es.
                                                                            compOwner;actExecutingOU~;(actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService));scImplements~ */
                                                                         
                                                                         SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps3.`SvcComponent` AS `TgtSvcComponent`
                                                                         FROM `Computer` AS ECps0,
                                                                              `Activity` AS ECps1,
                                                                              
                                                                              ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                                   actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService) ([Activity*ITService]) */
                                                                                SELECT DISTINCT isect0.`Activity` AS `SrcActivity`, isect0.`ITService` AS `TgtITService`
                                                                                FROM `actUsesITSvc` AS isect0, 
                                                                                     
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          actExecutingOU;-(compOwner~;compITService) */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtITService`
                                                                                       FROM `Activity` AS ECps0,
                                                                                            
                                                                                            ( /* case: ECpl e
                                                                                                 ECpl ( \\"compOwner~;compITService\\" ) */
                                                                                              SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`ITService` AS `TgtITService`
                                                                                              FROM `OrgUnit` AS cfst,
                                                                                                   `ITService` AS csnd
                                                                                              WHERE NOT EXISTS
                                                                                               (SELECT * FROM 
                                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                                          compOwner~;compITService */
                                                                                                       
                                                                                                       SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                                                       FROM `Computer` AS ECps0,
                                                                                                            `compITService` AS ECps1
                                                                                                       WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                                     ) AS cp
                                                                                                WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`ITService`=cp.`TgtITService`)
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`actExecutingOU`=ECps1.`SrcOrgUnit`
                                                                                     ) AS isect1
                                                                                WHERE (isect0.`Activity` = isect1.`SrcActivity` AND isect0.`ITService` = isect1.`TgtITService`) AND isect0.`Activity` IS NOT NULL AND isect0.`ITService` IS NOT NULL
                                                                              ) AS ECps2,
                                                                              `scImplements` AS ECps3
                                                                         WHERE ECps0.`compOwner`=ECps1.`actExecutingOU`
                                                                           AND ECps1.`Activity`=ECps2.`SrcActivity`
                                                                           AND ECps2.`TgtITService`=ECps3.`ITService`
                                                                     ) UNION (/* case: (ECps es), with two or more elements in es.
                                                                            compOwner;actExecutingOU~;(actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService));scIsClientFor~ */
                                                                         
                                                                         SELECT DISTINCT ECps0.`Computer` AS `SrcComputer`, ECps3.`SvcComponent` AS `TgtSvcComponent`
                                                                         FROM `Computer` AS ECps0,
                                                                              `Activity` AS ECps1,
                                                                              
                                                                              ( /* case: (EIsc lst\\\'@(_:_:_))
                                                                                   actUsesITSvc /\\\\ actExecutingOU;-(compOwner~;compITService) ([Activity*ITService]) */
                                                                                SELECT DISTINCT isect0.`Activity` AS `SrcActivity`, isect0.`ITService` AS `TgtITService`
                                                                                FROM `actUsesITSvc` AS isect0, 
                                                                                     
                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                          actExecutingOU;-(compOwner~;compITService) */
                                                                                       
                                                                                       SELECT DISTINCT ECps0.`Activity` AS `SrcActivity`, ECps1.`TgtITService`
                                                                                       FROM `Activity` AS ECps0,
                                                                                            
                                                                                            ( /* case: ECpl e
                                                                                                 ECpl ( \\"compOwner~;compITService\\" ) */
                                                                                              SELECT DISTINCT cfst.`OrgUnit` AS `SrcOrgUnit`, csnd.`ITService` AS `TgtITService`
                                                                                              FROM `OrgUnit` AS cfst,
                                                                                                   `ITService` AS csnd
                                                                                              WHERE NOT EXISTS
                                                                                               (SELECT * FROM 
                                                                                                     ( /* case: (ECps es), with two or more elements in es.
                                                                                                          compOwner~;compITService */
                                                                                                       
                                                                                                       SELECT DISTINCT ECps0.`compOwner` AS `SrcOrgUnit`, ECps1.`ITService` AS `TgtITService`
                                                                                                       FROM `Computer` AS ECps0,
                                                                                                            `compITService` AS ECps1
                                                                                                       WHERE ECps0.`Computer`=ECps1.`Computer`
                                                                                                     ) AS cp
                                                                                                WHERE cfst.`OrgUnit`=cp.`SrcOrgUnit` AND csnd.`ITService`=cp.`TgtITService`)
                                                                                            ) AS ECps1
                                                                                       WHERE ECps0.`actExecutingOU`=ECps1.`SrcOrgUnit`
                                                                                     ) AS isect1
                                                                                WHERE (isect0.`Activity` = isect1.`SrcActivity` AND isect0.`ITService` = isect1.`TgtITService`) AND isect0.`Activity` IS NOT NULL AND isect0.`ITService` IS NOT NULL
                                                                              ) AS ECps2,
                                                                              `scIsClientFor` AS ECps3
                                                                         WHERE ECps0.`compOwner`=ECps1.`actExecutingOU`
                                                                           AND ECps1.`Activity`=ECps2.`SrcActivity`
                                                                           AND ECps2.`TgtITService`=ECps3.`ITService`
                                                                     )
                                                                   ) AS isect0
                                                              WHERE NOT EXISTS (SELECT * FROM `scDeployedOn` AS cp
                                                                                WHERE isect0.`SrcComputer`=cp.`Computer` AND isect0.`TgtSvcComponent`=cp.`SvcComponent`) AND isect0.`SrcComputer` IS NOT NULL AND isect0.`TgtSvcComponent` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Router for role Developer:
      'Router' => 
      array ( 'name' => 'Router'
            // Normalized interface expression (== expressionSQL): I[Router]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('SerialNumber', 'Network', 'Location', 'Router', 'Computer')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Router'
            , 'tgtConcept' => 'Router'
            , 'expressionSQL' => '/* I[Router] */
                                    SELECT `Router` AS `src`, `Router` AS `tgt`
                                    FROM `Router`
                                    WHERE `Router` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Router'
                          // Normalized interface expression (== expressionSQL): I[Router]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* I[Router] */
                                                  SELECT `Router` AS `src`, `Router` AS `tgt`
                                                  FROM `Router`
                                                  WHERE `Router` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[Router]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => '/* I[Router] */
                                                                SELECT `Router` AS `src`, `Router` AS `tgt`
                                                                FROM `Router`
                                                                WHERE `Router` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Serial'
                                        // Normalized interface expression (== expressionSQL): routerSerial
                                        , 'relation' => 'routerSerial'
                                        , 'relationIsFlipped' => False
                                        , 'min' => 'Zero'
                                        , 'max' => 'One'
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'SerialNumber'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS `src`, `routerSerial` AS `tgt`
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerSerial` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): routerStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Router` AS `src`, `routerStatus` AS `tgt`
                                                              FROM `Router`
                                                              WHERE `Router` IS NOT NULL AND `routerStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Is part of'
                          // Normalized interface expression (== expressionSQL): routerNW
                          , 'relation' => 'routerNW'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => 'SELECT DISTINCT `Router` AS `src`, `routerNW` AS `tgt`
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Location'
                          // Normalized interface expression (== expressionSQL): routerLocation
                          , 'relation' => 'routerLocation'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'One'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Location'
                          , 'expressionSQL' => 'SELECT DISTINCT `Router` AS `src`, `routerLocation` AS `tgt`
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerLocation` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Routes (directly) to (Router)'
                          // Normalized interface expression (== expressionSQL): routerRoutesTo
                          , 'relation' => 'routerRoutesTo'
                          , 'relationIsFlipped' => False
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => 'SELECT DISTINCT `SrcRouter` AS `src`, `TgtRouter` AS `tgt`
                                                FROM `routerRoutesTo`
                                                WHERE `SrcRouter` IS NOT NULL AND `TgtRouter` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Routes (directly) to (Network)'
                          // Normalized interface expression (== expressionSQL): rrtDirect;routerNW /\\ routerNW;-I[Network]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                   rrtDirect;routerNW /\\\\ routerNW;-I[Network] ([Router*Network]) */
                                                SELECT DISTINCT isect0.`SrcRouter` AS `src`, isect0.`TgtNetwork` AS `tgt`
                                                FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          rrtDirect;routerNW */
                                                       
                                                       SELECT DISTINCT ECps0.`SrcRouter`, ECps1.`routerNW` AS `TgtNetwork`
                                                       FROM `rrtDirect` AS ECps0,
                                                            `Router` AS ECps1
                                                       WHERE ECps0.`TgtRouter`=ECps1.`Router`
                                                     ) AS isect0, 
                                                     
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          routerNW;-I[Network] */
                                                       
                                                       SELECT DISTINCT ECps0.`Router` AS `SrcRouter`, ECps2.`Network` AS `TgtNetwork`
                                                       FROM `Router` AS ECps0,
                                                            `Network` AS ECps2
                                                       WHERE ECps0.`routerNW`<>ECps2.`Network`
                                                     ) AS isect1
                                                WHERE (isect0.`SrcRouter` = isect1.`SrcRouter` AND isect0.`TgtNetwork` = isect1.`TgtNetwork`) AND isect0.`SrcRouter` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected to (Computer)'
                          // Normalized interface expression (== expressionSQL): compRouter~
                          , 'relation' => 'compRouter'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `Router` AS `src`, `Computer` AS `tgt`
                                                FROM `compRouter`
                                                WHERE `Computer` IS NOT NULL AND `Router` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Unreachable routers'
                          // Normalized interface expression (== expressionSQL): -rrtStar
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: ECpl e
                                                   ECpl ( \\"rrtStar\\" ) */
                                                SELECT DISTINCT cfst.`Router` AS `src`, csnd.`Router` AS `tgt`
                                                FROM `Router` AS cfst,
                                                     `Router` AS csnd
                                                WHERE NOT EXISTS
                                                 (SELECT * FROM `rrtStar` AS cp
                                                  WHERE cfst.`Router`=cp.`SrcRouter` AND csnd.`Router`=cp.`TgtRouter`)'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Work to do/monitor'
                          // Normalized interface expression (== expressionSQL): I[Router]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Router'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* I[Router] */
                                                  SELECT `Router` AS `src`, `Router` AS `tgt`
                                                  FROM `Router`
                                                  WHERE `Router` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'Organize connectivity with (Router)'
                                        // Normalized interface expression (== expressionSQL): routerNeedsPathTo
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Router'
                                        , 'tgtConcept' => 'Router'
                                        , 'expressionSQL' => 'SELECT DISTINCT `SrcRouter` AS `src`, `TgtRouter` AS `tgt`
                                                              FROM `routerNeedsPathTo`
                                                              WHERE `SrcRouter` IS NOT NULL AND `TgtRouter` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  )
            )
    , // Top-level interface Network for role Developer:
      'Network' => 
      array ( 'name' => 'Network'
            // Normalized interface expression (== expressionSQL): I[Network]
            , 'interfaceRoles' => array ('Developer')
            , 'editableConcepts' => array ('Router')
            , 'relation' => ''
            , 'relationIsFlipped' => ''
            , 'srcConcept' => 'Network'
            , 'tgtConcept' => 'Network'
            , 'expressionSQL' => '/* I[Network] */
                                    SELECT `Network` AS `src`, `Network` AS `tgt`
                                    FROM `Network`
                                    WHERE `Network` IS NOT NULL'
            // Box
            , 'boxSubInterfaces' =>
                array
                  ( array ( 'name' => 'Network'
                          // Normalized interface expression (== expressionSQL): I[Network]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* I[Network] */
                                                  SELECT `Network` AS `src`, `Network` AS `tgt`
                                                  FROM `Network`
                                                  WHERE `Network` IS NOT NULL'
                          // Box
                          , 'boxSubInterfaces' =>
                              array
                                ( array ( 'name' => 'ID'
                                        // Normalized interface expression (== expressionSQL): I[Network]
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Network'
                                        , 'expressionSQL' => '/* I[Network] */
                                                                SELECT `Network` AS `src`, `Network` AS `tgt`
                                                                FROM `Network`
                                                                WHERE `Network` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                , array ( 'name' => 'Status (Status)'
                                        // Normalized interface expression (== expressionSQL): nwStatus
                                        , 'relation' => ''
                                        , 'relationIsFlipped' => ''
                                        , 'srcConcept' => 'Network'
                                        , 'tgtConcept' => 'Status'
                                        , 'expressionSQL' => 'SELECT DISTINCT `Network` AS `src`, `nwStatus` AS `tgt`
                                                              FROM `Network`
                                                              WHERE `Network` IS NOT NULL AND `nwStatus` IS NOT NULL'
                                        // No subinterfaces
                                        )
                                )
                          )
                  , array ( 'name' => 'Routers'
                          // Normalized interface expression (== expressionSQL): routerNW~
                          , 'relation' => 'routerNW'
                          , 'relationIsFlipped' => True
                          , 'min' => 'Zero'
                          , 'max' => 'Many'
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Router'
                          , 'expressionSQL' => '/* case: EFlp x. */
                                                SELECT DISTINCT `routerNW` AS `src`, `Router` AS `tgt`
                                                FROM `Router`
                                                WHERE `Router` IS NOT NULL AND `routerNW` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected Networks'
                          // Normalized interface expression (== expressionSQL): routerNW~;rrtDirect;routerNW /\\ -I[Network]
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Network'
                          , 'expressionSQL' => '/* case: (EIsc lst\\\'@(_:_:_))
                                                   routerNW~;rrtDirect;routerNW /\\\\ -I[Network] ([Network*Network]) */
                                                SELECT DISTINCT isect0.`SrcNetwork` AS `src`, isect0.`TgtNetwork` AS `tgt`
                                                FROM 
                                                     ( /* case: (ECps es), with two or more elements in es.
                                                          routerNW~;rrtDirect;routerNW */
                                                       
                                                       SELECT DISTINCT ECps0.`routerNW` AS `SrcNetwork`, ECps2.`routerNW` AS `TgtNetwork`
                                                       FROM `Router` AS ECps0,
                                                            `rrtDirect` AS ECps1,
                                                            `Router` AS ECps2
                                                       WHERE ECps0.`Router`=ECps1.`SrcRouter`
                                                         AND ECps1.`TgtRouter`=ECps2.`Router`
                                                     ) AS isect0
                                                WHERE isect0.`SrcNetwork` <> isect0.`TgtNetwork` AND isect0.`SrcNetwork` IS NOT NULL AND isect0.`TgtNetwork` IS NOT NULL'
                          // No subinterfaces
                          )
                  , array ( 'name' => 'Connected Computers'
                          // Normalized interface expression (== expressionSQL): routerNW~;compRouter~
                          , 'relation' => ''
                          , 'relationIsFlipped' => ''
                          , 'srcConcept' => 'Network'
                          , 'tgtConcept' => 'Computer'
                          , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.
                                                   routerNW~;compRouter~ */
                                                
                                                SELECT DISTINCT ECps0.`routerNW` AS `src`, ECps1.`Computer` AS `tgt`
                                                FROM `Router` AS ECps0,
                                                     `compRouter` AS ECps1
                                                WHERE ECps0.`Router`=ECps1.`Router`'
                          // No subinterfaces
                          )
                  )
            )
    );
?>
